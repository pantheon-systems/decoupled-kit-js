{"version":3,"sources":["../../../../src/datastore/lmdb/query/common.ts"],"names":["isDesc","sortOrder","resolveFieldValue","dottedFieldPath","nodeOrThunk","resolvedNodeFields","result","node","matchesFilter","filter","fieldValue","comparator","DbComparator","EQ","value","IN","arr","Array","isArray","some","v","GT","compareKey","GTE","LT","LTE","NE","NIN","every","REGEX","RegExp","test","String","cartesianProduct","reduce","a","b","flatMap","d","map","e","typeOrder","symbol","undefined","boolean","number","string","arrayComparison","i","Symbol","keyFor"],"mappings":"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","sourcesContent":["import { DbComparator, IDbFilterStatement } from \"../../common/query\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { getValueAt } from \"../../../utils/get-value-at\"\n\nexport function isDesc(\n  sortOrder: \"asc\" | \"desc\" | \"ASC\" | \"DESC\" | boolean | void\n): boolean {\n  return sortOrder === `desc` || sortOrder === `DESC` || sortOrder === false\n}\n\n/**\n * Given dotted field selector (e.g. `foo.bar`) returns a plain list of values matching this selector.\n * It is possible that the path maps to several values when one of the intermediate values is an array.\n *\n * Example node:\n * {\n *   foo: [{ bar: `bar1`}, { bar: `bar2` }]\n * }\n *\n * In this case resolveFieldValue([`foo`, `bar`], node) returns [`bar1`, `bar2`]\n *\n * When `resolvedNodeFields` argument is passed the function first looks for values in this object\n * and only looks in the node if the value is not found in `resolvedNodeFields`\n */\nexport function resolveFieldValue(\n  dottedFieldPath: string | Array<string>,\n  nodeOrThunk: IGatsbyNode | (() => IGatsbyNode),\n  resolvedNodeFields?: { [field: string]: unknown }\n): unknown {\n  let result\n  if (resolvedNodeFields) {\n    result = getValueAt(resolvedNodeFields, dottedFieldPath)\n  }\n  if (typeof result !== `undefined`) {\n    return result\n  }\n  const node = typeof nodeOrThunk === `function` ? nodeOrThunk() : nodeOrThunk\n  return getValueAt(node, dottedFieldPath)\n}\n\nexport function matchesFilter(\n  filter: IDbFilterStatement,\n  fieldValue: unknown\n): boolean {\n  switch (filter.comparator) {\n    case DbComparator.EQ:\n      return filter.value === null\n        ? filter.value == fieldValue\n        : filter.value === fieldValue\n    case DbComparator.IN: {\n      const arr = Array.isArray(filter.value) ? filter.value : [filter.value]\n      return arr.some(v => (v === null ? v == fieldValue : v === fieldValue))\n    }\n    case DbComparator.GT:\n      return compareKey(fieldValue, filter.value) > 0\n    case DbComparator.GTE:\n      return compareKey(fieldValue, filter.value) >= 0\n    case DbComparator.LT:\n      return compareKey(fieldValue, filter.value) < 0\n    case DbComparator.LTE:\n      return compareKey(fieldValue, filter.value) <= 0\n    case DbComparator.NE:\n    case DbComparator.NIN: {\n      const arr = Array.isArray(filter.value) ? filter.value : [filter.value]\n      return arr.every(v => (v === null ? v != fieldValue : v !== fieldValue))\n    }\n    case DbComparator.REGEX: {\n      if (typeof fieldValue !== `undefined` && filter.value instanceof RegExp) {\n        return filter.value.test(String(fieldValue))\n      }\n      return false\n    }\n  }\n  return false\n}\n\nexport function cartesianProduct(...arr: Array<Array<any>>): Array<any> {\n  return arr.reduce((a, b) => a.flatMap(d => b.map(e => [...d, e])), [[]])\n}\n\nconst typeOrder = {\n  symbol: 0,\n  undefined: 1,\n  boolean: 2,\n  number: 3,\n  string: 4,\n}\n\n// Note: this is a copy of this function from lmdb-store:\n// https://github.com/DoctorEvidence/lmdb-store/blob/e1e53d6d2012ec22071a8fb7fa3b47f8886b22d2/index.js#L1259-L1300\n// We need it here to avoid imports from \"lmdb-store\" while it is not a direct dependency\n// FIXME: replace with an import in v4\nexport function compareKey(a: unknown, b: unknown): number {\n  // compare with type consistency that matches ordered-binary\n  if (typeof a == `object`) {\n    if (!a) {\n      return b == null ? 0 : -1\n    }\n    if (a[`compare`]) {\n      if (b == null) {\n        return 1\n      } else if (typeof b === `object` && b !== null && b[`compare`]) {\n        return a[`compare`](b)\n      } else {\n        return -1\n      }\n    }\n    let arrayComparison\n    if (b instanceof Array) {\n      let i = 0\n      while (\n        (arrayComparison = compareKey(a[i], b[i])) == 0 &&\n        i <= a[`length`]\n      ) {\n        i++\n      }\n      return arrayComparison\n    }\n    arrayComparison = compareKey(a[0], b)\n    if (arrayComparison == 0 && a[`length`] > 1) return 1\n    return arrayComparison\n  } else if (typeof a == typeof b) {\n    if (typeof a === `symbol` && typeof b === `symbol`) {\n      a = Symbol.keyFor(a)\n      b = Symbol.keyFor(b)\n    }\n    return (a as any) < (b as any) ? -1 : a === b ? 0 : 1\n  } else if (typeof b == `object`) {\n    if (b instanceof Array) return -compareKey(b, a)\n    return 1\n  } else {\n    return typeOrder[typeof a] < typeOrder[typeof b] ? -1 : 1\n  }\n}\n"],"file":"common.js"}
{"version":3,"sources":["../../../../src/steps/source-nodes/update-nodes/find-connected-nodes.js"],"names":["recursivelySearchForIds","key","value","Array","isArray","map","innerValue","Object","values","entries","findConnectedNodeIds","node","childNodeIds","Set","filter","id","length"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;AAEA;AAEA;AAEA,MAAMA,uBAAuB,GAAG,CAAC,CAACC,GAAD,EAAMC,KAAN,CAAD,KAAkB;AAChD,MAAI,CAACD,GAAD,IAAQ,CAACC,KAAb,EAAoB;AAClB,WAAO,IAAP;AACD;;AAED,MAAID,GAAG,KAAM,IAAb,EAAkB;AAChB,WAAOC,KAAP;AACD,GAFD,MAEO,IAAI,OAAOA,KAAP,KAAkB,QAAlB,IAA6B,OAAOA,KAAP,KAAkB,QAAnD,EAA4D;AACjE,WAAO,IAAP;AACD;;AAED,MAAIC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACxB,sBAAKD,GAAL,EADwB,CAExB;AACA;;AACAC,IAAAA,KAAK,CAACG,GAAN,CAAUC,UAAU,IAAI;AACtB,UAAIA,UAAU,KAAK,IAAnB,EAAyB;AACvB,eAAO,IAAP;AACD;;AAED,UAAIL,GAAG,KAAM,IAAT,IAAgB,OAAOK,UAAP,KAAuB,QAA3C,EAAoD;AAClD,eAAOA,UAAP;AACD;;AAED,UAAI,OAAOA,UAAP,KAAuB,QAA3B,EAAoC;AAClC,eAAOC,MAAM,CAACC,MAAP,CAAcF,UAAd,EAA0BD,GAA1B,CAA8BL,uBAA9B,CAAP;AACD;;AAED,aAAO,IAAP;AACD,KAdD;AAeD,GAnBD,MAmBO,IAAI,OAAOE,KAAP,KAAkB,QAAtB,EAA+B;AACpC,sBAAKD,GAAL;AACA,WAAOM,MAAM,CAACE,OAAP,CAAeP,KAAf,EAAsBG,GAAtB,CAA0BL,uBAA1B,CAAP;AACD;;AAED,SAAO,IAAP;AACD,CApCD;;AAsCO,MAAMU,oBAAoB,GAAGC,IAAI,IAAI;AAC1C,QAAMC,YAAY,GAAG,CACnB,GAAG,IAAIC,GAAJ,CACD,0BAAYN,MAAM,CAACE,OAAP,CAAeE,IAAf,EAAqBN,GAArB,CAAyBL,uBAAzB,CAAZ,EAA+Dc,MAA/D,CACEC,EAAE,IAAIA,EAAE,KAAKJ,IAAI,CAACI,EAAZ,IAAkB,CAAC,CAACA,EAD5B,CADC,CADgB,CAArB;;AAQA,MAAI,CAACH,YAAY,CAACI,MAAlB,EAA0B;AACxB,WAAO,IAAP;AACD;;AAED,SAAOJ,YAAP;AACD,CAdM","sourcesContent":["import flattenDeep from \"lodash/flattenDeep\"\nimport { dump } from \"dumper.js\"\n\n// After all nodes are created while building the schema, store possible node type relationships. So for example when building the WpPost type, for every gatsby node discovered as a potential connected node type WpPost's fields, record that in redux as WpPost => [...ConnectedTypeNames].\n\n// when creating or updating a Page incrementally, we should find all connected node ids, check the types of each of those id's, if any connected id type has the current node type as a potential connected node type, AND this node is not a connected node of that node, we should refetch that node in case it's now a connected node.\n\n// So we create a new Page, we then check the connected node id's and determine that one of them is a User type. The User type has Page as a potential connected node. So we check if this node is a connected node of that node. If it's not we can't be sure that that User node isn't missing this node as a connected node. So we refetch the connected node of our Page which is a User. Do this for all connected nodes where we can't find a relationship back.\n\nconst recursivelySearchForIds = ([key, value]) => {\n  if (!key || !value) {\n    return null\n  }\n\n  if (key === `id`) {\n    return value\n  } else if (typeof value === `string` || typeof value === `number`) {\n    return null\n  }\n\n  if (Array.isArray(value)) {\n    dump(key)\n    // loop through each value of the array. If it's an object recurse on it's fields\n    // if it's anything else skip it.\n    value.map(innerValue => {\n      if (innerValue === null) {\n        return null\n      }\n\n      if (key === `id` && typeof innerValue === `string`) {\n        return innerValue\n      }\n\n      if (typeof innerValue === `object`) {\n        return Object.values(innerValue).map(recursivelySearchForIds)\n      }\n\n      return null\n    })\n  } else if (typeof value === `object`) {\n    dump(key)\n    return Object.entries(value).map(recursivelySearchForIds)\n  }\n\n  return null\n}\n\nexport const findConnectedNodeIds = node => {\n  const childNodeIds = [\n    ...new Set(\n      flattenDeep(Object.entries(node).map(recursivelySearchForIds)).filter(\n        id => id !== node.id && !!id\n      )\n    ),\n  ]\n\n  if (!childNodeIds.length) {\n    return null\n  }\n\n  return childNodeIds\n}\n"],"file":"find-connected-nodes.js"}
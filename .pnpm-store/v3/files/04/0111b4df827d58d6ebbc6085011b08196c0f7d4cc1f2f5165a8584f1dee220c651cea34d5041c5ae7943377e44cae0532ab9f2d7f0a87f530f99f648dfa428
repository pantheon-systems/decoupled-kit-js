{"version":3,"sources":["../../src/utils/find-page-by-path.ts"],"names":["findBestMatchingPage","pages","path","pagesByMatchPath","page","values","matchPath","routes","Object","keys","map","picked","route","findPageByPath","state","fallbackTo404","get","hasLeadingSlash","startsWith","hasTrailingSlash","endsWith","bare","slice","length","some","potentialPath","matchingPage","undefined"],"mappings":";;;;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,oBAAoB,GAAG,CAC3BC,KAD2B,EAE3BC,IAF2B,KAGJ;AACvB;AACA;AACA,QAAMC,gBAA6C,GAAG,EAAtD;;AACA,OAAK,MAAMC,IAAX,IAAmBH,KAAK,CAACI,MAAN,EAAnB,EAAmC;AACjC,UAAMC,SAAS,GAAGF,IAAI,CAACE,SAAvB;;AACA,QAAIA,SAAJ,EAAe;AACbH,MAAAA,gBAAgB,CAACG,SAAD,CAAhB,GAA8BF,IAA9B;AACD;AACF;;AAED,QAAMG,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYN,gBAAZ,EAA8BO,GAA9B,CAAkCR,IAAI,IAAI;AACvD,WAAO;AAAEA,MAAAA;AAAF,KAAP;AACD,GAFc,CAAf,CAXuB,CAevB;;AACA,QAAMS,MAAM,GAAG,iBAAKJ,MAAL,EAAaL,IAAb,CAAf;;AAEA,MAAIS,MAAJ,EAAY;AACV,WAAOR,gBAAgB,CAACQ,MAAM,CAACC,KAAP,CAAaV,IAAd,CAAvB;AACD;;AAED,SAAO,IAAP;AACD,CA1BD;;AA4BO,SAASW,cAAT,CACLC,KADK,EAELZ,IAFK,EAGLa,aAAsB,GAAG,KAHpB,EAIoB;AACzB,QAAM;AAAEd,IAAAA;AAAF,MAAYa,KAAlB,CADyB,CAGzB;;AACA,MAAIV,IAAI,GAAGH,KAAK,CAACe,GAAN,CAAUd,IAAV,CAAX;;AACA,MAAIE,IAAJ,EAAU;AACR,WAAOA,IAAP;AACD;;AAED,MAAIF,IAAI,KAAM,EAAd,EAAiB;AACf;AACA;AACA;AACAE,IAAAA,IAAI,GAAGH,KAAK,CAACe,GAAN,CAAW,GAAX,CAAP;;AACA,QAAIZ,IAAJ,EAAU;AACR,aAAOA,IAAP;AACD;AACF,GARD,CASA;AACA;AACA;AAXA,OAYK,IAAIF,IAAI,KAAM,GAAd,EAAkB;AACrB;AACA,UAAMe,eAAe,GAAGf,IAAI,CAACgB,UAAL,CAAiB,GAAjB,CAAxB;AACA,UAAMC,gBAAgB,GAAGjB,IAAI,CAACkB,QAAL,CAAe,GAAf,CAAzB;AAEA,UAAMC,IAAI,GAAGnB,IAAI,CAACoB,KAAL,CACXL,eAAe,GAAG,CAAH,GAAO,CADX,EAEXE,gBAAgB,GAAG,CAAC,CAAJ,GAAQjB,IAAI,CAACqB,MAFlB,CAAb;AAKC,KAACF,IAAD,EAAQ,GAAD,GAAMA,IAAb,EAAmBA,IAAI,GAAI,GAA3B,EAAgC,GAAD,GAAMA,IAAN,GAAc,GAA7C,EAAiDG,IAAjD,CAAsDC,aAAa,IAAI;AACtErB,MAAAA,IAAI,GAAGH,KAAK,CAACe,GAAN,CAAUS,aAAV,CAAP;AACA,aAAO,CAAC,CAACrB,IAAT;AACD,KAHA;;AAID,QAAIA,IAAJ,EAAU;AACR,aAAOA,IAAP;AACD;AACF,GAtCwB,CAwCzB;AACA;AACA;AACA;AACA;;;AACA,QAAMsB,YAAY,GAAG1B,oBAAoB,CAACC,KAAD,EAAQC,IAAR,CAAzC;;AAEA,MAAIwB,YAAJ,EAAkB;AAChB,WAAOA,YAAP;AACD;;AAED,MAAIX,aAAJ,EAAmB;AAAA;;AACjB,8BACEF,cAAc,CAACC,KAAD,EAAS,gBAAT,EAA0B,KAA1B,CADhB,6DAEED,cAAc,CAACC,KAAD,EAAS,WAAT,EAAqB,KAArB,CAFhB;AAID;;AACD,SAAOa,SAAP;AACD","sourcesContent":["import { IGatsbyPage, IGatsbyState } from \"../redux/types\"\nimport { pick } from \"@gatsbyjs/reach-router/lib/utils\"\n\n// Ranks and picks the best page to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our pages, let the\n// computers do it.\n//\n// In the future, we could move this pagesByMatchPath computation outside this\n// function and save some processing power\nconst findBestMatchingPage = (\n  pages: Map<string, IGatsbyPage>,\n  path: string\n): IGatsbyPage | null => {\n  // Pick only routes with matchPath for better performance.\n  // Exact match should have already been checked\n  const pagesByMatchPath: Record<string, IGatsbyPage> = {}\n  for (const page of pages.values()) {\n    const matchPath = page.matchPath\n    if (matchPath) {\n      pagesByMatchPath[matchPath] = page\n    }\n  }\n\n  const routes = Object.keys(pagesByMatchPath).map(path => {\n    return { path }\n  })\n\n  // picks best matching route with reach router's algorithm\n  const picked = pick(routes, path)\n\n  if (picked) {\n    return pagesByMatchPath[picked.route.path]\n  }\n\n  return null\n}\n\nexport function findPageByPath(\n  state: IGatsbyState,\n  path: string,\n  fallbackTo404: boolean = false\n): IGatsbyPage | undefined {\n  const { pages } = state\n\n  // first check by exact path\n  let page = pages.get(path)\n  if (page) {\n    return page\n  }\n\n  if (path === ``) {\n    // from my tests I never was able to make request with\n    // completely empty pathname, but just for the sake\n    // of completeness - try available alternative\n    page = pages.get(`/`)\n    if (page) {\n      return page\n    }\n  }\n  // Gatsby doesn't allow for page path to be empty string,\n  // so skipping trying to get page for \"\" path if we can't\n  // find page for `/`\n  else if (path !== `/`) {\n    // check various trailing/leading slashes combinations\n    const hasLeadingSlash = path.startsWith(`/`)\n    const hasTrailingSlash = path.endsWith(`/`)\n\n    const bare = path.slice(\n      hasLeadingSlash ? 1 : 0,\n      hasTrailingSlash ? -1 : path.length\n    )\n\n    ;[bare, `/` + bare, bare + `/`, `/` + bare + `/`].some(potentialPath => {\n      page = pages.get(potentialPath)\n      return !!page\n    })\n    if (page) {\n      return page\n    }\n  }\n\n  // we didn't find exact static page, time to check matchPaths\n  // TODO: consider using `match-paths.json` generated by `requires-writer`\n  // to avoid looping through all pages again. Ideally generate smaller `match-paths.json`\n  // variant that doesn't including overlapping static pages in `requires-writer` as well\n  // as this function already checked static paths at this point\n  const matchingPage = findBestMatchingPage(pages, path)\n\n  if (matchingPage) {\n    return matchingPage\n  }\n\n  if (fallbackTo404) {\n    return (\n      findPageByPath(state, `/dev-404-page/`, false) ??\n      findPageByPath(state, `/404.html`, false)\n    )\n  }\n  return undefined\n}\n"],"file":"find-page-by-path.js"}
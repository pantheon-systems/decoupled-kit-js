{"version":3,"sources":["../../../src/redux/reducers/html.ts"],"names":["FLAG_DIRTY_CLEARED_CACHE","FLAG_DIRTY_NEW_PAGE","FLAG_DIRTY_PAGE_DATA_CHANGED","FLAG_DIRTY_STATIC_QUERY_FIRST_RUN","FLAG_DIRTY_STATIC_QUERY_RESULT_CHANGED","FLAG_DIRTY_BROWSER_COMPILATION_HASH","FLAG_DIRTY_SSR_COMPILATION_HASH","initialState","trackedHtmlFiles","Map","browserCompilationHash","ssrCompilationHash","trackedStaticQueryResults","unsafeBuiltinWasUsedInSSR","htmlReducer","state","action","type","cacheIsCorrupt","clear","forEach","htmlFile","isDeleted","dirty","path","payload","get","pageDataHash","set","Error","isPage","staticQueryResult","queryHash","staticQueryResultHash","resultHash","pagePath","delete","pages","staticQueryHash","staticQueryHashes"],"mappings":"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","sourcesContent":["import {\n  ActionsUnion,\n  IGatsbyState,\n  IHtmlFileState,\n  IStaticQueryResultState,\n} from \"../types\"\n\nconst FLAG_DIRTY_CLEARED_CACHE = 0b0000001\nconst FLAG_DIRTY_NEW_PAGE = 0b0000010\nconst FLAG_DIRTY_PAGE_DATA_CHANGED = 0b0000100\nconst FLAG_DIRTY_STATIC_QUERY_FIRST_RUN = 0b0001000\nconst FLAG_DIRTY_STATIC_QUERY_RESULT_CHANGED = 0b0010000\nconst FLAG_DIRTY_BROWSER_COMPILATION_HASH = 0b0100000\nconst FLAG_DIRTY_SSR_COMPILATION_HASH = 0b1000000\n\ntype PagePath = string\n\nfunction initialState(): IGatsbyState[\"html\"] {\n  return {\n    trackedHtmlFiles: new Map<PagePath, IHtmlFileState>(),\n    browserCompilationHash: ``,\n    ssrCompilationHash: ``,\n    trackedStaticQueryResults: new Map<string, IStaticQueryResultState>(),\n    unsafeBuiltinWasUsedInSSR: false,\n  }\n}\n\nexport function htmlReducer(\n  state: IGatsbyState[\"html\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"html\"] {\n  switch (action.type) {\n    case `DELETE_CACHE`: {\n      if (action.cacheIsCorrupt) {\n        // `public` doesn't exist so we can start fresh\n        return initialState()\n      } else {\n        // we can't just clear the cache here - we want to keep track of pages, so we mark them all as \"deleted\"\n        // if they are recreated \"isDeleted\" flag will be removed\n        state.browserCompilationHash = ``\n        state.ssrCompilationHash = ``\n        state.trackedStaticQueryResults.clear()\n        state.unsafeBuiltinWasUsedInSSR = false\n        state.trackedHtmlFiles.forEach(htmlFile => {\n          htmlFile.isDeleted = true\n          // there was a change somewhere, so just in case we mark those files are dirty as well\n          htmlFile.dirty |= FLAG_DIRTY_CLEARED_CACHE\n        })\n        return state\n      }\n    }\n\n    case `CREATE_PAGE`: {\n      // CREATE_PAGE can be called even if page already exist, so we only want to do anything\n      // if we don't track given page yet or if page is marked as deleted\n      const { path } = action.payload\n\n      let htmlFile = state.trackedHtmlFiles.get(path)\n      if (!htmlFile) {\n        htmlFile = {\n          dirty: FLAG_DIRTY_NEW_PAGE,\n          isDeleted: false,\n          pageDataHash: ``,\n        }\n        state.trackedHtmlFiles.set(path, htmlFile)\n      } else if (htmlFile.isDeleted) {\n        // page was recreated so we remove `isDeleted` flag\n        // TBD if dirtiness need to change\n        htmlFile.isDeleted = false\n      }\n\n      return state\n    }\n\n    case `DELETE_PAGE`: {\n      const { path } = action.payload\n      const htmlFile = state.trackedHtmlFiles.get(path)\n\n      if (!htmlFile) {\n        // invariant\n        throw new Error(\n          `[html reducer] how can I delete page that wasn't created (?)`\n        )\n      }\n\n      htmlFile.isDeleted = true\n      // TBD if dirtiness need to change\n      return state\n    }\n\n    case `PAGE_QUERY_RUN`: {\n      // Despite action name, this action is actually emitted for both page and static queries.\n      // In here we actually only care about static query result (particularly its hash).\n      // We don't care about page query result because we don't actually use page query result\n      // directly when generating html. We care about page-data (which contains page query result).\n      // Handling of page-data that transitively handles page query result is done in handler for\n      // `ADD_PAGE_DATA_STATS` action.\n      if (!action.payload.isPage) {\n        // static query case\n        let staticQueryResult = state.trackedStaticQueryResults.get(\n          action.payload.queryHash\n        )\n        if (!staticQueryResult) {\n          staticQueryResult = {\n            dirty: FLAG_DIRTY_STATIC_QUERY_FIRST_RUN,\n            staticQueryResultHash: action.payload.resultHash,\n          }\n          state.trackedStaticQueryResults.set(\n            action.payload.queryHash,\n            staticQueryResult\n          )\n        } else if (\n          staticQueryResult.staticQueryResultHash !== action.payload.resultHash\n        ) {\n          staticQueryResult.dirty |= FLAG_DIRTY_STATIC_QUERY_RESULT_CHANGED\n          staticQueryResult.staticQueryResultHash = action.payload.resultHash\n        }\n      }\n\n      return state\n    }\n    case `ADD_PAGE_DATA_STATS`: {\n      const htmlFile = state.trackedHtmlFiles.get(action.payload.pagePath)\n      if (!htmlFile) {\n        // invariant\n        throw new Error(\n          `[html reducer] I received event that query for a page finished running, but I'm not aware of the page it ran for (?)`\n        )\n      }\n\n      if (htmlFile.pageDataHash !== action.payload.pageDataHash) {\n        htmlFile.pageDataHash = action.payload.pageDataHash\n        htmlFile.dirty |= FLAG_DIRTY_PAGE_DATA_CHANGED\n      }\n      return state\n    }\n\n    case `SET_WEBPACK_COMPILATION_HASH`: {\n      if (state.browserCompilationHash !== action.payload) {\n        state.browserCompilationHash = action.payload\n        state.trackedHtmlFiles.forEach(htmlFile => {\n          htmlFile.dirty |= FLAG_DIRTY_BROWSER_COMPILATION_HASH\n        })\n      }\n      return state\n    }\n\n    case `SET_SSR_WEBPACK_COMPILATION_HASH`: {\n      if (state.ssrCompilationHash !== action.payload) {\n        state.ssrCompilationHash = action.payload\n        // we will mark every html file as dirty, so we can safely reset\n        // unsafeBuiltinWasUsedInSSR flag, which might be set again if\n        // ssr bundle continue to use those\n        state.unsafeBuiltinWasUsedInSSR = false\n        state.trackedHtmlFiles.forEach(htmlFile => {\n          htmlFile.dirty |= FLAG_DIRTY_SSR_COMPILATION_HASH\n        })\n      }\n      return state\n    }\n\n    case `HTML_REMOVED`: {\n      state.trackedHtmlFiles.delete(action.payload)\n      return state\n    }\n\n    case `HTML_TRACKED_PAGES_CLEANUP`: {\n      // this is to cleanup variants of page paths that don't result in artifacts deletion\n      // but page path should be pruned for cases like page changing path from \"/foo\" to \"/foo/\" (or vice versa)\n      // where produced artifacts filenames are the same and we don't want to delete them after building,\n      // but we still want to cleanup state here.\n      for (const path of action.payload) {\n        state.trackedHtmlFiles.delete(path)\n      }\n      return state\n    }\n\n    case `HTML_GENERATED`: {\n      for (const path of action.payload) {\n        const htmlFile = state.trackedHtmlFiles.get(path)\n        if (htmlFile) {\n          htmlFile.dirty = 0\n        }\n      }\n\n      return state\n    }\n\n    case `HTML_MARK_DIRTY_BECAUSE_STATIC_QUERY_RESULT_CHANGED`: {\n      // mark pages as dirty\n      for (const path of action.payload.pages) {\n        const htmlFile = state.trackedHtmlFiles.get(path)\n        if (htmlFile) {\n          htmlFile.dirty |= FLAG_DIRTY_STATIC_QUERY_RESULT_CHANGED\n        }\n      }\n\n      // mark static queries as not dirty anymore (we flushed their dirtiness into pages)\n      for (const staticQueryHash of action.payload.staticQueryHashes) {\n        const staticQueryResult =\n          state.trackedStaticQueryResults.get(staticQueryHash)\n        if (staticQueryResult) {\n          staticQueryResult.dirty = 0\n        }\n      }\n      return state\n    }\n\n    case `SSR_USED_UNSAFE_BUILTIN`: {\n      state.unsafeBuiltinWasUsedInSSR = true\n      return state\n    }\n  }\n  return state\n}\n"],"file":"html.js"}
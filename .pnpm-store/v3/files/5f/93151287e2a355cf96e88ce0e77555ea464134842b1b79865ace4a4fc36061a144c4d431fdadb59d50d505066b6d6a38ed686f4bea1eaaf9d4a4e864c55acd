{"version":3,"sources":["../../src/commands/build-utils.ts"],"names":["checkFolderIsEmpty","path","fs","existsSync","readdirSync","length","checkAndRemoveEmptyDir","publicDir","pagePath","pageHtmlDirectory","dirname","pageDataDirectory","join","removeSync","sortedPageKeysByNestedLevel","pageKeys","sort","a","b","currentPagePathValue","split","previousPagePathValue","removePageFiles","removePages","map","removePromise","then","store","dispatch","type","payload","removePageDataList","Promise","all","forEach","FSisCaseInsensitive","process","env","TEST_FORCE_CASE_FS","normalizePagePath","toLowerCase","endsWith","slice","pageGenerationActionPriority","regenerate","reuse","delete","calcDirtyHtmlFiles","state","toRegenerate","Set","toDelete","toCleanupFromTrackedState","normalizedPagePathToAction","Map","markActionForPage","action","normalizedPagePath","previousAction","get","overwritePreviousAction","previousActionPriority","currentActionPriority","add","actualPath","set","html","unsafeBuiltinWasUsedInSSR","reporter","warn","trackedHtmlFiles","htmlFile","page","pages","isDeleted","dirty","Array","from","markHtmlDirtyIfResultOfUsedStaticQueryChanged","getState","dirtyStaticQueryResults","trackedStaticQueryResults","staticQueryResultState","staticQueryHash","dirtyTemplates","staticQueriesByTemplate","staticQueryHashes","componentPath","dirtyStaticQueryHash","includes","dirtyPages","dirtyTemplate","component","components"],"mappings":"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","sourcesContent":["import fs from \"fs-extra\"\nimport path from \"path\"\nimport { platform } from \"os\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport {\n  remove as removePageHtmlFile,\n  generateHtmlPath,\n  fixedPagePath,\n} from \"gatsby-core-utils\"\nimport { removePageData } from \"../utils/page-data\"\nimport { store } from \"../redux\"\nimport { IGatsbyState } from \"../redux/types\"\nimport { getPageMode } from \"../utils/page-mode\"\n\nconst checkFolderIsEmpty = (path: string): boolean =>\n  fs.existsSync(path) && !fs.readdirSync(path).length\n\nconst checkAndRemoveEmptyDir = (publicDir: string, pagePath: string): void => {\n  const pageHtmlDirectory = path.dirname(generateHtmlPath(publicDir, pagePath))\n  const pageDataDirectory = path.join(\n    publicDir,\n    `page-data`,\n    fixedPagePath(pagePath)\n  )\n  // if page's folder is empty also remove matching page-data folder\n  if (checkFolderIsEmpty(pageHtmlDirectory)) {\n    fs.removeSync(pageHtmlDirectory)\n  }\n  if (checkFolderIsEmpty(pageDataDirectory)) {\n    fs.removeSync(pageDataDirectory)\n  }\n}\n\nconst sortedPageKeysByNestedLevel = (pageKeys: Array<string>): Array<string> =>\n  pageKeys.sort((a, b) => {\n    const currentPagePathValue = a.split(`/`).length\n    const previousPagePathValue = b.split(`/`).length\n    return previousPagePathValue - currentPagePathValue\n  })\n\nexport const removePageFiles = async (\n  publicDir: string,\n  pageKeys: Array<string>\n): Promise<void> => {\n  const removePages = pageKeys.map(pagePath => {\n    const removePromise = removePageHtmlFile({ publicDir }, pagePath)\n    removePromise.then(() => {\n      store.dispatch({\n        type: `HTML_REMOVED`,\n        payload: pagePath,\n      })\n    })\n    return removePromise\n  })\n\n  const removePageDataList = pageKeys.map(pagePath =>\n    removePageData(publicDir, pagePath)\n  )\n\n  return Promise.all([...removePages, ...removePageDataList]).then(() => {\n    // Sort removed pageKeys by nested directories and remove if empty.\n    sortedPageKeysByNestedLevel(pageKeys).forEach(pagePath => {\n      checkAndRemoveEmptyDir(publicDir, pagePath)\n    })\n  })\n}\n\nconst FSisCaseInsensitive = process.env.TEST_FORCE_CASE_FS\n  ? process.env.TEST_FORCE_CASE_FS === `INSENSITIVE`\n  : platform() === `win32` || platform() === `darwin`\nfunction normalizePagePath(path: string): string {\n  if (path === `/`) {\n    return `/`\n  }\n\n  if (FSisCaseInsensitive) {\n    // e.g. /TEST/ and /test/ would produce \"same\" artifacts on case insensitive\n    // file systems\n    path = path.toLowerCase()\n  }\n\n  return path.endsWith(`/`) ? path.slice(0, -1) : path\n}\n\ntype PageGenerationAction = \"delete\" | \"regenerate\" | \"reuse\"\nconst pageGenerationActionPriority: Record<PageGenerationAction, number> = {\n  // higher the number, higher the priority\n  regenerate: 2,\n  reuse: 1,\n  delete: 0,\n}\n\nexport function calcDirtyHtmlFiles(state: IGatsbyState): {\n  toRegenerate: Array<string>\n  toDelete: Array<string>\n  toCleanupFromTrackedState: Set<string>\n} {\n  const toRegenerate = new Set<string>()\n  const toDelete = new Set<string>()\n  const toCleanupFromTrackedState = new Set<string>()\n  const normalizedPagePathToAction = new Map<\n    string,\n    {\n      actualPath: string\n      action: PageGenerationAction\n    }\n  >()\n\n  /**\n   * multiple page paths can result in same html and page-data filenames\n   * so we need to keep that in mind when generating list of pages\n   * to regenerate and more importantly - to delete (so we don't delete html and page-data file\n   * when path changes slightly but it would still result in same html and page-data filenames\n   * for example adding/removing trailing slash between builds or even mid build with plugins\n   * like `gatsby-plugin-remove-trailing-slashes`). Additionally similar consideration need to\n   * be accounted for cases where page paths casing on case-insensitive file systems.\n   */\n  function markActionForPage(path: string, action: PageGenerationAction): void {\n    const normalizedPagePath = normalizePagePath(path)\n\n    const previousAction = normalizedPagePathToAction.get(normalizedPagePath)\n    let overwritePreviousAction = false\n    if (previousAction) {\n      const previousActionPriority =\n        pageGenerationActionPriority[previousAction.action]\n      const currentActionPriority = pageGenerationActionPriority[action]\n\n      if (currentActionPriority > previousActionPriority) {\n        overwritePreviousAction = true\n        toCleanupFromTrackedState.add(previousAction.actualPath)\n        if (previousAction.action === `delete`) {\n          // \"reuse\" or \"regenerate\" will take over, so we should\n          // remove path from list of paths to delete\n          toDelete.delete(previousAction.actualPath)\n        }\n      }\n    }\n\n    if (!previousAction || overwritePreviousAction) {\n      normalizedPagePathToAction.set(normalizedPagePath, {\n        actualPath: path,\n        action,\n      })\n      if (action === `delete`) {\n        toDelete.add(path)\n      } else if (action === `regenerate`) {\n        toRegenerate.add(path)\n      }\n    }\n  }\n\n  if (state.html.unsafeBuiltinWasUsedInSSR) {\n    reporter.warn(\n      `Previous build used unsafe builtin method. We need to rebuild all pages`\n    )\n  }\n\n  state.html.trackedHtmlFiles.forEach(function (htmlFile, path) {\n    const page = state.pages.get(path)\n    if (htmlFile.isDeleted || !page) {\n      // FIXME: checking pages state here because pages are not persisted\n      // and because of that `isDeleted` might not be set ...\n      markActionForPage(path, `delete`)\n    } else {\n      if (_CFLAGS_.GATSBY_MAJOR === `4`) {\n        if (getPageMode(page, state) === `SSG`) {\n          if (htmlFile.dirty || state.html.unsafeBuiltinWasUsedInSSR) {\n            markActionForPage(path, `regenerate`)\n          } else {\n            markActionForPage(path, `reuse`)\n          }\n        }\n      } else {\n        if (htmlFile.dirty || state.html.unsafeBuiltinWasUsedInSSR) {\n          markActionForPage(path, `regenerate`)\n        } else {\n          markActionForPage(path, `reuse`)\n        }\n      }\n    }\n  })\n\n  return {\n    toRegenerate: Array.from(toRegenerate),\n    toDelete: Array.from(toDelete),\n    toCleanupFromTrackedState,\n  }\n}\n\nexport function markHtmlDirtyIfResultOfUsedStaticQueryChanged(): void {\n  const state = store.getState()\n\n  const dirtyStaticQueryResults = new Set<string>()\n  state.html.trackedStaticQueryResults.forEach(function (\n    staticQueryResultState,\n    staticQueryHash\n  ) {\n    if (staticQueryResultState.dirty) {\n      dirtyStaticQueryResults.add(staticQueryHash)\n    }\n  })\n\n  // we have dirty static query hashes - now we need to find templates that use them\n  const dirtyTemplates = new Set<string>()\n  state.staticQueriesByTemplate.forEach(function (\n    staticQueryHashes,\n    componentPath\n  ) {\n    for (const dirtyStaticQueryHash of dirtyStaticQueryResults) {\n      if (staticQueryHashes.includes(dirtyStaticQueryHash)) {\n        dirtyTemplates.add(componentPath)\n        break // we already know this template need to rebuild, no need to check rest of queries\n      }\n    }\n  })\n\n  // mark html as dirty\n  const dirtyPages = new Set<string>()\n  for (const dirtyTemplate of dirtyTemplates) {\n    const component = state.components.get(dirtyTemplate)\n    if (component) {\n      for (const page of component.pages) {\n        dirtyPages.add(page)\n      }\n    }\n  }\n\n  store.dispatch({\n    type: `HTML_MARK_DIRTY_BECAUSE_STATIC_QUERY_RESULT_CHANGED`,\n    payload: {\n      pages: dirtyPages,\n      staticQueryHashes: dirtyStaticQueryResults,\n    },\n  })\n}\n"],"file":"build-utils.js"}
{"version":3,"sources":["../../src/utils/detect-node-mutations.ts"],"names":["reported","Set","genericProxy","createProxyHandler","nodeInternalProxy","onGet","key","value","undefined","onSet","target","nodeProxy","memoizedProxy","referenceMap","WeakMap","handler","alreadyWrapped","get","wrapped","Proxy","set","result","error","Error","captureStackTrace","stack","has","add","codeFrame","reporter","warn","replace","fieldDescriptor","Object","getOwnPropertyDescriptor","writable","shouldWrapNodesInProxies","process","env","GATSBY_DETECT_NODE_MUTATIONS","enableNodeMutationsDetection","wrapNode","node","wrapNodes","nodes","length","map"],"mappings":"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","sourcesContent":["import reporter from \"gatsby-cli/lib/reporter\"\nimport { getNonGatsbyCodeFrameFormatted } from \"./stack-trace-utils\"\nimport type { IGatsbyNode } from \"../redux/types\"\n\nconst reported = new Set<string>()\n\nconst genericProxy = createProxyHandler()\nconst nodeInternalProxy = createProxyHandler({\n  onGet(key, value) {\n    if (key === `fieldOwners` || key === `content`) {\n      // all allowed in here\n      return value\n    }\n    return undefined\n  },\n  onSet(target, key, value) {\n    if (key === `fieldOwners` || key === `content`) {\n      target[key] = value\n      return true\n    }\n    return undefined\n  },\n})\n\nconst nodeProxy = createProxyHandler({\n  onGet(key, value) {\n    if (key === `internal`) {\n      return memoizedProxy(value, nodeInternalProxy)\n    } else if (\n      key === `__gatsby_resolved` ||\n      key === `fields` ||\n      key === `children`\n    ) {\n      // all allowed in here\n      return value\n    }\n    return undefined\n  },\n  onSet(target, key, value) {\n    if (key === `__gatsby_resolved` || key === `fields` || key === `children`) {\n      target[key] = value\n      return true\n    }\n    return undefined\n  },\n})\n\n/**\n * Every time we create proxy for object, we store it in WeakMap,\n * so that we reuse it for that object instead of creating new Proxy.\n * This also ensures reference equality: `memoizedProxy(obj) === memoizedProxy(obj)`.\n * If we didn't reuse already created proxy above comparison would return false.\n */\nconst referenceMap = new WeakMap<any, any>()\nfunction memoizedProxy<T>(target: T, handler: ProxyHandler<any>): T {\n  const alreadyWrapped = referenceMap.get(target)\n  if (alreadyWrapped) {\n    return alreadyWrapped\n  } else {\n    const wrapped = new Proxy(target, handler)\n    referenceMap.set(target, wrapped)\n    return wrapped\n  }\n}\n\nfunction createProxyHandler({\n  onGet,\n  onSet,\n}: {\n  onGet?: (key: string | symbol, value: any) => any\n  onSet?: (target: any, key: string | symbol, value: any) => boolean | undefined\n} = {}): ProxyHandler<any> {\n  function set(target, key, value): boolean {\n    if (onSet) {\n      const result = onSet(target, key, value)\n      if (result !== undefined) {\n        return result\n      }\n    }\n\n    const error = new Error(`Stack trace:`)\n    Error.captureStackTrace(error, set)\n\n    if (error.stack && !reported.has(error.stack)) {\n      reported.add(error.stack)\n      const codeFrame = getNonGatsbyCodeFrameFormatted({\n        stack: error.stack,\n      })\n      reporter.warn(\n        `Node mutation detected\\n\\n${\n          codeFrame ? `${codeFrame}\\n\\n` : ``\n        }${error.stack.replace(/^Error:?\\s*/, ``)}`\n      )\n    }\n    return true\n  }\n\n  function get(target, key): any {\n    const value = target[key]\n\n    if (onGet) {\n      const result = onGet(key, value)\n      if (result !== undefined) {\n        return result\n      }\n    }\n\n    const fieldDescriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (fieldDescriptor && !fieldDescriptor.writable) {\n      // this is to prevent errors like:\n      // ```\n      // TypeError: 'get' on proxy: property 'constants' is a read - only and\n      // non - configurable data property on the proxy target but the proxy\n      // did not return its actual value\n      // (expected '[object Object]' but got '[object Object]')\n      // ```\n      return value\n    }\n\n    if (typeof value === `object` && value !== null) {\n      return memoizedProxy(value, genericProxy)\n    }\n\n    return value\n  }\n\n  return {\n    get,\n    set,\n  }\n}\n\nlet shouldWrapNodesInProxies = !!process.env.GATSBY_DETECT_NODE_MUTATIONS\nexport function enableNodeMutationsDetection(): void {\n  shouldWrapNodesInProxies = true\n\n  reporter.warn(\n    `Node mutation detection is enabled. Remember to disable it after you are finished with diagnostic as it will cause build performance degradation.`\n  )\n}\n\nexport function wrapNode<T extends IGatsbyNode | undefined>(node: T): T {\n  if (node && shouldWrapNodesInProxies) {\n    return memoizedProxy(node, nodeProxy)\n  } else {\n    return node\n  }\n}\n\nexport function wrapNodes<T extends Array<IGatsbyNode> | undefined>(\n  nodes: T\n): T {\n  if (nodes && shouldWrapNodesInProxies && nodes.length > 0) {\n    return nodes.map(node => memoizedProxy(node, nodeProxy)) as T\n  } else {\n    return nodes\n  }\n}\n"],"file":"detect-node-mutations.js"}
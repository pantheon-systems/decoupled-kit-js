{"version":3,"sources":["../../../src/steps/ingest-remote-schema/identify-and-store-ingestable-types.js"],"names":["identifyAndStoreIngestableFieldsAndTypes","nodeListFilter","field","name","state","store","getState","introspectionData","fieldBlacklist","typeMap","remoteSchema","pluginOptions","gatsbyApi","cachedFetchedTypes","key","restoredFetchedTypesMap","Map","dispatch","setState","fetchedTypes","type","Object","entries","forEach","typeName","typeSettings","lazyNodes","__all","lazyType","get","addFetchedType","interfaces","__schema","types","filter","kind","interfaceType","fields","interfaceField","rootFields","nodeInterfaceTypes","nodeListRootFields","nonNodeRootFields","nodeInterfacePossibleTypeNames","fieldHasNonNullArgs","args","some","arg","nodeField","find","ofType","nodeListField","push","nodeListFieldType","innerField","nodeInterface","nodeInterfaceType","possibleTypes","includes","takesIDinput","RootQuery","excludeFieldNames","excludedFieldName","nodeListFieldNames","map","nodeListTypeNames","connectionType","nodesField","gatsbyNodesInfo","fieldNames","typeNames","ingestibles"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { typeIsABuiltInScalar } from \"../create-schema-customization/helpers\"\nimport { findTypeName } from \"~/steps/create-schema-customization/helpers\"\nimport { getPersistentCache } from \"~/utils/cache\"\n\nconst identifyAndStoreIngestableFieldsAndTypes = async () => {\n  const nodeListFilter = field => field.name === `nodes`\n\n  const state = store.getState()\n  const { introspectionData, fieldBlacklist, typeMap } = state.remoteSchema\n  const { pluginOptions } = state.gatsbyApi\n\n  const cachedFetchedTypes = await getPersistentCache({\n    key: `previously-fetched-types`,\n  })\n\n  if (cachedFetchedTypes) {\n    const restoredFetchedTypesMap = new Map(cachedFetchedTypes)\n\n    store.dispatch.remoteSchema.setState({\n      fetchedTypes: restoredFetchedTypesMap,\n    })\n  }\n\n  if (pluginOptions.type) {\n    Object.entries(pluginOptions.type).forEach(([typeName, typeSettings]) => {\n      // our lazy types won't initially be fetched,\n      // so we need to mark them as fetched here\n      if (\n        (typeSettings.lazyNodes || pluginOptions.type?.__all?.lazyNodes) &&\n        !typeIsExcluded({ pluginOptions, typeName })\n      ) {\n        const lazyType = typeMap.get(typeName)\n        store.dispatch.remoteSchema.addFetchedType(lazyType)\n      }\n    })\n  }\n\n  const interfaces = introspectionData.__schema.types.filter(\n    type => type.kind === `INTERFACE`\n  )\n\n  for (const interfaceType of interfaces) {\n    if (typeIsExcluded({ pluginOptions, typeName: interfaceType.name })) {\n      continue\n    }\n\n    store.dispatch.remoteSchema.addFetchedType(interfaceType)\n\n    if (interfaceType.fields) {\n      for (const interfaceField of interfaceType.fields) {\n        if (interfaceField.type) {\n          store.dispatch.remoteSchema.addFetchedType(interfaceField.type)\n        }\n      }\n    }\n  }\n\n  const rootFields = typeMap.get(`RootQuery`).fields\n\n  const nodeInterfaceTypes = []\n  const nodeListRootFields = []\n  const nonNodeRootFields = []\n  const nodeInterfacePossibleTypeNames = []\n\n  for (const field of rootFields) {\n    const fieldHasNonNullArgs = field.args.some(\n      arg => arg.type.kind === `NON_NULL`\n    )\n\n    if (fieldHasNonNullArgs) {\n      // we can't know what those args should be, so skip this field\n      continue\n    }\n\n    if (typeIsExcluded({ pluginOptions, typeName: field.type.name })) {\n      continue\n    }\n\n    if (field.type.kind === `OBJECT`) {\n      const type = typeMap.get(field.type.name)\n\n      const nodeField = type?.fields?.find(nodeListFilter)\n\n      if (nodeField && nodeField.type.ofType.kind === `INTERFACE`) {\n        const nodeListField = type.fields.find(nodeListFilter)\n\n        if (nodeListField) {\n          nodeInterfaceTypes.push(nodeListField.type.ofType.name)\n\n          store.dispatch.remoteSchema.addFetchedType(nodeListField.type)\n\n          const nodeListFieldType = typeMap.get(nodeListField.type.ofType.name)\n\n          for (const innerField of nodeListFieldType.fields) {\n            store.dispatch.remoteSchema.addFetchedType(innerField.type)\n          }\n\n          if (\n            // if we haven't marked this as a nodeInterface type then push this to root fields to fetch it\n            // nodeInterface is different than a node which is an interface type.\n            // In Gatsby nodeInterface means the node data is pulled from a different type. On the WP side we can also have nodes that are of an interface type, but we only pull them from a single root field\n            // the problem is that if we don't mark them as a node list root field\n            // we don't know to identify them later as being a node type that will have been fetched and we also wont try to fetch this type during node sourcing.\n            !pluginOptions?.type?.[nodeListField.type.ofType.name]\n              ?.nodeInterface\n          ) {\n            const nodeInterfaceType = typeMap.get(\n              findTypeName(nodeListField.type)\n            )\n\n            // we need to mark all the possible types as being fetched\n            // and also need to record the possible type as a node type\n            for (const type of nodeInterfaceType?.possibleTypes || []) {\n              nodeInterfacePossibleTypeNames.push(type.name)\n              store.dispatch.remoteSchema.addFetchedType(type)\n            }\n\n            nodeListRootFields.push(field)\n          }\n\n          continue\n        }\n      } else if (nodeField) {\n        if (fieldBlacklist.includes(field.name)) {\n          continue\n        }\n\n        store.dispatch.remoteSchema.addFetchedType(nodeField.type)\n\n        nodeListRootFields.push(field)\n        continue\n      }\n    }\n\n    if (fieldBlacklist.includes(field.name)) {\n      continue\n    }\n\n    const takesIDinput = field?.args?.find(arg => arg.type.name === `ID`)\n\n    // if a non-node root field takes an id input, we 99% likely can't use it.\n    // so don't fetch it and don't add it to the schema.\n    if (takesIDinput) {\n      continue\n    }\n\n    if (\n      // if this type is excluded on the RootQuery, skip it\n      pluginOptions.type.RootQuery?.excludeFieldNames?.find(\n        excludedFieldName => excludedFieldName === field.name\n      )\n    ) {\n      continue\n    }\n\n    // we don't need to mark types as fetched if they're supported SCALAR types\n    if (!typeIsABuiltInScalar(field.type)) {\n      store.dispatch.remoteSchema.addFetchedType(field.type)\n    }\n\n    nonNodeRootFields.push(field)\n  }\n\n  const nodeListFieldNames = nodeListRootFields.map(field => field.name)\n\n  const nodeListTypeNames = [\n    ...nodeInterfacePossibleTypeNames,\n    ...nodeListRootFields.map(field => {\n      const connectionType = typeMap.get(field.type.name)\n\n      const nodesField = connectionType.fields.find(nodeListFilter)\n      return nodesField.type.ofType.name\n    }),\n  ]\n\n  const gatsbyNodesInfo = {\n    fieldNames: nodeListFieldNames,\n    typeNames: nodeListTypeNames,\n  }\n\n  store.dispatch.remoteSchema.setState({\n    gatsbyNodesInfo,\n    ingestibles: {\n      nodeListRootFields,\n      nonNodeRootFields,\n      nodeInterfaceTypes,\n    },\n  })\n}\n\nexport { identifyAndStoreIngestableFieldsAndTypes }\n"],"file":"identify-and-store-ingestable-types.js"}
{"version":3,"sources":["../../../src/schema/types/date.ts"],"names":["ISO_8601_FORMAT","GraphQLDate","GraphQLScalarType","name","description","serialize","String","parseValue","parseLiteral","ast","kind","Kind","STRING","value","undefined","momentFormattingTokens","momentFormattingRegexes","YYYY","MM","DD","DDDD","HH","mm","ss","SSS","SSSSSS","E","W","WW","Z","ISO_8601_FORMAT_AS_REGEX","map","format","matchedFormat","match","token","join","ISO_8601_FORMAT_LENGTHS","Set","reduce","acc","val","endsWith","concat","length","quickDateValidateRegex","RegExp","looksLikeDateStartRegex","looksLikeDateEndRegex","looksLikeADate","includes","test","isDate","momentDate","moment","utc","isValid","formatDateCache","getFormatDateCache","GatsbyCacheLmdb","encoding","init","formatDate","date","fromNow","difference","formatString","locale","normalizedDate","JSON","parse","stringify","cacheKey","cachedFormat","get","result","set","diff","getDateResolver","options","fieldConfig","args","type","defaultValue","resolve","source","context","info","resolver","defaultFieldResolver","from","fromNode","Array","isArray","Promise","all","d"],"mappings":"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","sourcesContent":["import moment, { MomentInput, unitOfTime, LocaleSpecifier } from \"moment\"\nimport { GraphQLScalarType, Kind, GraphQLFieldConfig } from \"graphql\"\nimport { oneLine } from \"common-tags\"\nimport GatsbyCacheLmdb from \"../../utils/cache-lmdb\"\n\ninterface IFormatDateArgs {\n  date: Date | string\n  fromNow?: boolean\n  formatString?: string\n  difference?: unitOfTime.Diff\n  locale?: LocaleSpecifier\n}\ninterface IDateResolverOption {\n  locale?: string\n  formatString?: string\n  fromNow?: boolean\n  difference?: string\n  from?: string\n  fromNode?: boolean\n}\ntype DateResolverFieldConfig = GraphQLFieldConfig<any, any, any>\ntype DateResolver = (\n  source: any,\n  args: any,\n  context: any,\n  info: any\n) => Promise<null | string | number | Array<string | number>>\n\nconst ISO_8601_FORMAT = [\n  `YYYY`,\n  `YYYY-MM`,\n  `YYYY-MM-DD`,\n  `YYYYMMDD`,\n\n  // Local Time\n  `YYYY-MM-DDTHH`,\n  `YYYY-MM-DDTHH:mm`,\n  `YYYY-MM-DDTHHmm`,\n  `YYYY-MM-DDTHH:mm:ss`,\n  `YYYY-MM-DDTHHmmss`,\n  `YYYY-MM-DDTHH:mm:ss.SSS`,\n  `YYYY-MM-DDTHHmmss.SSS`,\n  `YYYY-MM-DDTHH:mm:ss.SSSSSS`,\n  `YYYY-MM-DDTHHmmss.SSSSSS`,\n  // `YYYY-MM-DDTHH:mm:ss.SSSSSSSSS`,\n  // `YYYY-MM-DDTHHmmss.SSSSSSSSS`,\n\n  // Local Time (Omit T)\n  `YYYY-MM-DD HH`,\n  `YYYY-MM-DD HH:mm`,\n  `YYYY-MM-DD HHmm`,\n  `YYYY-MM-DD HH:mm:ss`,\n  `YYYY-MM-DD HHmmss`,\n  `YYYY-MM-DD HH:mm:ss.SSS`,\n  `YYYY-MM-DD HHmmss.SSS`,\n  `YYYY-MM-DD HH:mm:ss.SSSSSS`,\n  `YYYY-MM-DD HHmmss.SSSSSS`,\n  // `YYYY-MM-DD HH:mm:ss.SSSSSSSSS`,\n  // `YYYY-MM-DD HHmmss.SSSSSSSSS`,\n\n  // Coordinated Universal Time (UTC)\n  `YYYY-MM-DDTHHZ`,\n  `YYYY-MM-DDTHH:mmZ`,\n  `YYYY-MM-DDTHHmmZ`,\n  `YYYY-MM-DDTHH:mm:ssZ`,\n  `YYYY-MM-DDTHHmmssZ`,\n  `YYYY-MM-DDTHH:mm:ss.SSSZ`,\n  `YYYY-MM-DDTHHmmss.SSSZ`,\n  `YYYY-MM-DDTHH:mm:ss.SSSSSSZ`,\n  `YYYY-MM-DDTHHmmss.SSSSSSZ`,\n  // `YYYY-MM-DDTHH:mm:ss.SSSSSSSSSZ`,\n  // `YYYY-MM-DDTHHmmss.SSSSSSSSSZ`,\n\n  // Coordinated Universal Time (UTC) (Omit T)\n  `YYYY-MM-DD HHZ`,\n  `YYYY-MM-DD HH:mmZ`,\n  `YYYY-MM-DD HHmmZ`,\n  `YYYY-MM-DD HH:mm:ssZ`,\n  `YYYY-MM-DD HHmmssZ`,\n  `YYYY-MM-DD HH:mm:ss.SSSZ`,\n  `YYYY-MM-DD HHmmss.SSSZ`,\n  `YYYY-MM-DD HH:mm:ss.SSSSSSZ`,\n  `YYYY-MM-DD HHmmss.SSSSSSZ`,\n  // `YYYY-MM-DD HH:mm:ss.SSSSSSSSSZ`,\n  // `YYYY-MM-DD HHmmss.SSSSSSSSSZ`,\n\n  // Coordinated Universal Time (UTC) (Omit T, Extra Space before Z)\n  `YYYY-MM-DD HH Z`,\n  `YYYY-MM-DD HH:mm Z`,\n  `YYYY-MM-DD HHmm Z`,\n  `YYYY-MM-DD HH:mm:ss Z`,\n  `YYYY-MM-DD HHmmss Z`,\n  `YYYY-MM-DD HH:mm:ss.SSS Z`,\n  `YYYY-MM-DD HHmmss.SSS Z`,\n  `YYYY-MM-DD HH:mm:ss.SSSSSS Z`,\n  `YYYY-MM-DD HHmmss.SSSSSS Z`,\n\n  `YYYY-[W]WW`,\n  `YYYY[W]WW`,\n  `YYYY-[W]WW-E`,\n  `YYYY[W]WWE`,\n  `YYYY-DDDD`,\n  `YYYYDDDD`,\n]\n\nexport const GraphQLDate = new GraphQLScalarType({\n  name: `Date`,\n  description: oneLine`\n    A date string, such as 2007-12-03, compliant with the ISO 8601 standard\n    for representation of dates and times using the Gregorian calendar.`,\n  serialize: String,\n  parseValue: String,\n  parseLiteral(ast): string | undefined {\n    return ast.kind === Kind.STRING ? ast.value : undefined\n  },\n})\n\nconst momentFormattingTokens =\n  /(\\[[^[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g\nconst momentFormattingRegexes = {\n  YYYY: `\\\\d{4}`,\n  MM: `\\\\d{2}`,\n  DD: `\\\\d{2}`,\n  DDDD: `\\\\d{4}`,\n  HH: `\\\\d{2}`,\n  mm: `\\\\d{2}`,\n  ss: `\\\\d{2}`,\n  SSS: `\\\\d{3}`,\n  SSSSSS: `\\\\d{6}`,\n  E: `\\\\d`,\n  W: `\\\\d`,\n  WW: `\\\\d{2}`,\n  \"[W]\": `W`,\n  \".\": `\\\\.`,\n  Z: `(Z|[+-]\\\\d\\\\d(?::?\\\\d\\\\d)?)`,\n}\nconst ISO_8601_FORMAT_AS_REGEX = ISO_8601_FORMAT.map(format => {\n  const matchedFormat = format.match(momentFormattingTokens)\n  if (matchedFormat === null) return ``\n  // convert ISO string to a map of momentTokens ([YYYY, MM, DD])\n  return [...matchedFormat]\n    .map(token =>\n      // see if the token (YYYY or ss) is found, else we just return the value\n      momentFormattingRegexes[token] ? momentFormattingRegexes[token] : token\n    )\n    .join(``)\n}).join(`|`)\n\n// calculate all lengths of the formats, if a string is longer or smaller it can't be valid\nconst ISO_8601_FORMAT_LENGTHS = [\n  ...new Set(\n    ISO_8601_FORMAT.reduce((acc: Array<number>, val: string) => {\n      if (!val.endsWith(`Z`)) {\n        return acc.concat(val.length)\n      }\n\n      // we add count of +01 & +01:00\n      return acc.concat([val.length, val.length + 3, val.length + 5])\n    }, [])\n  ),\n]\n\n// lets imagine these formats: YYYY-MM-DDTHH & YYYY-MM-DD HHmmss.SSSSSS Z\n// this regex looks like (/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}|\\d{4}-\\d{2}-\\d{2} \\d{2}\\d{2}\\d{2}.\\d{6} Z)$)\nconst quickDateValidateRegex = new RegExp(`^(${ISO_8601_FORMAT_AS_REGEX})$`)\n\nconst looksLikeDateStartRegex = /^\\d{4}/\n// this regex makes sure the last characters are a number or the letter Z\nconst looksLikeDateEndRegex = /(\\d|Z)$/\n\n/**\n * looksLikeADate isn't a 100% valid check if it is a real date but at least it's something that looks like a date.\n * It won't catch values like 2010-02-30\n * 1) is it a number?\n * 2) does the length of the value comply with any of our formats\n * 3) does the str starts with 4 digites (YYYY)\n * 4) does the str ends with something that looks like a date\n * 5) Small regex to see if it matches any of the formats\n * 6) check momentjs\n *\n * @param {*} value\n * @return {boolean}\n */\nexport function looksLikeADate(value?: string): boolean {\n  // quick check if value does not look like a date\n  if (\n    !value ||\n    (value.length && !ISO_8601_FORMAT_LENGTHS.includes(value.length)) ||\n    !looksLikeDateStartRegex.test(value) ||\n    !looksLikeDateEndRegex.test(value)\n  ) {\n    return false\n  }\n\n  // If it looks like a date we parse the date with a regex to see if we can handle it.\n  // momentjs just does regex validation itself if you don't do any operations on it.\n  if (typeof value === `string` && quickDateValidateRegex.test(value)) {\n    return true\n  }\n\n  return isDate(value)\n}\n\n/**\n * @param {*} value\n * @return {boolean}\n */\nexport function isDate(value: MomentInput): boolean {\n  const momentDate = moment.utc(value, ISO_8601_FORMAT, true)\n  return typeof value !== `number` && momentDate.isValid()\n}\n\nlet formatDateCache: GatsbyCacheLmdb | undefined\nfunction getFormatDateCache(): GatsbyCacheLmdb {\n  if (!formatDateCache) {\n    formatDateCache = new GatsbyCacheLmdb({\n      name: `format-date-cache`,\n      encoding: `string`,\n    }).init()\n  }\n  return formatDateCache\n}\n\nconst formatDate = async ({\n  date,\n  fromNow,\n  difference,\n  formatString,\n  locale = `en`,\n}: IFormatDateArgs): Promise<string | number> => {\n  const normalizedDate = JSON.parse(JSON.stringify(date))\n  if (formatString) {\n    const cacheKey = `${normalizedDate}-${formatString}-${locale}`\n    const cachedFormat = await getFormatDateCache().get(cacheKey)\n    if (cachedFormat) {\n      return cachedFormat as string\n    }\n\n    const result = moment\n      .utc(normalizedDate, ISO_8601_FORMAT, true)\n      .locale(locale)\n      .format(formatString)\n\n    await getFormatDateCache().set(cacheKey, result)\n\n    return result\n  } else if (fromNow) {\n    return moment\n      .utc(normalizedDate, ISO_8601_FORMAT, true)\n      .locale(locale)\n      .fromNow()\n  } else if (difference) {\n    return moment().diff(\n      moment.utc(normalizedDate, ISO_8601_FORMAT, true).locale(locale),\n      difference\n    )\n  }\n  return normalizedDate\n}\n\nexport const getDateResolver = (\n  options: IDateResolverOption = {},\n  fieldConfig: DateResolverFieldConfig\n): { args: Record<string, any>; resolve: DateResolver } => {\n  const { locale, formatString, fromNow, difference } = options\n  return {\n    args: {\n      ...fieldConfig.args,\n      formatString: {\n        type: `String`,\n        description: oneLine`\n        Format the date using Moment.js' date tokens, e.g.\n        \\`date(formatString: \"YYYY MMMM DD\")\\`.\n        See https://momentjs.com/docs/#/displaying/format/\n        for documentation for different tokens.`,\n        defaultValue: formatString,\n      },\n      fromNow: {\n        type: `Boolean`,\n        description: oneLine`\n        Returns a string generated with Moment.js' \\`fromNow\\` function`,\n        defaultValue: fromNow,\n      },\n      difference: {\n        type: `String`,\n        description: oneLine`\n        Returns the difference between this date and the current time.\n        Defaults to \"milliseconds\" but you can also pass in as the\n        measurement \"years\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\",\n        and \"seconds\".`,\n        defaultValue: difference,\n      },\n      locale: {\n        type: `String`,\n        description: oneLine`\n        Configures the locale Moment.js will use to format the date.`,\n        defaultValue: locale,\n      },\n    },\n    async resolve(source, args, context, info): ReturnType<DateResolver> {\n      const resolver = fieldConfig.resolve || context.defaultFieldResolver\n      const date = await resolver(source, args, context, {\n        ...info,\n        from: options.from || info.from,\n        fromNode: options.from ? options.fromNode : info.fromNode,\n      })\n\n      if (date == null) {\n        return null\n      }\n\n      if (Array.isArray(date)) {\n        return await Promise.all(\n          date.map(d => formatDate({ date: d, ...args }))\n        )\n      }\n\n      return await formatDate({ date, ...args })\n    },\n  }\n}\n"],"file":"date.js"}
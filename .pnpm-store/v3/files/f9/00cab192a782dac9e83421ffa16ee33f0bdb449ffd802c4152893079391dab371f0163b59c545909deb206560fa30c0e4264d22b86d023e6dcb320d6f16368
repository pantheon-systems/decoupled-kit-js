{"version":3,"sources":["../../src/utils/get-page-data.ts"],"names":["DEFAULT_WAIT_TIMEOUT","RETRY_INTERVAL","getPageData","pagePath","waitForMS","doGetPageData","initialWaitForMs","queries","pendingPageDataWrites","pages","store","getState","has","Error","query","trackedQueries","get","running","waitNextPageData","dirty","emitter","emit","pagePaths","readPageData","remainingTime","Promise","resolve","on","listener","timeout","setTimeout","off","Math","max","min","data","payload","page","clearTimeout","process","nextTick","catch","toFixed","program","path","join","directory","err"],"mappings":"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","sourcesContent":["import * as path from \"path\"\nimport { store, emitter } from \"../redux\"\nimport { IClearPendingPageDataWriteAction } from \"../redux/types\"\nimport {\n  IPageDataWithQueryResult,\n  readPageData as readPageDataUtil,\n} from \"./page-data\"\n\nconst DEFAULT_WAIT_TIMEOUT = 15 * 1000\nexport const RETRY_INTERVAL = 5 * 1000\n\nexport async function getPageData(\n  pagePath: string,\n  waitForMS: number = DEFAULT_WAIT_TIMEOUT\n): Promise<IPageDataWithQueryResult> {\n  return doGetPageData(pagePath, waitForMS, waitForMS)\n}\n\nasync function doGetPageData(\n  pagePath: string,\n  waitForMS: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  const { queries, pendingPageDataWrites, pages } = store.getState()\n\n  if (!pages.has(pagePath)) {\n    throw new Error(\n      `Page \"${pagePath}\" doesn't exist. It might have been deleted recently.`\n    )\n  }\n\n  const query = queries.trackedQueries.get(pagePath)\n\n  if (!query) {\n    throw new Error(`Could not find query ${pagePath}`)\n  }\n  if (query.running !== 0) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (query.dirty !== 0) {\n    emitter.emit(`QUERY_RUN_REQUESTED`, { pagePath })\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (pendingPageDataWrites.pagePaths.has(pagePath)) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  // Results are up-to-date\n  return readPageData(pagePath)\n}\n\nasync function waitNextPageData(\n  pagePath: string,\n  remainingTime: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  if (remainingTime > 0) {\n    return new Promise(resolve => {\n      emitter.on(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n\n      const timeout = setTimeout((): void => {\n        emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n        resolve(\n          doGetPageData(\n            pagePath,\n            Math.max(remainingTime - RETRY_INTERVAL, 0),\n            initialWaitForMs\n          )\n        )\n      }, Math.min(RETRY_INTERVAL, remainingTime))\n\n      function listener(data: IClearPendingPageDataWriteAction): void {\n        if (data.payload.page === pagePath) {\n          clearTimeout(timeout)\n          emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n          // page-data was flushed, but we don't know if query wasn't marked as stale in meantime\n          // so we call `doGetPageData` again that will make checks and wait for fresh result\n          // or resolve immediately if it's not stale.\n          // Remaining time change is not actually \"correct\", but timeout overall is meant to ensure\n          // we do resolve (or reject) eventually, it doesn't have to be 100% correct - we do decrease\n          // it slightly to not end up in infinite loop situations.\n          // We also need to delay calling `doGetPageData` because it can cause adding another `CLEAR_PENDING_PAGE_DATA_WRITE`\n          // callback in same tick and `mett` will run this callback (because it will happen before current callback finishes\n          // and `mett` doesn't guarantee it will only run callbacks registered before message was emitted)\n          process.nextTick(() =>\n            resolve(\n              doGetPageData(\n                pagePath,\n                Math.max(remainingTime - RETRY_INTERVAL / 5, 0),\n                initialWaitForMs\n              )\n            )\n          )\n        }\n      }\n    })\n  } else {\n    // not ideal ... but try to push results we might have (stale)\n    // or fail/reject\n    return readPageData(pagePath).catch(() => {\n      throw new Error(\n        `Couldn't get query results for \"${pagePath}\" in ${(\n          initialWaitForMs / 1000\n        ).toFixed(3)}s.`\n      )\n    })\n  }\n}\n\nasync function readPageData(pagePath): Promise<IPageDataWithQueryResult> {\n  const { program } = store.getState()\n\n  try {\n    return await readPageDataUtil(\n      path.join(program.directory, `public`),\n      pagePath\n    )\n  } catch (err) {\n    throw new Error(\n      `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n    )\n  }\n}\n"],"file":"get-page-data.js"}
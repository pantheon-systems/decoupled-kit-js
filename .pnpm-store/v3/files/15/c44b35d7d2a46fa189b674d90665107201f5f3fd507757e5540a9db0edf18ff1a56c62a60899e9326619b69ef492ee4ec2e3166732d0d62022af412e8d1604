{"version":3,"sources":["../../../src/state-machines/waiting/index.ts"],"names":["NODE_MUTATION_BATCH_SIZE","NODE_MUTATION_BATCH_TIMEOUT","FILE_CHANGE_AGGREGATION_TIMEOUT","waitingStates","id","initial","context","nodeMutationBatch","runningBatch","states","idle","always","cond","ctx","length","target","sourceFilesDirty","Boolean","on","ADD_NODE_MUTATION","actions","SOURCE_FILE_CHANGED","aggregatingFileChanges","after","undefined","internal","batchingNodeMutations","committingBatch","entry","invoke","src","onDone","rebuild","type","data","waitingMachine","waitingActions","services","waitingServices"],"mappings":"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","sourcesContent":["import { MachineConfig, assign, Machine } from \"xstate\"\nimport { IWaitingContext } from \"./types\"\nimport { waitingActions } from \"./actions\"\nimport { waitingServices } from \"./services\"\n\nconst NODE_MUTATION_BATCH_SIZE = 100\nconst NODE_MUTATION_BATCH_TIMEOUT = 500\nconst FILE_CHANGE_AGGREGATION_TIMEOUT = 200\n\nexport type WaitingResult = Pick<IWaitingContext, \"nodeMutationBatch\">\n\n/**\n * This idle state also handles batching of node mutations and running of\n * mutations when we first start it\n */\nexport const waitingStates: MachineConfig<IWaitingContext, any, any> = {\n  id: `waitingMachine`,\n  initial: `idle`,\n  context: {\n    nodeMutationBatch: [],\n    runningBatch: [],\n  },\n  states: {\n    idle: {\n      always: [\n        {\n          // If we already have queued node mutations, move\n          // immediately to batching\n          cond: (ctx): boolean => !!ctx.nodeMutationBatch.length,\n          target: `batchingNodeMutations`,\n        },\n        {\n          // If source files are dirty upon entering this state,\n          // move immediately to aggregatingFileChanges to force re-compilation\n          // See https://github.com/gatsbyjs/gatsby/issues/27609\n          target: `aggregatingFileChanges`,\n          cond: ({ sourceFilesDirty }): boolean => Boolean(sourceFilesDirty),\n        },\n      ],\n      on: {\n        ADD_NODE_MUTATION: {\n          actions: `addNodeMutation`,\n          target: `batchingNodeMutations`,\n        },\n        // We only listen for this when idling because if we receive it at any\n        // other point we're already going to create pages etc\n        SOURCE_FILE_CHANGED: {\n          target: `aggregatingFileChanges`,\n        },\n      },\n    },\n    aggregatingFileChanges: {\n      // Sigh. This is because webpack doesn't expose the Watchpack\n      // aggregated file invalidation events. If we compile immediately,\n      // we won't pick up the changed files\n      after: {\n        // The aggregation timeout\n        [FILE_CHANGE_AGGREGATION_TIMEOUT]: {\n          actions: `extractQueries`,\n          target: `idle`,\n        },\n      },\n      on: {\n        ADD_NODE_MUTATION: {\n          actions: `addNodeMutation`,\n          target: `batchingNodeMutations`,\n        },\n        SOURCE_FILE_CHANGED: {\n          target: undefined,\n          // External self-transition reset the timer\n          internal: false,\n        },\n      },\n    },\n    batchingNodeMutations: {\n      // Check if the batch is already full on entry\n      always: {\n        cond: (ctx): boolean =>\n          ctx.nodeMutationBatch.length >= NODE_MUTATION_BATCH_SIZE,\n        target: `committingBatch`,\n      },\n      on: {\n        // More mutations added to batch\n        ADD_NODE_MUTATION: [\n          // You know the score: only run the first matching transition\n          {\n            // If this fills the batch then commit it\n            actions: `addNodeMutation`,\n            cond: (ctx): boolean =>\n              ctx.nodeMutationBatch.length >= NODE_MUTATION_BATCH_SIZE,\n            target: `committingBatch`,\n          },\n          {\n            // ...otherwise just add it to the batch\n            actions: `addNodeMutation`,\n          },\n        ],\n      },\n      after: {\n        // Time's up\n        [NODE_MUTATION_BATCH_TIMEOUT]: `committingBatch`,\n      },\n    },\n    committingBatch: {\n      entry: assign<IWaitingContext>(({ nodeMutationBatch }) => {\n        return {\n          nodeMutationBatch: [],\n          runningBatch: nodeMutationBatch,\n        }\n      }),\n      on: {\n        // While we're running the batch we will also run new actions, as these may be cascades\n        ADD_NODE_MUTATION: {\n          actions: `callApi`,\n        },\n      },\n      invoke: {\n        src: `runMutationBatch`,\n        // When we're done, clear the running batch ready for next time\n        onDone: {\n          actions: assign<IWaitingContext, any>({\n            runningBatch: [],\n          }),\n          target: `rebuild`,\n        },\n      },\n    },\n    rebuild: {\n      type: `final`,\n      // This is returned to the parent. The batch includes\n      // any mutations that arrived while we were running the other batch\n      data: ({ nodeMutationBatch }): WaitingResult => {\n        return { nodeMutationBatch }\n      },\n    },\n  },\n}\n\nexport const waitingMachine = Machine(waitingStates, {\n  actions: waitingActions,\n  services: waitingServices,\n})\n"],"file":"index.js"}
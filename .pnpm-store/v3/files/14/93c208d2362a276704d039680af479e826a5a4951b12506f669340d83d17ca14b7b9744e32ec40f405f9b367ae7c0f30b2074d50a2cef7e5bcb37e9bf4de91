{"version":3,"sources":["../../../src/datastore/in-memory/run-fast-filters.ts"],"names":["createFilterCacheKey","typeNames","filter","filterStep","comparator","paths","push","path","type","q","nestedQuery","query","join","applyFastFilters","filters","nodeTypeNames","filtersCache","sortFields","resolvedFields","nodesPerValueArrs","getBucketsForFilters","length","sort","a","b","pop","result","every","filterCacheKey","getBucketsForQueryFilter","collectBucketForElemMatch","undefined","filterPath","value","filterValue","has","nodesPerValue","targetValue","f","nodesByValue","runFastFiltersAndSort","args","queryArgs","limit","skip","stats","convertAndApplyFastFilters","sortedResult","sortNodes","totalCount","entries","slice","nodeObjects","map","nodeIds","id","GatsbyIterable","filterFields","forEach","filterStats","filterToStats","comparatorPath","comparatorsUsed","set","get","uniqueFilterPaths","add","totalNonSingleFilters","fields","filterCache","cache","meta","orderedByCounter","totalIndexHits","totalSiftHits","concat","nodes","sortFns","field","v","sortOrder","order","toLowerCase","sortField","uniqueSorts","_","orderBy"],"mappings":"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","sourcesContent":["import _ from \"lodash\"\nimport {\n  DbQuery,\n  IDbQueryQuery,\n  IDbQueryElemMatch,\n  IInputQuery,\n  FilterValueNullable,\n  createDbQueriesFromObject,\n  prefixResolvedFields,\n  prepareQueryArgs,\n} from \"../common/query\"\nimport {\n  FilterOp,\n  FilterCacheKey,\n  FiltersCache,\n  ensureEmptyFilterCache,\n  ensureIndexByQuery,\n  ensureIndexByElemMatch,\n  getNodesFromCacheByValue,\n  intersectNodesByCounter,\n  IFilterCache,\n  IGatsbyNodePartial,\n  getSortFieldIdentifierKeys,\n  getGatsbyNodePartial,\n} from \"./indexing\"\nimport { IGraphQLRunnerStats } from \"../../query/types\"\nimport { IRunQueryArgs, IQueryResult } from \"../types\"\nimport { GatsbyIterable } from \"../common/iterable\"\nimport { getNode } from \"../\"\n\nexport interface IRunFilterArg extends IRunQueryArgs {\n  filtersCache: FiltersCache\n}\n\ntype ISortParameters =\n  | {\n      fields: Array<string>\n      order: Array<boolean | \"asc\" | \"desc\" | \"ASC\" | \"DESC\">\n    }\n  | undefined\n\n/**\n * Creates a key for one filterCache inside FiltersCache\n */\nfunction createFilterCacheKey(\n  typeNames: Array<string>,\n  filter: DbQuery | null\n): FilterCacheKey {\n  // Note: while `elemMatch` is a special case, in the key it's just `elemMatch`\n  // (This function is future proof for elemMatch support, won't receive it yet)\n  let filterStep = filter\n  let comparator = ``\n  const paths: Array<string> = []\n  while (filterStep) {\n    paths.push(...filterStep.path)\n    if (filterStep.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = filterStep\n      filterStep = q.nestedQuery\n      // Make distinction between filtering `a.elemMatch.b.eq` and `a.b.eq`\n      // In practice this is unlikely to be an issue, but it might\n      paths.push(`elemMatch`)\n    } else {\n      const q: IDbQueryQuery = filterStep\n      comparator = q.query.comparator\n      break\n    }\n  }\n\n  // Note: the separators (`,` and `/`) are arbitrary but must be different\n  return typeNames.join(`,`) + `/` + paths.join(`,`) + `/` + comparator\n}\n\n/**\n * Given the path of a set of filters, return the sets of nodes that pass the\n * filter.\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n *\n * Note: Not a public API. Exported for tests.\n */\nexport function applyFastFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  sortFields: Array<string>,\n  resolvedFields: any\n): Array<IGatsbyNodePartial> | null {\n  if (!filtersCache) {\n    // If no filter cache is passed on, explicitly don't use one\n    return null\n  }\n\n  const nodesPerValueArrs = getBucketsForFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache,\n    sortFields,\n    resolvedFields\n  )\n\n  if (!nodesPerValueArrs) {\n    return null\n  }\n\n  if (nodesPerValueArrs.length === 0) {\n    return []\n  } else {\n    // Put smallest last (we'll pop it)\n    nodesPerValueArrs.sort((a, b) => b.length - a.length)\n\n    // All elements of nodesPerValueArrs should be sorted by counter and deduped\n    // So if there's only one bucket in this list the next loop is skipped\n\n    while (nodesPerValueArrs.length > 1) {\n      // TS limitation: cannot guard against .pop(), so we must double cast\n      const a = nodesPerValueArrs.pop() as unknown as Array<IGatsbyNodePartial>\n      const b = nodesPerValueArrs.pop() as unknown as Array<IGatsbyNodePartial>\n      nodesPerValueArrs.push(intersectNodesByCounter(a, b))\n    }\n\n    const result = nodesPerValueArrs[0]\n\n    if (result.length === 0) {\n      // Intersection came up empty. Not one node appeared in every bucket.\n      return null\n    }\n\n    return result\n  }\n}\n\n/**\n * If this returns undefined it means at least one cache was not found\n */\nfunction getBucketsForFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  sortFields: Array<string>,\n  resolvedFields: any\n): Array<Array<IGatsbyNodePartial>> | undefined {\n  const nodesPerValueArrs: Array<Array<IGatsbyNodePartial>> = []\n\n  // Fail fast while trying to create and get the value-cache for each path\n  const every = filters.every(filter => {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, filter)\n    if (filter.type === `query`) {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryQuery = filter\n      return getBucketsForQueryFilter(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs,\n        sortFields,\n        resolvedFields\n      )\n    } else {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryElemMatch = filter\n      return collectBucketForElemMatch(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs,\n        sortFields,\n        resolvedFields\n      )\n    }\n  })\n\n  if (every) {\n    return nodesPerValueArrs\n  }\n\n  // \"failed at least one\"\n  return undefined\n}\n\n/**\n * Fetch all buckets for given query filter. That means it's not elemMatch.\n * Returns `false` if it found none.\n */\nfunction getBucketsForQueryFilter(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryQuery,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNodePartial>>,\n  sortFields: Array<string>,\n  resolvedFields: any\n): boolean {\n  const {\n    path: filterPath,\n    query: { comparator, value: filterValue },\n  } = filter\n\n  if (!filtersCache.has(filterCacheKey)) {\n    // indexFields = sortFields\n    ensureIndexByQuery(\n      comparator as FilterOp,\n      filterCacheKey,\n      filterPath,\n      nodeTypeNames,\n      filtersCache,\n      sortFields,\n      resolvedFields\n    )\n  }\n\n  const nodesPerValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    filterValue as FilterValueNullable,\n    filtersCache,\n    false\n  )\n\n  if (!nodesPerValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesPerValue)\n\n  return true\n}\n\n/**\n * Matching node arrs are put in given array by reference\n */\nfunction collectBucketForElemMatch(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNodePartial>>,\n  sortFields: Array<string>,\n  resolvedFields: any\n): boolean {\n  // Get comparator and target value for this elemMatch\n  let comparator: FilterOp = `$eq` // (Must be overridden but TS requires init)\n  let targetValue: FilterValueNullable = null\n  let f: DbQuery = filter\n  while (f) {\n    if (f.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = f\n      f = q.nestedQuery\n    } else {\n      const q: IDbQueryQuery = f\n      comparator = q.query.comparator as FilterOp\n      targetValue = q.query.value as FilterValueNullable\n      break\n    }\n  }\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByElemMatch(\n      comparator,\n      filterCacheKey,\n      filter,\n      nodeTypeNames,\n      filtersCache,\n      sortFields,\n      resolvedFields\n    )\n  }\n\n  const nodesByValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    targetValue,\n    filtersCache,\n    true\n  )\n\n  if (!nodesByValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesByValue)\n\n  return true\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {{filter?: Object, sort?: Object, skip?: number, limit?: number} | undefined} args.queryArgs\n * @property {FiltersCache} args.filtersCache A cache of indexes where you can\n *   look up Nodes grouped by a FilterCacheKey, which yields a Map which holds\n *   an arr of Nodes for the value that the filter is trying to query against.\n *   This object lives in query/query-runner.js and is passed down runQuery.\n * @returns Collection of results. Collection will be sliced by `skip` and `limit`\n */\nexport function runFastFiltersAndSort(args: IRunFilterArg): IQueryResult {\n  const {\n    queryArgs: { filter, sort, limit, skip = 0 } = {},\n    resolvedFields = {},\n    nodeTypeNames,\n    filtersCache,\n    stats,\n  } = args\n\n  const result = convertAndApplyFastFilters(\n    filter,\n    nodeTypeNames,\n    filtersCache,\n    resolvedFields,\n    stats,\n    sort\n  )\n\n  const sortedResult = sortNodes(result, sort, resolvedFields, stats)\n  const totalCount = async (): Promise<number> => sortedResult.length\n\n  const entries =\n    skip || limit\n      ? sortedResult.slice(skip, limit ? skip + (limit ?? 0) : undefined)\n      : sortedResult\n\n  const nodeObjects = entries.map(nodeIds => getNode(nodeIds.id)!)\n  return { entries: new GatsbyIterable(nodeObjects), totalCount }\n}\n\n/**\n * Return a collection of results.\n */\nfunction convertAndApplyFastFilters(\n  filterFields: IInputQuery | undefined,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  resolvedFields: Record<string, any>,\n  stats: IGraphQLRunnerStats,\n  sort: ISortParameters\n): Array<IGatsbyNodePartial> {\n  const filters = filterFields\n    ? prefixResolvedFields(\n        createDbQueriesFromObject(prepareQueryArgs(filterFields)),\n        resolvedFields\n      )\n    : []\n\n  if (stats) {\n    filters.forEach(filter => {\n      const filterStats = filterToStats(filter)\n      const comparatorPath = filterStats.comparatorPath.join(`.`)\n      stats.comparatorsUsed.set(\n        comparatorPath,\n        (stats.comparatorsUsed.get(comparatorPath) || 0) + 1\n      )\n      stats.uniqueFilterPaths.add(filterStats.filterPath.join(`.`))\n    })\n    if (filters.length > 1) {\n      stats.totalNonSingleFilters++\n    }\n  }\n\n  if (filters.length === 0) {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, null)\n    if (!filtersCache.has(filterCacheKey)) {\n      ensureEmptyFilterCache(\n        filterCacheKey,\n        nodeTypeNames,\n        filtersCache,\n        sort?.fields || [],\n        resolvedFields\n      )\n    }\n\n    // If there's a filter, there (now) must be an entry for this cache key\n    const filterCache = filtersCache.get(filterCacheKey) as IFilterCache\n    // If there is no filter then the ensureCache step will populate this:\n    const cache = filterCache.meta.orderedByCounter as Array<IGatsbyNodePartial>\n\n    return cache.slice(0)\n  }\n\n  const result = applyFastFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache,\n    sort?.fields || [],\n    resolvedFields\n  )\n\n  if (result) {\n    if (stats) {\n      stats.totalIndexHits++\n    }\n    return result\n  }\n\n  if (stats) {\n    // to mean, \"empty results\"\n    stats.totalSiftHits++\n  }\n\n  return []\n}\n\nfunction filterToStats(\n  filter: DbQuery,\n  filterPath: Array<string> = [],\n  comparatorPath: Array<string> = []\n): {\n  filterPath: Array<string>\n  comparatorPath: Array<string>\n} {\n  if (filter.type === `elemMatch`) {\n    return filterToStats(\n      filter.nestedQuery,\n      filterPath.concat(filter.path),\n      comparatorPath.concat([`elemMatch`])\n    )\n  } else {\n    return {\n      filterPath: filterPath.concat(filter.path),\n      comparatorPath: comparatorPath.concat(filter.query.comparator),\n    }\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n * Returns same reference as input, sorted inline\n */\nfunction sortNodes(\n  nodes: Array<IGatsbyNodePartial>,\n  sort: ISortParameters,\n  resolvedFields: any,\n  stats: IGraphQLRunnerStats\n): Array<IGatsbyNodePartial> {\n  if (!sort || sort.fields?.length === 0 || !nodes || nodes.length === 0) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const sortFields = getSortFieldIdentifierKeys(sort.fields, resolvedFields)\n  const sortFns = sortFields.map(\n    field =>\n      (v): ((any) => any) =>\n        field in v\n          ? v[field]\n          : getGatsbyNodePartial(v, sort.fields, resolvedFields)[field]\n  )\n  const sortOrder = sort.order.map(order =>\n    typeof order === `boolean` ? order : order.toLowerCase()\n  ) as Array<boolean | \"asc\" | \"desc\">\n\n  if (stats) {\n    sortFields.forEach(sortField => {\n      stats.uniqueSorts.add(sortField)\n    })\n  }\n\n  return _.orderBy(nodes, sortFns, sortOrder)\n}\n"],"file":"run-fast-filters.js"}
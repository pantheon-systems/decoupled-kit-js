{"version":3,"sources":["../../src/utils/page-mode.ts"],"names":["pageConfigMap","Map","getPageMode","page","state","components","store","getState","component","get","componentPath","serverData","config","resolvePageMode","pageMode","undefined","pageConfigFn","componentChunkName","fsRouteParams","context","pageConfig","params","defer","path","materializePageMode","pages","dispatchCount","values","Error","action","type","payload","dispatch","Promise","resolve","setImmediate","ready","preparePageTemplateConfigs","graphql","program","pageRendererPath","directory","ROUTES_DIRECTORY","pageRenderer","require","global","all","Array","from","map","componentInstance","getPageChunk","set"],"mappings":"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","sourcesContent":["import { store } from \"../redux\"\nimport {\n  IGatsbyPage,\n  IGatsbyState,\n  IMaterializePageMode,\n  PageMode,\n} from \"../redux/types\"\nimport { reportOnce } from \"./report-once\"\nimport { ROUTES_DIRECTORY } from \"../constants\"\nimport { Runner } from \"../bootstrap/create-graphql-runner\"\nimport { getDataStore } from \"../datastore\"\n\ntype IPageConfigFn = (arg: { params: Record<string, unknown> }) => {\n  defer: boolean\n}\n\nconst pageConfigMap = new Map<string, IPageConfigFn>()\n\n/**\n * In develop IGatsbyPage[\"mode\"] can change at any time, so as a general rule we need to resolve it\n * every time from page component and IGatsbyPage[\"defer\"] value.\n *\n * IGatsbyPage[\"mode\"] is only reliable in engines and in `onPostBuild` hook.\n */\nexport function getPageMode(page: IGatsbyPage, state?: IGatsbyState): PageMode {\n  const { components } = state ?? store.getState()\n\n  // assume SSG until components are actually extracted\n  const component = components.get(page.componentPath) ?? {\n    serverData: false,\n    config: false,\n  }\n\n  return resolvePageMode(page, component)\n}\n\nfunction resolvePageMode(\n  page: IGatsbyPage,\n  component: { serverData: boolean; config: boolean }\n): PageMode {\n  let pageMode: PageMode | undefined = undefined\n  if (component.serverData) {\n    pageMode = `SSR`\n  } else if (component.config) {\n    const pageConfigFn = pageConfigMap.get(page.componentChunkName)\n    if (!pageConfigFn) {\n      // This is possible in warm builds when `component.config` was persisted but\n      // `preparePageTemplateConfigs` hasn't been executed yet\n      // TODO: if we move `mode` away from page and persist it in the state separately,\n      //  we can just return the old `mode` that should be in sync with `component.config`\n      return `SSG`\n    }\n\n    const fsRouteParams = (\n      typeof page.context[`__params`] === `object`\n        ? page.context[`__params`]\n        : {}\n    ) as Record<string, unknown>\n\n    const pageConfig = pageConfigFn({ params: fsRouteParams })\n    if (typeof pageConfig.defer === `boolean`) {\n      pageMode = pageConfig.defer ? `DSG` : `SSG`\n    }\n  }\n\n  if (!pageMode) {\n    pageMode = page.defer ? `DSG` : `SSG`\n  }\n  if (\n    pageMode !== `SSG` &&\n    (page.path === `/404.html` || page.path === `/500.html`)\n  ) {\n    reportOnce(\n      `Status page \"${page.path}\" ignores page mode (\"${pageMode}\") and force sets it to SSG (this page can't be lazily rendered).`\n    )\n    pageMode = `SSG`\n  }\n\n  return pageMode\n}\n\n/**\n * Persist page.mode for SSR/DSG pages to ensure they work with `gatsby serve`\n *\n * TODO: ideally IGatsbyPage[\"mode\"] should not exist at all and instead we need a different entity\n *   holding this information: an entity that is only created in the end of the build e.g. Route\n *   then materializePageMode transforms to createRoutes\n */\nexport async function materializePageMode(): Promise<void> {\n  const { pages, components } = store.getState()\n\n  let dispatchCount = 0\n  for (const page of pages.values()) {\n    const component = components.get(page.componentPath)\n    if (!component) {\n      throw new Error(`Could not find matching component for page ${page.path}`)\n    }\n    const pageMode = resolvePageMode(page, component)\n\n    // Do not materialize for SSG pages: saves some CPU time as `page.mode` === `SSG` by default when creating a page\n    // and our pages are re-generated on each build, not persisted\n    // (so no way to get DSG/SSR value from the previous build)\n    if (pageMode !== `SSG`) {\n      const action: IMaterializePageMode = {\n        type: `MATERIALIZE_PAGE_MODE`,\n        payload: { path: page.path, pageMode },\n      }\n      store.dispatch(action)\n    }\n    // Do not block task queue of the event loop for too long:\n    if (dispatchCount++ % 100 === 0) {\n      await new Promise(resolve => setImmediate(resolve))\n    }\n  }\n  await getDataStore().ready()\n}\n\nexport async function preparePageTemplateConfigs(\n  graphql: Runner\n): Promise<void> {\n  const { program } = store.getState()\n  const pageRendererPath = `${program.directory}/${ROUTES_DIRECTORY}render-page.js`\n\n  const pageRenderer = require(pageRendererPath)\n  global[`__gatsbyGraphql`] = graphql\n\n  await Promise.all(\n    Array.from(store.getState().components.values()).map(async component => {\n      if (component.config) {\n        const componentInstance = await pageRenderer.getPageChunk({\n          componentChunkName: component.componentChunkName,\n        })\n        const pageConfigFn = await componentInstance.config()\n        if (typeof pageConfigFn !== `function`) {\n          throw new Error(\n            `Unexpected result of config factory. Expected \"function\", got \"${typeof pageConfigFn}\".`\n          )\n        }\n\n        pageConfigMap.set(component.componentChunkName, pageConfigFn)\n      }\n    })\n  )\n  delete global[`__gatsbyGraphql`]\n}\n"],"file":"page-mode.js"}
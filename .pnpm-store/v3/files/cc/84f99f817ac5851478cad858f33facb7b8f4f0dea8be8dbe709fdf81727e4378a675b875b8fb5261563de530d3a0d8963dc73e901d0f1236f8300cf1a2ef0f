{"version":3,"sources":["../../src/services/recompile.ts"],"names":["recompile","context","stats","Promise","all","recompileDevBundle","recompileSSRBundle","webpackWatching","reporter","panic","resolve","finish","emitter","off","on","resume","suspend","program","websocketManager","recompiledFiles","Set","includesSSRComponent","verbose","close","rendererPath","Stage","DevelopHTML","emitStaleServerData","result","Array","from","map","path","isSSRPageComponent","some","isSSR","filename","fs","pathExists","lstat","isFile","text","readFile","includes"],"mappings":";;;;;;;AAEA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;AARA;AAUO,eAAeA,SAAf,CAAyBC,OAAzB,EAAiE;AACtE,QAAM,CAACC,KAAD,IAAU,MAAMC,OAAO,CAACC,GAAR,CAAY,CAChCC,kBAAkB,CAACJ,OAAD,CADc,EAEhCK,kBAAkB,CAACL,OAAD,CAFc,CAAZ,CAAtB;AAIA,SAAOC,KAAP;AACD;;AAED,eAAeG,kBAAf,CAAkC;AAChCE,EAAAA;AADgC,CAAlC,EAEkC;AAChC,MAAI,CAACA,eAAL,EAAsB;AACpBC,sBAASC,KAAT,CAAgB,kBAAhB;AACD;;AACD,SAAO,IAAIN,OAAJ,CAAmBO,OAAO,IAAI;AACnC,aAASC,MAAT,CAAgBT,KAAhB,EAAoC;AAClCU,qBAAQC,GAAR,CAAa,kBAAb,EAAgCF,MAAhC;;AACAD,MAAAA,OAAO,CAACR,KAAD,CAAP;AACD;;AACDU,mBAAQE,EAAR,CAAY,kBAAZ,EAA+BH,MAA/B;;AACAJ,IAAAA,eAAe,CAACQ,MAAhB,GANmC,CAOnC;;AACAR,IAAAA,eAAe,CAACS,OAAhB;AACD,GATM,CAAP;AAUD;;AAED,eAAeV,kBAAf,CAAkC;AAChCW,EAAAA,OADgC;AAEhCC,EAAAA,gBAFgC;AAGhCC,EAAAA,eAAe,GAAG,IAAIC,GAAJ;AAHc,CAAlC,EAIiC;AAC/B,MAAI,EAAE,MAAMC,oBAAoB,CAACF,eAAD,CAA5B,CAAJ,EAAoD;AAClD;AACD;;AACDX,oBAASc,OAAT,CAAkB,wBAAlB;;AAEA,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA;AAAT,MAA0B,MAAM,8BACpCP,OADoC,EAEpCQ,aAAMC,WAF8B,CAAtC;AAKA,uDAA6BF,YAA7B;;AAEA,MAAIN,gBAAJ,EAAsB;AACpBA,IAAAA,gBAAgB,CAACS,mBAAjB;AACD;;AAED,QAAMJ,KAAK,EAAX;AACD;;AAED,eAAeF,oBAAf,CACEF,eADF,EAEoB;AAClB,QAAMS,MAAM,GAAG,MAAMzB,OAAO,CAACC,GAAR,CACnByB,KAAK,CAACC,IAAN,CAAWX,eAAX,EAA4BY,GAA5B,CAAgCC,IAAI,IAAIC,kBAAkB,CAACD,IAAD,CAA1D,CADmB,CAArB;AAGA,SAAOJ,MAAM,CAACM,IAAP,CAAYC,KAAK,IAAIA,KAAK,KAAK,IAA/B,CAAP;AACD;;AAED,eAAeF,kBAAf,CAAkCG,QAAlC,EAAsE;AACpE,MACE,EAAE,MAAMC,EAAE,CAACC,UAAH,CAAcF,QAAd,CAAR,KACA,CAAC,CAAC,MAAMC,EAAE,CAACE,KAAH,CAASH,QAAT,CAAP,EAA2BI,MAA3B,EAFH,EAGE;AACA,WAAO,KAAP;AACD;;AACD,QAAMC,IAAI,GAAG,MAAMJ,EAAE,CAACK,QAAH,CAAYN,QAAZ,EAAuB,MAAvB,CAAnB;AACA,SAAOK,IAAI,CAACE,QAAL,CAAe,eAAf,CAAP;AACD","sourcesContent":["/* eslint-disable no-unused-expressions */\nimport { IBuildContext } from \"./types\"\nimport * as fs from \"fs-extra\"\nimport { Stats } from \"webpack\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { emitter } from \"../redux\"\nimport { buildRenderer } from \"../commands/build-html\"\nimport { Stage } from \"../commands/types\"\nimport { clearRequireCacheRecursively } from \"../utils/clear-require-cache\"\n\nexport async function recompile(context: IBuildContext): Promise<Stats> {\n  const [stats] = await Promise.all([\n    recompileDevBundle(context),\n    recompileSSRBundle(context),\n  ])\n  return stats\n}\n\nasync function recompileDevBundle({\n  webpackWatching,\n}: IBuildContext): Promise<Stats> {\n  if (!webpackWatching) {\n    reporter.panic(`Missing compiler`)\n  }\n  return new Promise<Stats>(resolve => {\n    function finish(stats: Stats): void {\n      emitter.off(`COMPILATION_DONE`, finish)\n      resolve(stats)\n    }\n    emitter.on(`COMPILATION_DONE`, finish)\n    webpackWatching.resume()\n    // Suspending is just a flag, so it's safe to re-suspend right away\n    webpackWatching.suspend()\n  })\n}\n\nasync function recompileSSRBundle({\n  program,\n  websocketManager,\n  recompiledFiles = new Set(),\n}: IBuildContext): Promise<void> {\n  if (!(await includesSSRComponent(recompiledFiles))) {\n    return\n  }\n  reporter.verbose(`Recompiling SSR bundle`)\n\n  const { close, rendererPath } = await buildRenderer(\n    program,\n    Stage.DevelopHTML\n  )\n\n  clearRequireCacheRecursively(rendererPath)\n\n  if (websocketManager) {\n    websocketManager.emitStaleServerData()\n  }\n\n  await close()\n}\n\nasync function includesSSRComponent(\n  recompiledFiles: Set<string>\n): Promise<boolean> {\n  const result = await Promise.all(\n    Array.from(recompiledFiles).map(path => isSSRPageComponent(path))\n  )\n  return result.some(isSSR => isSSR === true)\n}\n\nasync function isSSRPageComponent(filename: string): Promise<boolean> {\n  if (\n    !(await fs.pathExists(filename)) ||\n    !(await fs.lstat(filename)).isFile()\n  ) {\n    return false\n  }\n  const text = await fs.readFile(filename, `utf8`)\n  return text.includes(`getServerData`)\n}\n"],"file":"recompile.js"}
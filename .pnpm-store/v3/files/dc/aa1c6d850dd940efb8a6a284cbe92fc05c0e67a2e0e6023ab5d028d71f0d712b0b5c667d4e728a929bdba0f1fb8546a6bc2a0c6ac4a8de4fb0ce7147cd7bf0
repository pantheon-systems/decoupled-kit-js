{"version":3,"sources":["../../src/query/query-watcher.ts"],"names":["debug","require","getQueriesSnapshot","state","store","getState","snapshot","components","Map","staticQueryComponents","handleComponentsWithRemovedQueries","queries","forEach","c","query","has","componentPath","dispatch","type","payload","id","handleQuery","component","isStaticQuery","oldQuery","get","isNewQuery","hash","text","actions","replaceStaticQuery","name","path","filesToWatch","Set","watcher","watch","rootDir","modulesThatUseGatsby","packagePaths","map","module","filesRegex","pathRegex","join","chokidar","ignoreInitial","on","emitter","emit","filePath","add","watchComponent","process","env","NODE_ENV","clearInactiveComponents","pages","activeTemplates","page","startWatchDeletePage","action","otherPageWithTemplateExists","values","updateStateAndRunQueries","isFirstRun","parentSpan","size","queryExtracted","queriesWillNotRun","queryWillRun","report","warn","log","stripIndent","extractQueries","then","program","directory"],"mappings":"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","sourcesContent":["/***\n * Jobs of this module\n * - Maintain the list of components in the Redux store. So monitor new components\n *   and add/remove components.\n * - Watch components for query changes and extract these and update the store.\n * - Ensure all page queries are run as part of bootstrap and report back when\n *   this is done\n * - Whenever a query changes, re-run all pages that rely on this query.\n ***/\n\nimport chokidar, { FSWatcher } from \"chokidar\"\nimport { Span } from \"opentracing\"\n\nimport path from \"path\"\nimport { slash } from \"gatsby-core-utils\"\n\nimport { store, emitter } from \"../redux/\"\nimport { actions } from \"../redux/actions\"\nimport { IGatsbyStaticQueryComponents } from \"../redux/types\"\nimport queryCompiler from \"./query-compiler\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { getGatsbyDependents } from \"../utils/gatsby-dependents\"\nimport { processNodeManifests } from \"../utils/node-manifest\"\n\nconst debug = require(`debug`)(`gatsby:query-watcher`)\n\ninterface IComponent {\n  componentPath: string\n  query: string\n  pages: Set<string>\n  isInBootstrap: boolean\n}\n\ninterface IQuery {\n  id: string\n  name: string\n  text: string\n  originalText: string\n  path: string\n  isHook: boolean\n  isStaticQuery: boolean\n  hash: string\n}\n\ninterface IQuerySnapshot {\n  components: Map<string, IComponent>\n  staticQueryComponents: Map<string, IGatsbyStaticQueryComponents>\n}\n\nconst getQueriesSnapshot = (): IQuerySnapshot => {\n  const state = store.getState()\n\n  const snapshot: IQuerySnapshot = {\n    components: new Map<string, IComponent>(state.components),\n    staticQueryComponents: new Map<string, IGatsbyStaticQueryComponents>(\n      state.staticQueryComponents\n    ),\n  }\n\n  return snapshot\n}\n\nconst handleComponentsWithRemovedQueries = (\n  { staticQueryComponents }: IQuerySnapshot,\n  queries: Map<string, IQuery>\n): void => {\n  // If a component had static query and it doesn't have it\n  // anymore - update the store\n  staticQueryComponents.forEach(c => {\n    if (c.query !== `` && !queries.has(c.componentPath)) {\n      debug(`Static query was removed from ${c.componentPath}`)\n      store.dispatch({\n        type: `REMOVE_STATIC_QUERY`,\n        payload: c.id,\n      })\n    }\n  })\n}\n\nconst handleQuery = (\n  { staticQueryComponents }: IQuerySnapshot,\n  query: IQuery,\n  component: string\n): boolean => {\n  // If this is a static query\n  // Add action / reducer + watch staticquery files\n  if (query.isStaticQuery) {\n    const oldQuery = staticQueryComponents.get(query.id)\n    const isNewQuery = !oldQuery\n\n    // Compare query text because text is compiled query with any attached\n    // fragments and we want to rerun queries if fragments are edited.\n    // Compare hash because hash is used for identyfing query and\n    // passing data to component in development. Hash can change if user will\n    // format query text, but it doesn't mean that compiled text will change.\n    if (\n      isNewQuery ||\n      oldQuery?.hash !== query.hash ||\n      oldQuery?.query !== query.text\n    ) {\n      store.dispatch(\n        actions.replaceStaticQuery({\n          name: query.name,\n          componentPath: query.path,\n          id: query.id,\n          query: query.text,\n          hash: query.hash,\n        })\n      )\n\n      debug(\n        `Static query in ${component} ${\n          isNewQuery ? `was added` : `has changed`\n        }.`\n      )\n    }\n    return true\n  }\n\n  return false\n}\n\nconst filesToWatch = new Set<string>()\nlet watcher: FSWatcher\n\nconst watch = async (rootDir: string): Promise<void> => {\n  if (watcher) return\n\n  const modulesThatUseGatsby = await getGatsbyDependents()\n\n  const packagePaths = modulesThatUseGatsby.map(module => {\n    const filesRegex = `*.+(t|j)s?(x)`\n    const pathRegex = `/{${filesRegex},!(node_modules)/**/${filesRegex}}`\n    return slash(path.join(module.path, pathRegex))\n  })\n\n  watcher = chokidar\n    .watch(\n      [slash(path.join(rootDir, `/src/**/*.{js,jsx,ts,tsx}`)), ...packagePaths],\n      { ignoreInitial: true }\n    )\n    .on(`change`, path => {\n      emitter.emit(`SOURCE_FILE_CHANGED`, path)\n    })\n    .on(`add`, path => {\n      emitter.emit(`SOURCE_FILE_CHANGED`, path)\n    })\n    .on(`unlink`, path => {\n      emitter.emit(`SOURCE_FILE_CHANGED`, path)\n    })\n\n  filesToWatch.forEach(filePath => watcher.add(filePath))\n}\n\nconst watchComponent = (componentPath: string): void => {\n  // We don't start watching until mid-way through the bootstrap so ignore\n  // new components being added until then. This doesn't affect anything as\n  // when extractQueries is called from bootstrap, we make sure that all\n  // components are being watched.\n  if (\n    process.env.NODE_ENV !== `production` &&\n    !filesToWatch.has(componentPath)\n  ) {\n    filesToWatch.add(componentPath)\n    if (watcher) {\n      watcher.add(componentPath)\n    }\n  }\n}\n\n/**\n * Removes components templates that aren't used by any page from redux store.\n */\nconst clearInactiveComponents = (): void => {\n  const { components, pages } = store.getState()\n\n  const activeTemplates = new Set()\n  pages.forEach(page => {\n    // Set will guarantee uniqueness of entries\n    activeTemplates.add(slash(page.component))\n  })\n\n  components.forEach(component => {\n    if (!activeTemplates.has(component.componentPath)) {\n      debug(\n        `${component.componentPath} component was removed because it isn't used by any page`\n      )\n      store.dispatch({\n        type: `REMOVE_STATIC_QUERIES_BY_TEMPLATE`,\n        payload: component,\n      })\n    }\n  })\n}\n\nexport const startWatchDeletePage = (): void => {\n  emitter.on(`DELETE_PAGE`, action => {\n    const componentPath = slash(action.payload.component)\n    const { pages } = store.getState()\n    let otherPageWithTemplateExists = false\n    for (const page of pages.values()) {\n      if (slash(page.component) === componentPath) {\n        otherPageWithTemplateExists = true\n        break\n      }\n    }\n    if (!otherPageWithTemplateExists) {\n      store.dispatch({\n        type: `REMOVE_STATIC_QUERIES_BY_TEMPLATE`,\n        payload: {\n          componentPath,\n        },\n      })\n    }\n  })\n}\n\nexport const updateStateAndRunQueries = async (\n  isFirstRun: boolean,\n  { parentSpan }: { parentSpan?: Span } = {}\n): Promise<void> => {\n  const snapshot = getQueriesSnapshot()\n  const queries: Map<string, IQuery> = await queryCompiler({ parentSpan })\n  // If there's an error while extracting queries, the queryCompiler returns false\n  // or zero results.\n  // Yeah, should probably be an error but don't feel like threading the error\n  // all the way here.\n  if (!queries || queries.size === 0) {\n    return\n  }\n  handleComponentsWithRemovedQueries(snapshot, queries)\n\n  // Run action for each component\n  const { components } = snapshot\n  components.forEach(c => {\n    const { isStaticQuery = false, text = `` } =\n      queries.get(c.componentPath) || {}\n\n    store.dispatch(\n      actions.queryExtracted({\n        componentPath: c.componentPath,\n        query: isStaticQuery ? `` : text,\n      })\n    )\n  })\n\n  let queriesWillNotRun = false\n  queries.forEach((query, component) => {\n    const queryWillRun = handleQuery(snapshot, query, component)\n\n    if (queryWillRun) {\n      watchComponent(component)\n      // Check if this is a page component.\n      // If it is and this is our first run during bootstrap,\n      // show a warning about having a query in a non-page component.\n    } else if (isFirstRun && !snapshot.components.has(component)) {\n      report.warn(\n        `The GraphQL query in the non-page component \"${component}\" will not be run.`\n      )\n      queriesWillNotRun = true\n    }\n  })\n\n  if (queriesWillNotRun) {\n    report.log(report.stripIndent`\n\n        Exported queries are only executed for Page components. It's possible you're\n        trying to create pages in your gatsby-node.js and that's failing for some\n        reason.\n\n        If the failing component(s) is a regular component and not intended to be a page\n        component, you generally want to use a <StaticQuery> (https://gatsbyjs.org/docs/static-query)\n        instead of exporting a page query.\n\n        If you're more experienced with GraphQL, you can also export GraphQL\n        fragments from components and compose the fragments in the Page component\n        query and pass data down into the child component — https://graphql.org/learn/queries/#fragments\n\n      `)\n  }\n\n  if (process.env.NODE_ENV === `development`) {\n    /**\n     * only process node manifests here in develop. we want this to run every time queries are updated. for gatsby build we process node manifests in src/services/run-page-queries.ts after all queries are run and pages are created. If we process node manifests in this location for gatsby build we wont have all the information needed to create the manifests. If we don't process manifests in this location during gatsby develop manifests will only be written once and never again when more manifests are created.\n     */\n    await processNodeManifests()\n  }\n}\n\nexport const extractQueries = ({\n  parentSpan,\n}: { parentSpan?: Span } = {}): Promise<void> => {\n  // Remove template components that point to not existing page templates.\n  // We need to do this, because components data is cached and there might\n  // be changes applied when development server isn't running. This is needed\n  // only in initial run, because during development state will be adjusted.\n  clearInactiveComponents()\n\n  return updateStateAndRunQueries(true, { parentSpan }).then(() => {\n    // During development start watching files to recompile & run\n    // queries on the fly.\n\n    // TODO: move this into a spawned service\n    if (process.env.NODE_ENV !== `production`) {\n      watch(store.getState().program.directory)\n    }\n  })\n}\n"],"file":"query-watcher.js"}
{"version":3,"sources":["../../../src/internal-plugins/webpack-theme-component-shadowing/index.js"],"names":["path","require","debug","fs","_","DEFAULT_FILE_EXTENSIONS_CATEGORIES","js","jsx","ts","tsx","cjs","mjs","coffee","json","yaml","yml","css","sass","scss","less","jpeg","jpg","jfif","png","tiff","webp","avif","gif","woff","woff2","module","exports","GatsbyThemeComponentShadowingResolverPlugin","constructor","projectRoot","themes","extensions","extensionsCategory","map","themeName","additionalShadowExtensions","buildAdditionalShadowExtensions","extensionsByCategory","groupBy","ext","substring","additionalExtensions","category","exts","Object","entries","push","key","value","sort","a","b","length","apply","resolver","getHook","tapAsync","request","stack","callback","_gatsbyThemeShadowingOriginalRequestPath","theme","component","getThemeAndComponent","context","issuer","requestPathIsIssuerShadowPath","issuerPath","userSiteDir","originalRequestPath","originalRequestComponent","basename","builtComponentPath","resolveComponentPath","doResolve","hooks","describedRelative","filter","themesArray","join","concat","reverse","themeDir","acceptableShadowFileNames","getAcceptableShadowFileNames","possibleComponentPath","dir","readdirSync","dirname","e","existsDir","filepath","matchingShadowFile","find","shadowFile","includes","allMatchingThemes","startsWith","matchingThemes","uniqBy","Error","split","getBaseShadowDirsForThemes","Array","from","shadowFiles","flatMap","comp","componentName","matchingEntry","entry","endsWith","additionalNames","baseName","slice","legacyAdditionalNames","uniq"],"mappings":"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","sourcesContent":["const path = require(`path`)\nconst debug = require(`debug`)(`gatsby:component-shadowing`)\nconst fs = require(`fs`)\nconst _ = require(`lodash`)\n\n// A file can be shadowed by a file of the same extension, or a file of a\n// \"compatible\" file extension; two files extensions are compatible if they both\n// belongs to the same \"category\". For example, a .JS file (that is code), may\n// be shadowed by a .TS file or a .JSX file (both are code), but not by a .CSS\n// file (that is a stylesheet) or a .PNG file (that is an image). The following\n// list establish to which category a given file extension belongs. Note that if\n// a file is not present in this list, then it can only be shadowed by a file\n// of the same extension.\n\n// FIXME: Determine how this list can be extended by user/plugins\nconst DEFAULT_FILE_EXTENSIONS_CATEGORIES = {\n  // Code formats\n  js: `code`,\n  jsx: `code`,\n  ts: `code`,\n  tsx: `code`,\n  cjs: `code`,\n  mjs: `code`,\n  coffee: `code`,\n\n  // JSON-like data formats\n  json: `json`,\n  yaml: `json`,\n  yml: `json`,\n\n  // Stylesheets formats\n  css: `stylesheet`,\n  sass: `stylesheet`,\n  scss: `stylesheet`,\n  less: `stylesheet`,\n  \"css.js\": `stylesheet`,\n\n  // Images formats\n  jpeg: `image`,\n  jpg: `image`,\n  jfif: `image`,\n  png: `image`,\n  tiff: `image`,\n  webp: `image`,\n  avif: `image`,\n  gif: `image`,\n\n  // Fonts\n  woff: `font`,\n  woff2: `font`,\n}\n\n// TO-DO:\n//  - implement ability to add/remove shadowed modules from the webpack chain as file are being created/deleted\n//    ( https://github.com/gatsbyjs/gatsby/issues/11456 ):\n//    - this will also need to add memo invalidation for page template shadowing:\n//      see memoized `shadowCreatePagePath` function used in `createPage` action creator.\n\nmodule.exports = class GatsbyThemeComponentShadowingResolverPlugin {\n  constructor({ projectRoot, themes, extensions, extensionsCategory }) {\n    debug(\n      `themes list`,\n      themes.map(({ themeName }) => themeName)\n    )\n    this.themes = themes\n    this.projectRoot = projectRoot\n\n    this.extensions = extensions ?? []\n    this.extensionsCategory = {\n      ...DEFAULT_FILE_EXTENSIONS_CATEGORIES,\n      ...extensionsCategory,\n    }\n    this.additionalShadowExtensions = this.buildAdditionalShadowExtensions()\n  }\n\n  buildAdditionalShadowExtensions() {\n    const extensionsByCategory = _.groupBy(\n      this.extensions,\n      ext => this.extensionsCategory[ext.substring(1)] || `undefined`\n    )\n\n    const additionalExtensions = []\n    for (const [category, exts] of Object.entries(extensionsByCategory)) {\n      if (category === `undefined`) continue\n      for (const ext of exts) {\n        additionalExtensions.push({ key: ext, value: exts })\n      }\n    }\n\n    // Sort extensions in reverse length order, so that something such as\n    // \".css.js\" get caught before \".js\"\n    return additionalExtensions.sort(\n      ({ key: a }, { key: b }) => a.length <= b.length\n    )\n  }\n\n  apply(resolver) {\n    // This hook is executed very early and captures the original file name\n    resolver\n      .getHook(`resolve`)\n      .tapAsync(\n        `GatsbyThemeComponentShadowingResolverPlugin`,\n        (request, stack, callback) => {\n          if (!request._gatsbyThemeShadowingOriginalRequestPath) {\n            request._gatsbyThemeShadowingOriginalRequestPath = request.request\n          }\n          return callback()\n        }\n      )\n\n    // This is where the magic really happens\n    resolver\n      .getHook(`before-resolved`)\n      .tapAsync(\n        `GatsbyThemeComponentShadowingResolverPlugin`,\n        (request, stack, callback) => {\n          const [theme, component] = this.getThemeAndComponent(request.path)\n          if (!theme) {\n            return callback()\n          }\n\n          if (\n            /**\n             * if someone adds\n             * ```\n             * modules: [path.resolve(__dirname, /src'), 'node_modules'],\n             * ```\n             * to the webpack config, `issuer` is `null`, so we skip this check.\n             * note that it's probably a bad idea in general to set `modules`\n             * like this in a theme, but we also shouldn't artificially break\n             * people that do.\n             */\n            request.context.issuer &&\n            /**\n             * An issuer is the file making the require request. It can\n             * be in a user's site or a theme. If the issuer is requesting\n             * a path in the shadow chain that it participates in, then we\n             * will let the request through as normal. Otherwise, we\n             * engage the shadowing algorithm.\n             */\n            this.requestPathIsIssuerShadowPath({\n              component,\n              theme,\n              issuerPath: request.context.issuer,\n              userSiteDir: this.projectRoot,\n            })\n          ) {\n            return callback()\n          }\n\n          const originalRequestPath =\n            request._gatsbyThemeShadowingOriginalRequestPath\n          const originalRequestComponent = path.basename(originalRequestPath)\n\n          // This is the shadowing algorithm.\n          const builtComponentPath = this.resolveComponentPath({\n            theme,\n            component,\n            originalRequestComponent,\n          })\n\n          if (builtComponentPath) {\n            return resolver.doResolve(\n              resolver.hooks.describedRelative,\n              { ...request, path: builtComponentPath },\n              null,\n              {},\n              callback\n            )\n          } else {\n            return callback()\n          }\n        }\n      )\n  }\n\n  // check the user's project and the theme files\n  resolveComponentPath({ theme, component, originalRequestComponent }) {\n    // don't include matching theme in possible shadowing paths\n    const themes = this.themes.filter(\n      ({ themeName }) => themeName !== theme.themeName\n    )\n\n    const themesArray = [\n      path.join(this.projectRoot, `src`, theme.themeName),\n    ].concat(\n      themes\n        .reverse()\n        .map(({ themeDir }) => path.join(themeDir, `src`, theme.themeName))\n    )\n\n    const acceptableShadowFileNames = this.getAcceptableShadowFileNames(\n      path.basename(component),\n      originalRequestComponent\n    )\n\n    for (const theme of themesArray) {\n      const possibleComponentPath = path.join(theme, component)\n      debug(`possibleComponentPath`, possibleComponentPath)\n\n      let dir\n      try {\n        // we use fs/path instead of require.resolve to work with\n        // TypeScript and alternate syntaxes\n        dir = fs.readdirSync(path.dirname(possibleComponentPath))\n      } catch (e) {\n        continue\n      }\n      const existsDir = dir.map(filepath => path.basename(filepath))\n\n      // if no exact path, search for extension\n      const matchingShadowFile = acceptableShadowFileNames.find(shadowFile =>\n        existsDir.includes(shadowFile)\n      )\n      if (matchingShadowFile) {\n        return path.join(\n          path.dirname(possibleComponentPath),\n          matchingShadowFile\n        )\n      }\n    }\n    return null\n  }\n\n  getThemeAndComponent(filepath) {\n    // find out which theme's src/components dir we're requiring from\n    const allMatchingThemes = this.themes.filter(({ themeDir }) =>\n      filepath.startsWith(path.join(themeDir, `src`))\n    )\n\n    // The same theme can be included twice in the themes list causing multiple\n    // matches. This case should only be counted as a single match for that theme.\n    const matchingThemes = _.uniqBy(allMatchingThemes, `themeName`)\n\n    // 0 matching themes happens a lot for paths we don't want to handle\n    // > 1 matching theme means we have a path like\n    //   `gatsby-theme-blog/src/components/gatsby-theme-something/src/components`\n    if (matchingThemes.length > 1) {\n      throw new Error(\n        `Gatsby can't differentiate between themes ${matchingThemes\n          .map(theme => theme.themeName)\n          .join(` and `)} for path ${filepath}`\n      )\n    }\n\n    if (matchingThemes.length === 0) {\n      return [null, null]\n    }\n\n    const theme = matchingThemes[0]\n\n    // get the location of the component relative to its theme's src/\n    const [, component] = filepath.split(path.join(theme.themeDir, `src`))\n\n    return [theme, component]\n  }\n\n  // given a theme name, return all of the possible shadow locations\n  getBaseShadowDirsForThemes(theme) {\n    return Array.from(this.themes)\n      .reverse()\n      .map(({ themeName, themeDir }) => {\n        if (themeName === theme) {\n          return path.join(themeDir, `src`)\n        } else {\n          return path.join(themeDir, `src`, theme)\n        }\n      })\n  }\n\n  requestPathIsIssuerShadowPath({ theme, component, issuerPath, userSiteDir }) {\n    if (!theme || !component) {\n      return false\n    }\n\n    // get list of potential shadow locations\n    const shadowFiles = this.getBaseShadowDirsForThemes(theme.themeName)\n      .concat(path.join(userSiteDir, `src`, theme.themeName))\n      .map(dir => path.join(dir, component))\n      .flatMap(comp => this.getAcceptableShadowFileNames(comp))\n\n    // if the issuer is requesting a path that is a potential shadow path of itself\n    return shadowFiles.includes(issuerPath)\n  }\n\n  getAcceptableShadowFileNames(componentName, originalRequestComponent) {\n    const matchingEntry = this.additionalShadowExtensions.find(entry =>\n      componentName.endsWith(entry.key)\n    )\n\n    let additionalNames = []\n    if (matchingEntry) {\n      const baseName = componentName.slice(0, -matchingEntry.key.length)\n      additionalNames = matchingEntry.value.map(ext => `${baseName}${ext}`)\n    }\n\n    let legacyAdditionalNames = []\n    if (originalRequestComponent) {\n      legacyAdditionalNames = this.extensions.map(\n        ext => `${originalRequestComponent}${ext}`\n      )\n    }\n\n    return _.uniq([componentName, ...additionalNames, ...legacyAdditionalNames])\n  }\n}\n"],"file":"index.js"}
{"version":3,"sources":["../../../src/schema/types/derived-types.ts"],"names":["getDerivedTypes","typeComposer","derivedTypes","getExtension","Set","deleteFieldsOfDerivedTypes","getFieldNames","forEach","fieldName","fieldType","getField","type","has","getTypeName","removeField","removeTypeFromSchemaComposer","schemaComposer","delete","_gqType","clearDerivedTypes","typeName","values","derivedTypeComposer","getAnyTC","ObjectTypeComposer","InterfaceTypeComposer","inputTypeComposer","getInputTypeComposer","removeInputTypeComposer","setExtension","addDerivedType","derivedTypeName","add"],"mappings":";;;;;AA+BA;;AA/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA,MAAMA,eAAe,GAAG,CAAC;AACvBC,EAAAA;AADuB,CAAD,KAIL;AACjB,QAAMC,YAAY,GAAGD,YAAY,CAACE,YAAb,CAA2B,cAA3B,CAArB;;AACA,MAAID,YAAJ,EAAkB;AAChB,WAAOA,YAAP;AACD;;AAED,SAAO,IAAIE,GAAJ,EAAP;AACD,CAXD;;AAaO,MAAMC,0BAA0B,GAAG,CAAC;AAAEJ,EAAAA;AAAF,CAAD,KAA4B;AACpE,QAAMC,YAAY,GAAGF,eAAe,CAAC;AAAEC,IAAAA;AAAF,GAAD,CAApC;AAEAA,EAAAA,YAAY,CAACK,aAAb,GAA6BC,OAA7B,CAAqCC,SAAS,IAAI;AAChD,UAAMC,SAAS,GAAGR,YAAY,CAACS,QAAb,CAAsBF,SAAtB,EAAiCG,IAAnD;;AAEA,QAAIT,YAAY,CAACU,GAAb,CAAiBH,SAAS,CAACI,WAAV,EAAjB,CAAJ,EAA+C;AAC7CZ,MAAAA,YAAY,CAACa,WAAb,CAAyBN,SAAzB;AACD;AACF,GAND;AAOD,CAVM;;;;AAYP,MAAMO,4BAA4B,GAAG,CAAC;AACpCC,EAAAA,cADoC;AAEpCf,EAAAA;AAFoC,CAAD,KAGzB;AACVe,EAAAA,cAAc,CAACC,MAAf,CAAsBhB,YAAY,CAACY,WAAb,EAAtB;AACAG,EAAAA,cAAc,CAACC,MAAf,CAAuBhB,YAAD,CAAsBiB,OAA5C;AACAF,EAAAA,cAAc,CAACC,MAAf,CAAsBhB,YAAtB;AACD,CAPD;;AASO,MAAMkB,iBAAiB,GAAG,CAAC;AAChCH,EAAAA,cADgC;AAEhCf,EAAAA;AAFgC,CAAD,KAMrB;AACV,QAAMC,YAAY,GAAGF,eAAe,CAAC;AAAEC,IAAAA;AAAF,GAAD,CAApC;;AAEA,OAAK,MAAMmB,QAAX,IAAuBlB,YAAY,CAACmB,MAAb,EAAvB,EAA8C;AAC5C,UAAMC,mBAAmB,GAAGN,cAAc,CAACO,QAAf,CAAwBH,QAAxB,CAA5B;AACAD,IAAAA,iBAAiB,CAAC;AAAEH,MAAAA,cAAF;AAAkBf,MAAAA,YAAY,EAAEqB;AAAhC,KAAD,CAAjB;AACAP,IAAAA,4BAA4B,CAAC;AAC3BC,MAAAA,cAD2B;AAE3Bf,MAAAA,YAAY,EAAEqB;AAFa,KAAD,CAA5B;AAID;;AAED,MACErB,YAAY,YAAYuB,kCAAxB,IACAvB,YAAY,YAAYwB,qCAF1B,EAGE;AACA,UAAMC,iBAAiB,GAAGzB,YAAY,CAAC0B,oBAAb,EAA1B;AACAZ,IAAAA,4BAA4B,CAAC;AAC3BC,MAAAA,cAD2B;AAE3Bf,MAAAA,YAAY,EAAEyB;AAFa,KAAD,CAA5B;AAIAzB,IAAAA,YAAY,CAAC2B,uBAAb;AACD;;AAED3B,EAAAA,YAAY,CAAC4B,YAAb,CAA2B,cAA3B,EAA0C,IAAIzB,GAAJ,EAA1C;AACD,CA/BM;;;;AAiCA,MAAM0B,cAAc,GAAG,CAAC;AAC7B7B,EAAAA,YAD6B;AAE7B8B,EAAAA;AAF6B,CAAD,KAMlB;AACV,QAAM7B,YAAY,GAAGF,eAAe,CAAC;AAAEC,IAAAA;AAAF,GAAD,CAApC;AACAA,EAAAA,YAAY,CAAC4B,YAAb,CAA2B,cAA3B,EAA0C3B,YAAY,CAAC8B,GAAb,CAAiBD,eAAjB,CAA1C;AACD,CATM","sourcesContent":["/**\n * Derived types are types that make sense only when their base type exists\n *\n * Take this node for example:\n * {\n *   internal: { type: 'Foo' },\n *   fields: {\n *     bar: \"string\",\n *   }\n * }\n *\n * It will produce following types:\n * Foo\n * FooFields\n *\n * FooInputFilter\n * FooSortInput\n *\n * FooFieldsInputFilter\n * FooFieldsSortFilter\n * etc\n *\n * Derived types:\n *   Foo: FooFields, FooInputFilter, FooSortInput\n *   FooFields: FooFieldsInputFilter, FooFieldsSortFilter\n *\n * Caveats:\n *   Only types created via inference are marked as derived. So if in the example above\n *   user explicitly defines `FooFields` type (via `createTypes` call) it won't be considered\n *   a derived type\n */\nimport {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  ScalarTypeComposer,\n  SchemaComposer,\n  InputTypeComposer,\n  EnumTypeComposer,\n  UnionTypeComposer,\n} from \"graphql-compose\"\n\ntype AllTypeComposer =\n  | ObjectTypeComposer\n  | InputTypeComposer\n  | EnumTypeComposer\n  | InterfaceTypeComposer\n  | UnionTypeComposer\n  | ScalarTypeComposer\n\nconst getDerivedTypes = ({\n  typeComposer,\n}: {\n  typeComposer: AllTypeComposer\n}): Set<string> => {\n  const derivedTypes = typeComposer.getExtension(`derivedTypes`)\n  if (derivedTypes) {\n    return derivedTypes as Set<string>\n  }\n\n  return new Set()\n}\n\nexport const deleteFieldsOfDerivedTypes = ({ typeComposer }): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const fieldType = typeComposer.getField(fieldName).type\n\n    if (derivedTypes.has(fieldType.getTypeName())) {\n      typeComposer.removeField(fieldName)\n    }\n  })\n}\n\nconst removeTypeFromSchemaComposer = ({\n  schemaComposer,\n  typeComposer,\n}): void => {\n  schemaComposer.delete(typeComposer.getTypeName())\n  schemaComposer.delete((typeComposer as any)._gqType)\n  schemaComposer.delete(typeComposer)\n}\n\nexport const clearDerivedTypes = ({\n  schemaComposer,\n  typeComposer,\n}: {\n  schemaComposer: SchemaComposer<any>\n  typeComposer: AllTypeComposer\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  for (const typeName of derivedTypes.values()) {\n    const derivedTypeComposer = schemaComposer.getAnyTC(typeName)\n    clearDerivedTypes({ schemaComposer, typeComposer: derivedTypeComposer })\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: derivedTypeComposer,\n    })\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    const inputTypeComposer = typeComposer.getInputTypeComposer()\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: inputTypeComposer,\n    })\n    typeComposer.removeInputTypeComposer()\n  }\n\n  typeComposer.setExtension(`derivedTypes`, new Set())\n}\n\nexport const addDerivedType = ({\n  typeComposer,\n  derivedTypeName,\n}: {\n  typeComposer: AllTypeComposer\n  derivedTypeName: string\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n  typeComposer.setExtension(`derivedTypes`, derivedTypes.add(derivedTypeName))\n}\n"],"file":"derived-types.js"}
{"version":3,"sources":["../../../../src/datastore/lmdb/query/create-index.ts"],"names":["undefinedSymbol","Symbol","for","createIndex","context","typeName","indexFields","indexName","buildIndexName","meta","getIndexMetadata","state","indexReady","lockIndex","err","doCreateIndex","assertReady","databases","metadata","get","toMetadataKey","Error","datastore","indexes","label","console","time","resolvedNodes","store","getState","resolvedNodesCache","stats","maxKeysPerItem","keyCount","itemCount","indexMetadata","keyFields","multiKeyFields","keyPrefix","i","node","iterateNodesByType","resolvedFields","id","keys","prepareIndexKeys","length","Math","max","push","indexKey","put","Promise","resolve","setTimeout","Set","timeEnd","e","error","String","indexKeyElements","dottedField","fieldValue","indexFieldValue","jsValueToLmdbKey","path","internal","type","Array","isArray","flat","counter","justLocked","ifNoExists","reject","retries","timeout","poll","min","fields","tokens","field","sortDirection","join","value","result","item","lmdbKey","undefined","JSON","stringify"],"mappings":"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","sourcesContent":["import { inspect } from \"util\"\nimport { store } from \"../../../redux\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { IDataStore, ILmdbDatabases } from \"../../types\"\nimport { cartesianProduct, resolveFieldValue } from \"./common\"\n\ninterface IIndexingContext {\n  databases: ILmdbDatabases\n  datastore: IDataStore\n}\n\nexport type IndexFields = Map<string, number> // name, direction\n\nexport interface IIndexMetadata {\n  state: \"ready\" | \"building\" | \"stale\" | \"error\" | \"initial\"\n  error?: string\n  typeName: string\n  keyPrefix: number | string\n  keyFields: Array<[fieldName: string, orderDirection: number]>\n  multiKeyFields: Array<string>\n\n  // Stats for multi-key indexes\n  // (e.g. when node is { id: `id`, foo: [1,2] } it translates into two index keys: [1,`id`], [2,`id`])\n  stats: {\n    keyCount: number\n    itemCount: number\n    maxKeysPerItem: number\n  }\n}\n\nexport const undefinedSymbol = Symbol.for(`undef`)\n\nexport type IndexFieldValue =\n  | number\n  | string\n  | boolean\n  | null\n  | typeof undefinedSymbol\n  | Array<IndexFieldValue>\n\nexport type IndexKey = Array<IndexFieldValue>\n\nexport async function createIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields\n): Promise<IIndexMetadata> {\n  const indexName = buildIndexName(typeName, indexFields)\n  const meta = getIndexMetadata(context, typeName, indexFields, false)\n\n  switch (meta?.state) {\n    case `ready`:\n      return meta\n    case `building`: {\n      return indexReady(context, indexName)\n    }\n    case `initial`:\n    default: {\n      try {\n        await lockIndex(context, indexName)\n      } catch (err) {\n        // Index is being updated in some other process.\n        // Wait and assume it's in a good state when done\n        return indexReady(context, indexName)\n      }\n      return doCreateIndex(context, typeName, indexFields)\n    }\n  }\n}\n\nexport function getIndexMetadata(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields,\n  assertReady = true\n): IIndexMetadata {\n  const { databases } = context\n  const indexName = buildIndexName(typeName, indexFields)\n  const meta: IIndexMetadata = databases.metadata.get(toMetadataKey(indexName))\n\n  if (assertReady && meta?.state !== `ready`) {\n    throw new Error(\n      `Index ${indexName} is not ready yet. State: ${meta?.state ?? `unknown`}`\n    )\n  }\n  return meta\n}\n\nasync function doCreateIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields\n): Promise<IIndexMetadata> {\n  const { datastore, databases } = context\n  const { indexes, metadata } = databases\n  const indexName = buildIndexName(typeName, indexFields)\n\n  const label = `Indexing ${indexName}`\n  console.time(label)\n\n  // Assuming materialization was run before creating index\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n\n  // TODO: iterate only over dirty nodes\n  // TODO: wrap in async transaction?\n  const stats: IIndexMetadata[\"stats\"] = {\n    maxKeysPerItem: 0,\n    keyCount: 0,\n    itemCount: 0,\n  }\n  const indexMetadata: IIndexMetadata = {\n    state: `building`,\n    typeName,\n    keyFields: [...indexFields],\n    multiKeyFields: [],\n    keyPrefix: indexName, // FIXME\n    stats,\n  }\n\n  try {\n    let i = 0\n    for (const node of datastore.iterateNodesByType(typeName)) {\n      // Assuming materialization was run (executing custom resolvers for fields in `filter` and `sort` clauses)\n      //  And materialized values of those fields are stored in resolvedNodes\n      const resolvedFields = resolvedNodes?.get(node.id)\n      const { keys, multiKeyFields } = prepareIndexKeys(\n        node,\n        resolvedFields,\n        indexName,\n        indexFields\n      )\n      stats.keyCount += keys.length\n      stats.itemCount++\n      stats.maxKeysPerItem = Math.max(stats.maxKeysPerItem, keys.length)\n      indexMetadata.multiKeyFields.push(...multiKeyFields)\n\n      for (const indexKey of keys) {\n        // Note: this may throw if indexKey exceeds 1978 chars (lmdb limit) or contain objects/buffers/etc\n        indexes.put(indexKey, node.id)\n      }\n      if (++i % 5000 === 0) {\n        // Do not block event loop too much\n        await new Promise(resolve => setTimeout(resolve, 3))\n      }\n    }\n    indexMetadata.state = `ready`\n    indexMetadata.multiKeyFields = [...new Set(indexMetadata.multiKeyFields)]\n\n    await metadata.put(toMetadataKey(indexName), indexMetadata)\n    console.timeEnd(label)\n\n    return indexMetadata\n  } catch (e) {\n    indexMetadata.state = `error`\n    indexMetadata.error = String(e)\n    await metadata.put(toMetadataKey(indexName), indexMetadata)\n    throw e\n  }\n}\n\n/**\n * Returns a list of index keys for a given node.\n * One node may produce multiple index entries when indexing over array values.\n *\n * For example:\n *  Node: { foo: [{ bar: `bar1`}, { bar: `bar2` }] }\n *  Index fields: [`foo.bar`] will produce the following elements: [`bar1`, `bar2`]\n *\n * Keys are prefixed with index name and suffixed with node counter for stable sort.\n *\n * If materialization result (resolvedFields) exists for a given index field\n *  it is used as a key element, otherwise the a raw node value is used.\n */\nfunction prepareIndexKeys(\n  node: IGatsbyNode,\n  resolvedFields: { [field: string]: unknown } | undefined,\n  indexName: string,\n  indexFields: IndexFields\n): { keys: Array<IndexKey>; multiKeyFields: Array<string> } {\n  // TODO: use index id vs index name (shorter)\n  const indexKeyElements: Array<Array<IndexFieldValue>> = []\n  const multiKeyFields: Array<string> = []\n\n  indexKeyElements.push([indexName])\n  for (const dottedField of indexFields.keys()) {\n    const fieldValue = resolveFieldValue(dottedField, node, resolvedFields)\n    let indexFieldValue = jsValueToLmdbKey(fieldValue)\n\n    // Got value that can't be stored in lmdb key\n    if (typeof indexFieldValue === `undefined`) {\n      const path = `${node.internal.type}.${dottedField} (id: ${node.id})`\n      throw new Error(`Bad value at ${path}: ${inspect(fieldValue)}`)\n    }\n    indexFieldValue = Array.isArray(indexFieldValue)\n      ? indexFieldValue.flat() // FIXME\n      : [indexFieldValue]\n\n    indexKeyElements.push(indexFieldValue)\n\n    if (indexFieldValue.length > 1) {\n      multiKeyFields.push(dottedField)\n    }\n  }\n  indexKeyElements.push([node.internal.counter])\n\n  return { keys: cartesianProduct(...indexKeyElements), multiKeyFields }\n}\n\nasync function lockIndex(\n  context: IIndexingContext,\n  indexName: string\n): Promise<void> {\n  const { metadata } = context.databases\n  const indexKey = toMetadataKey(indexName)\n\n  const justLocked = await metadata.ifNoExists(indexKey, () => {\n    metadata.put(indexKey, null)\n  })\n  if (!justLocked) {\n    throw new Error(`Index is already locked`)\n  }\n}\n\nasync function indexReady(\n  context: IIndexingContext,\n  indexName: string\n): Promise<IIndexMetadata> {\n  return new Promise((resolve, reject) => {\n    const { metadata } = context.databases\n\n    let retries = 0\n    let timeout = 16\n    function poll(): void {\n      const indexMetadata = metadata.get(toMetadataKey(indexName))\n      if (indexMetadata?.state === `ready`) {\n        resolve(indexMetadata)\n        return\n      }\n      if (retries++ > 1000) {\n        reject(new Error(`Index ${indexName} is locked for too long`))\n        return\n      }\n      setTimeout(poll, timeout)\n      timeout = Math.min(200, timeout * 1.5)\n    }\n    poll()\n  })\n}\n\n/**\n * Autogenerate index name based on parameters.\n *\n * Example:\n *\n * buildIndexName(`Foo`, { foo: 1, bar: -1 }) -> `Foo/foo:1/bar:-1\n */\nfunction buildIndexName(typeName: string, fields: IndexFields): string {\n  const tokens: Array<string> = [typeName]\n\n  for (const [field, sortDirection] of fields) {\n    tokens.push(`${field}:${sortDirection}`)\n  }\n\n  return tokens.join(`/`)\n}\n\nfunction toMetadataKey(indexName: string): string {\n  return `index:${indexName}`\n}\n\nfunction jsValueToLmdbKey(value: unknown): IndexFieldValue | undefined {\n  if (\n    typeof value === `number` ||\n    typeof value === `string` ||\n    typeof value === `boolean` ||\n    value === null\n  ) {\n    return value\n  }\n  if (typeof value === `undefined`) {\n    // Array keys containing `undefined` are not supported by lmdb-store\n    //  But we can't exclude those nodes from an index because\n    //  filters { eq: null, gte: null, lte: null } are expected to return such nodes\n    // Furthermore, lmdb-store puts those keys before others and we want them to be below\n    //  so need to add additional padding\n    return undefinedSymbol\n  }\n  if (Array.isArray(value)) {\n    const result: Array<IndexFieldValue> = []\n    for (const item of value) {\n      const lmdbKey = jsValueToLmdbKey(item)\n      if (typeof lmdbKey === `undefined`) {\n        return undefined // bad value\n      }\n      result.push(lmdbKey)\n    }\n    return result\n  }\n  // FIXME: not sure if we want this but there are tests for this :/\n  if (typeof value === `object`) {\n    return JSON.stringify(value)\n  }\n  return undefined\n}\n"],"file":"create-index.js"}
{"version":3,"sources":["../../../src/schema/graphql-engine/lmdb-bundling-patch.ts"],"names":["createRequire","require","source","lmdbBinaryLocation","lmdbRoot","_module","resourceResolveData","descriptionFileRoot","path","dirname","resourcePath","replace","lmdbRequire","nodeGypBuild","relative","e","JSON","stringify"],"mappings":";;;;;;;AAEA;;AACA;;AAHA;;AACA;AAIA;AACA,MAAM;AAAEA,EAAAA;AAAF,IAAoBC,OAAO,CAAE,QAAF,CAAjC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACe,kBAAqBC,MAArB,EAA6C;AAC1D,MAAIC,kBAAJ;;AACA,MAAI;AAAA;;AACF,UAAMC,QAAQ,GACZ,2EAAMC,OAAN,CAAcC,mBAAd,gFAAmCC,mBAAnC,KACAC,eAAKC,OAAL,CAAa,KAAKC,YAAlB,EAAgCC,OAAhC,CAAyC,OAAzC,EAAkD,EAAlD,CAFF;;AAIA,UAAMC,WAAW,GAAGZ,aAAa,CAAC,KAAKU,YAAN,CAAjC;AACA,UAAMG,YAAY,GAAGD,WAAW,CAAE,gBAAF,CAAhC;AAEAT,IAAAA,kBAAkB,GAAG,iBACnBK,eAAKM,QAAL,CACEN,eAAKC,OAAL,CAAa,KAAKC,YAAlB,CADF,EAEEG,YAAY,CAACL,IAAb,CAAkBJ,QAAlB,CAFF,CADmB,CAArB;AAMD,GAdD,CAcE,OAAOW,CAAP,EAAU;AACV,WAAOb,MAAP;AACD;;AACD,SAAOA,MAAM,CACVS,OADI,CAEF,sCAFE,EAGF,WAAUK,IAAI,CAACC,SAAL,CAAed,kBAAf,CAAmC,GAH3C,EAKJQ,OALI,CAMF,sCANE,EAOF,qCAPE,EASJA,OATI,CAUH,+WAVG,EAWF,sDAXE,CAAP;AAaD","sourcesContent":["/* eslint-disable @babel/no-invalid-this */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { slash } from \"gatsby-core-utils/path\"\nimport path from \"path\"\n\n// we need to require this module, we can't use import here\nconst { createRequire } = require(`module`)\n\n// This is hacky webpack loader that does string replacements to\n// allow lmdb@2 to be bundled by webpack for engines.\n// Currently `@vercel/webpack-asset-relocator-loader doesn't handle\n// the way lmdb is loading binaries and dictionary file\n// (can't statically analyze it). So we perform few localized changes\n// and we replace dynamic values with hardcoded ones to allow\n// asset-relocator to pick those assets up and handle them.\n//\n// Because lmdb code can diverge, we also pin version in gatsby\n// dependencies and will have manually bump it (with renovate most likely).\n//\n// To solve this upstream few things would need to change:\n//  - https://github.com/DoctorEvidence/lmdb-js/blob/544b3fda402f24a70a0e946921e4c9134c5adf85/node-index.js#L14-L16\n//  - https://github.com/DoctorEvidence/lmdb-js/blob/544b3fda402f24a70a0e946921e4c9134c5adf85/open.js#L77\n// Reliance on `import.meta.url` + usage of `.replace` is what seems to cause problems currently.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function (this: any, source: string): string {\n  let lmdbBinaryLocation: string | undefined\n  try {\n    const lmdbRoot =\n      this?._module.resourceResolveData?.descriptionFileRoot ||\n      path.dirname(this.resourcePath).replace(`/dist`, ``)\n\n    const lmdbRequire = createRequire(this.resourcePath)\n    const nodeGypBuild = lmdbRequire(`node-gyp-build`)\n\n    lmdbBinaryLocation = slash(\n      path.relative(\n        path.dirname(this.resourcePath),\n        nodeGypBuild.path(lmdbRoot)\n      )\n    )\n  } catch (e) {\n    return source\n  }\n  return source\n    .replace(\n      `require$1('node-gyp-build')(dirName)`,\n      `require(${JSON.stringify(lmdbBinaryLocation)})`\n    )\n    .replace(\n      `require$2.resolve('./dict/dict.txt')`,\n      `require.resolve('../dict/dict.txt')`\n    )\n    .replace(\n      /fs\\.readFileSync\\(new URL\\('\\.\\/dict\\/dict\\.txt',\\s*\\(typeof\\s*document\\s*===\\s*'undefined'\\s*\\?\\s*new\\s*\\(require\\('u'\\s*\\+\\s*'rl'\\)\\.URL\\)\\s*\\('file:'\\s*\\+\\s*__filename\\).href\\s*:\\s*\\(document\\.currentScript\\s*&&\\s*document\\.currentScript\\.src\\s*\\|\\|\\s*new URL\\('index\\.cjs',\\s*document\\.baseURI\\)\\.href\\)\\)\\.replace\\(\\/dist\\[\\\\\\\\\\\\\\/\\]index\\.cjs\\$\\/,\\s*''\\)\\)\\)/g,\n      `fs.readFileSync(require.resolve('../dict/dict.txt'))`\n    )\n}\n"],"file":"lmdb-bundling-patch.js"}
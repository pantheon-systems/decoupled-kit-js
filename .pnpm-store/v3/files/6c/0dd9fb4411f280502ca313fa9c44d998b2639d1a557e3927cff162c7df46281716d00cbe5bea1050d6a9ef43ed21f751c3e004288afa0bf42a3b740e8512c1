{"version":3,"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/recursively-transform-fields.js"],"names":["transformInlineFragments","possibleTypes","gatsbyNodesInfo","typeMap","maxDepth","parentType","mainType","parentField","fragments","circularQueryLimit","buildGatsbyNodeFields","depth","buildingFragment","ancestorTypeNames","parentAncestorTypeNames","state","store","getState","remoteSchema","pluginOptions","gatsbyApi","schema","queryDepth","transformedInlineFragments","map","possibleType","type","get","name","typeSettings","exclude","dispatch","addFetchedType","isAGatsbyNode","typeNames","includes","fields","typeInfo","filteredFields","kind","filter","filteredField","find","recursivelyTransformFields","length","Boolean","countIncarnations","typeName","ancestorTypeName","transformField","field","fieldBlacklist","fieldAliases","typeKind","typeIncarnationCount","createFragment","fieldName","args","arg","fieldType","ofType","isListOfGatsbyNodes","isListOfMediaItems","hasIdField","listOfType","transformedFields","inlineFragments","every","isAMediaItemNode","isAnInterfaceType","parentFieldName","previouslyCreatedFragment","fragmentFields","reduce","fieldTypeName","innerFieldField","transformedField","push","queryType","transformFields","fragment","fragmentField","internalType","fieldInlineFragment","fragmentInlineFragment","fieldTypeKind","fieldOfTypeKind","typeKindsRequiringSelectionSets","fieldNeedsSelectionSet","grandParentTypeName","recursivelyTransformedFields"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport {\n  getTypeSettingsByType,\n  findTypeName,\n  findTypeKind,\n} from \"~/steps/create-schema-customization/helpers\"\nimport { fieldIsExcludedOnParentType } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { returnAliasedFieldName } from \"~/steps/create-schema-customization/transform-fields\"\n\nexport const transformInlineFragments = ({\n  possibleTypes,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  parentType,\n  mainType,\n  parentField,\n  fragments,\n  circularQueryLimit,\n  buildGatsbyNodeFields = false,\n  depth = 0,\n  buildingFragment = false,\n  ancestorTypeNames: parentAncestorTypeNames = [],\n}) => {\n  const state = store.getState()\n\n  if (!typeMap) {\n    typeMap = state.remoteSchema.typeMap\n  }\n\n  const { pluginOptions } = state.gatsbyApi\n\n  if (!maxDepth) {\n    maxDepth = pluginOptions.schema.queryDepth\n  }\n\n  if (!circularQueryLimit) {\n    circularQueryLimit = pluginOptions.circularQueryLimit\n  }\n\n  if (!gatsbyNodesInfo) {\n    gatsbyNodesInfo = state.remoteSchema.gatsbyNodesInfo\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const transformedInlineFragments = possibleTypes\n    .map(possibleType => {\n      possibleType = { ...possibleType }\n\n      const type = typeMap.get(possibleType.name)\n\n      if (!type) {\n        return false\n      }\n\n      const typeSettings = getTypeSettingsByType(type)\n\n      if (typeSettings.exclude) {\n        return false\n      }\n\n      possibleType.type = { ...type }\n\n      // save this type so we can use it in schema customization\n      store.dispatch.remoteSchema.addFetchedType(type)\n\n      const isAGatsbyNode = gatsbyNodesInfo.typeNames.includes(\n        possibleType.name\n      )\n\n      if (isAGatsbyNode && !buildGatsbyNodeFields) {\n        // we use the id to link to the top level Gatsby node\n        possibleType.fields = [`id`]\n        return possibleType\n      }\n\n      const typeInfo = typeMap.get(possibleType.name)\n\n      let filteredFields = [...typeInfo.fields]\n\n      if (parentType?.kind === `INTERFACE`) {\n        // remove any fields from our fragment if the parent type already has them as shared fields\n        filteredFields = filteredFields.filter(\n          filteredField =>\n            !parentType.fields.find(\n              parentField => parentField.name === filteredField.name\n            )\n        )\n      }\n\n      if (typeInfo) {\n        const fields = recursivelyTransformFields({\n          fields: filteredFields,\n          parentType: type,\n          depth,\n          ancestorTypeNames,\n          fragments,\n          buildingFragment,\n          circularQueryLimit,\n          mainType,\n          parentField,\n        })\n\n        if (!fields || !fields.length) {\n          return false\n        }\n\n        possibleType.fields = [...fields]\n        return possibleType\n      }\n\n      return false\n    })\n    .filter(Boolean)\n\n  return possibleTypes && depth <= maxDepth ? transformedInlineFragments : null\n}\n\n// since we're counting circular types that may be on fields many levels up, incarnation felt like it works here ;) the types are born again in later generations\nconst countIncarnations = ({ typeName, ancestorTypeNames }) =>\n  ancestorTypeNames.length\n    ? ancestorTypeNames.filter(\n        ancestorTypeName => ancestorTypeName === typeName\n      )?.length\n    : 0\n\nexport function transformField({\n  field,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  ancestorTypeNames: parentAncestorTypeNames,\n  circularQueryLimit,\n  fragments,\n  buildingFragment,\n  mainType,\n} = {}) {\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  // we're potentially infinitely recursing when fields are connected to other types that have fields that are connections to other types\n  //  so we need a maximum limit for that\n  if (depth > maxDepth) {\n    return false\n  }\n\n  depth++\n\n  // if the field has no type we can't use it.\n  if (!field || !field.type) {\n    return false\n  }\n\n  const typeSettings = getTypeSettingsByType(field.type)\n\n  if (typeSettings.exclude) {\n    return false\n  }\n\n  // count the number of times this type has appeared as an ancestor of itself\n  // somewhere up the tree\n  const typeName = findTypeName(field.type)\n  const typeKind = findTypeKind(field.type)\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount > 0) {\n    // this type is nested within itself atleast once\n    // create a fragment here that can be reused\n    createFragment({\n      fields: typeMap.get(typeName).fields,\n      type: field.type,\n      fragments,\n      field,\n      ancestorTypeNames: parentAncestorTypeNames,\n      depth,\n      fieldBlacklist,\n      fieldAliases,\n      typeMap,\n      gatsbyNodesInfo,\n      circularQueryLimit,\n      queryDepth: maxDepth,\n      buildingFragment,\n      mainType,\n    })\n  }\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return false\n  }\n\n  // this is used to alias fields that conflict with Gatsby node fields\n  // for ex Gatsby and WPGQL both have a `parent` field\n  const fieldName = returnAliasedFieldName({ fieldAliases, field })\n\n  if (\n    fieldBlacklist.includes(field.name) ||\n    fieldBlacklist.includes(fieldName)\n  ) {\n    return false\n  }\n\n  // remove fields that have required args. They'll cause query errors if omitted\n  //  and we can't determine how to use those args programatically.\n  if (\n    field.args &&\n    field.args.length &&\n    field.args.find(arg => arg?.type?.kind === `NON_NULL`)\n  ) {\n    return false\n  }\n\n  const fieldType = typeMap.get(findTypeName(field.type)) || {}\n  const ofType = typeMap.get(findTypeName(fieldType.ofType)) || {}\n\n  if (\n    fieldType.kind === `SCALAR` ||\n    fieldType.kind === `ENUM` ||\n    (fieldType.kind === `NON_NULL` && ofType.kind === `SCALAR`) ||\n    (fieldType.kind === `LIST` && fieldType.ofType.kind === `SCALAR`) ||\n    // a list of enums has no type name, so findTypeName above finds the enum type\n    // instead of the field type. Need to explicitly check here\n    // instead of using helpers\n    (field.type.kind === `LIST` && field.type?.ofType?.kind === `ENUM`)\n  ) {\n    return {\n      fieldName,\n      fieldType,\n    }\n  }\n\n  const isListOfGatsbyNodes =\n    ofType && gatsbyNodesInfo.typeNames.includes(typeName)\n\n  const isListOfMediaItems = ofType && typeName === `MediaItem`\n\n  const hasIdField = fieldType?.fields?.find(({ name }) => name === `id`)\n  if (\n    fieldType.kind === `LIST` &&\n    isListOfGatsbyNodes &&\n    !isListOfMediaItems &&\n    hasIdField\n  ) {\n    return {\n      fieldName: fieldName,\n      fields: [`id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST` && isListOfMediaItems && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST`) {\n    const listOfType = typeMap.get(findTypeName(fieldType))\n\n    const transformedFields = recursivelyTransformFields({\n      fields: listOfType.fields,\n      parentType: listOfType || fieldType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n      mainType,\n    })\n\n    const transformedInlineFragments = transformInlineFragments({\n      possibleTypes: listOfType.possibleTypes,\n      parentType: listOfType || fieldType,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    // if we have either inlineFragments or fields\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  const isAGatsbyNode =\n    // if this is a gatsby node type\n    gatsbyNodesInfo.typeNames.includes(typeName) ||\n    // or all possible types on this type are Gatsby node types\n    typeMap\n      .get(typeName)\n      ?.possibleTypes?.every(possibleType =>\n        gatsbyNodesInfo.typeNames.includes(possibleType.name)\n      )\n\n  const isAMediaItemNode = isAGatsbyNode && typeName === `MediaItem`\n\n  // pull the id and __typename for connections to media item gatsby nodes\n  if (isAMediaItemNode && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (isAGatsbyNode && hasIdField) {\n    const isAnInterfaceType =\n      // if this is an interface\n      typeKind === `INTERFACE` || fieldType.kind === `INTERFACE`\n\n    return {\n      fieldName: fieldName,\n      fields: isAnInterfaceType\n        ? // we need the typename for interfaces\n          [`id`, `__typename`]\n        : // or just the id for 1:1 connections to gatsby nodes\n          [`id`],\n      fieldType,\n    }\n  }\n\n  const typeInfo = typeMap.get(findTypeName(fieldType))\n\n  const { fields } = typeInfo || {}\n\n  let transformedInlineFragments\n\n  if (typeInfo.possibleTypes) {\n    transformedInlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      parentType: typeInfo,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n  }\n\n  if (fields || transformedInlineFragments) {\n    const transformedFields = recursivelyTransformFields({\n      parentType: typeInfo,\n      parentFieldName: field.name,\n      mainType,\n      fields,\n      depth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  if (fieldType.kind === `UNION`) {\n    const typeInfo = typeMap.get(fieldType.name)\n\n    const transformedFields = recursivelyTransformFields({\n      fields: typeInfo.fields,\n      parentType: fieldType,\n      mainType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    const inlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      gatsbyNodesInfo,\n      typeMap,\n      mainType,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments,\n      fieldType,\n    }\n  }\n\n  return false\n}\n\nconst createFragment = ({\n  fields,\n  field,\n  type,\n  fragments,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  ancestorTypeNames,\n  mainType,\n  buildingFragment = false,\n}) => {\n  const typeName = findTypeName(type)\n\n  if (buildingFragment) {\n    // this fragment is inside a fragment that's already being built so we should exit\n    return null\n  }\n\n  const previouslyCreatedFragment = fragments?.[typeName]\n\n  if (previouslyCreatedFragment && buildingFragment === typeName) {\n    return previouslyCreatedFragment\n  }\n\n  const fragmentFields = fields.reduce((fragmentFields, field) => {\n    const fieldTypeName = findTypeName(field.type)\n    const fieldType = typeMap.get(fieldTypeName)\n\n    if (\n      // if this field is a different type than the fragment but has a field of the same type as the fragment,\n      // we need to skip this field in the fragment to prevent nesting this type in itself a level down\n      fieldType.name !== typeName &&\n      fieldType?.fields?.find(\n        innerFieldField => findTypeName(innerFieldField.type) === typeName\n      )\n    ) {\n      return fragmentFields\n    }\n\n    const transformedField = transformField({\n      field,\n      gatsbyNodesInfo,\n      typeMap,\n      maxDepth: queryDepth,\n      depth: 0,\n      fieldBlacklist,\n      fieldAliases,\n      ancestorTypeNames,\n      mainType,\n      circularQueryLimit: 1,\n      fragments,\n      buildingFragment: typeName,\n    })\n\n    if (findTypeName(field.type) !== typeName && !!transformedField) {\n      fragmentFields.push(transformedField)\n    }\n\n    return fragmentFields\n  }, [])\n\n  const queryType = typeMap.get(typeName)\n\n  const transformedInlineFragments = queryType?.possibleTypes?.length\n    ? transformInlineFragments({\n        possibleTypes: queryType.possibleTypes,\n        parentType: queryType,\n        parentField: field,\n        mainType,\n        gatsbyNodesInfo,\n        typeMap,\n        depth: 0,\n        maxDepth: queryDepth,\n        circularQueryLimit: 1,\n        ancestorTypeNames,\n        fragments,\n        buildingFragment: typeName,\n      })\n    : null\n\n  if (fragments) {\n    fragments[typeName] = {\n      name: `${typeName}Fragment`,\n      type: typeName,\n      fields: fragmentFields,\n      inlineFragments: transformedInlineFragments,\n    }\n  }\n\n  return fragmentFields\n}\n\nconst transformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  circularQueryLimit,\n  pluginOptions,\n  buildingFragment,\n}) =>\n  fields\n    ?.filter(\n      field =>\n        !fieldIsExcludedOnParentType({\n          pluginOptions,\n          field,\n          parentType,\n          mainType,\n          parentField,\n        })\n    )\n    .map(field => {\n      const transformedField = transformField({\n        maxDepth: queryDepth,\n        gatsbyNodesInfo,\n        fieldBlacklist,\n        fieldAliases,\n        typeMap,\n        field,\n        depth,\n        ancestorTypeNames,\n        circularQueryLimit,\n        fragments,\n        buildingFragment,\n        mainType,\n        parentField,\n      })\n\n      if (transformedField) {\n        // save this type so we know to use it in schema customization\n        store.dispatch.remoteSchema.addFetchedType(field.type)\n      }\n\n      const typeName = findTypeName(field.type)\n      const fragment = fragments?.[typeName]\n\n      // @todo add any adjacent fields and inline fragments directly to the stored fragment object so this logic can be changed to if (fragment) useTheFragment()\n      // once that's done it can be added above and below transformField() above ☝️\n      // and potentially short circuit expensive work that will be thrown away anyway\n      if (fragment && transformedField && buildingFragment !== typeName) {\n        // if (fragment && buildingFragment !== typeName && transformedField) {\n        // remove fields from this query that already exist in the fragment\n        if (transformedField?.fields?.length) {\n          transformedField.fields = transformedField.fields.filter(\n            field =>\n              !fragment.fields.find(\n                fragmentField => fragmentField.fieldName === field.fieldName\n              )\n          )\n        }\n\n        // if this field has no fields (because it has inline fragments only)\n        // we need to create an empty array since we treat reusable fragments as\n        // a field\n        if (!transformedField.fields) {\n          transformedField.fields = []\n        }\n\n        transformedField.fields.push({\n          internalType: `Fragment`,\n          fragment,\n        })\n\n        if (transformedField?.inlineFragments?.length) {\n          transformedField.inlineFragments =\n            transformedField.inlineFragments.filter(\n              fieldInlineFragment =>\n                // yes this is a horrible use of .find(). @todo refactor this for better perf\n                !fragment.inlineFragments.find(\n                  fragmentInlineFragment =>\n                    fragmentInlineFragment.name === fieldInlineFragment.name\n                )\n            )\n        }\n      }\n\n      if (field.fields && !transformedField) {\n        return null\n      }\n\n      const fieldTypeKind = findTypeKind(field.type)\n      const fieldOfTypeKind = findTypeKind(field.type.ofType)\n      const typeKindsRequiringSelectionSets = [`OBJECT`, `UNION`, `INTERFACE`]\n      const fieldNeedsSelectionSet =\n        typeKindsRequiringSelectionSets.includes(fieldTypeKind) ||\n        typeKindsRequiringSelectionSets.includes(fieldOfTypeKind)\n\n      if (\n        // if our field needs a selectionset\n        fieldNeedsSelectionSet &&\n        // but we have no fields\n        !transformedField.fields &&\n        // and no inline fragments\n        !transformedField.inlineFragments\n      ) {\n        // we need to discard this field to prevent GraphQL errors\n        // we're likely at the very bottom of the query depth\n        // so that this fields children were omitted\n        return null\n      }\n\n      return transformedField\n    })\n    .filter(Boolean)\n\nconst recursivelyTransformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames: parentAncestorTypeNames,\n  depth = 0,\n  buildingFragment = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  if (!parentAncestorTypeNames) {\n    parentAncestorTypeNames = []\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const {\n    gatsbyApi: { pluginOptions },\n    remoteSchema: { fieldBlacklist, fieldAliases, typeMap, gatsbyNodesInfo },\n  } = store.getState()\n\n  const {\n    schema: { queryDepth, circularQueryLimit },\n  } = pluginOptions\n\n  if (depth > queryDepth && ancestorTypeNames.length) {\n    return null\n  }\n\n  const typeName = findTypeName(parentType)\n\n  const grandParentTypeName = ancestorTypeNames.length\n    ? ancestorTypeNames[ancestorTypeNames.length - 1]\n    : null\n\n  if (grandParentTypeName && typeName !== grandParentTypeName) {\n    // if a field has fields of the same type as the field above it\n    // we shouldn't fetch them. 2 types that are circular between each other\n    // are dangerous as they will generate very large queries and fetch data we don't need\n    // these types should instead be proper connections so we can identify\n    // that only an id needs to be fetched.\n    // @todo maybe move this into transformFields() instead of here\n    fields = fields.filter(field => {\n      const fieldTypeName = findTypeName(field.type)\n      return fieldTypeName !== grandParentTypeName\n    })\n  }\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return null\n  }\n\n  parentAncestorTypeNames.push(typeName)\n\n  const recursivelyTransformedFields = transformFields({\n    fields,\n    parentType,\n    mainType,\n    fragments,\n    parentField,\n    ancestorTypeNames: parentAncestorTypeNames,\n    depth,\n    fieldBlacklist,\n    fieldAliases,\n    typeMap,\n    gatsbyNodesInfo,\n    queryDepth,\n    circularQueryLimit,\n    pluginOptions,\n    buildingFragment,\n  })\n\n  if (!recursivelyTransformedFields.length) {\n    return null\n  }\n\n  return recursivelyTransformedFields\n}\n\nexport default recursivelyTransformFields\n"],"file":"recursively-transform-fields.js"}
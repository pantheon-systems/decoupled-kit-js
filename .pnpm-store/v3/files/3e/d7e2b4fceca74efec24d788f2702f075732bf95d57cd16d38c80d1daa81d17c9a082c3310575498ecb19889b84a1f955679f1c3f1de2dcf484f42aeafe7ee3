{"version":3,"sources":["../../src/redux/types.ts"],"names":["ProgramStatus"],"mappings":";;;;IAwBYA,a;;;WAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;GAAAA,a,6BAAAA,a","sourcesContent":["import type { TrailingSlash } from \"gatsby-page-utils\"\nimport { IProgram } from \"../commands/types\"\nimport { GraphQLFieldExtensionDefinition } from \"../schema/extensions\"\nimport { DocumentNode, GraphQLSchema, DefinitionNode } from \"graphql\"\nimport { SchemaComposer } from \"graphql-compose\"\nimport { IGatsbyCLIState } from \"gatsby-cli/src/reporter/redux/types\"\nimport { ThunkAction } from \"redux-thunk\"\nimport { InternalJob, JobResultInterface } from \"../utils/jobs/manager\"\nimport { ITypeMetadata } from \"../schema/infer/inference-metadata\"\nimport { Span } from \"opentracing\"\n\ntype SystemPath = string\ntype Identifier = string\n\nexport interface IRedirect {\n  fromPath: string\n  toPath: string\n  isPermanent?: boolean\n  redirectInBrowser?: boolean\n  ignoreCase: boolean\n  // Users can add anything to this createRedirect API\n  [key: string]: any\n}\n\nexport enum ProgramStatus {\n  BOOTSTRAP_FINISHED = `BOOTSTRAP_FINISHED`,\n  BOOTSTRAP_QUERY_RUNNING_FINISHED = `BOOTSTRAP_QUERY_RUNNING_FINISHED`,\n}\n\nexport type PageMode = \"SSG\" | \"DSG\" | \"SSR\"\n\nexport interface IGatsbyPage {\n  internalComponentName: string\n  path: string\n  matchPath: undefined | string\n  component: SystemPath\n  componentChunkName: string\n  isCreatedByStatefulCreatePages: boolean\n  context: Record<string, unknown>\n  updatedAt: number\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  pluginCreator___NODE: Identifier\n  pluginCreatorId: Identifier\n  componentPath: SystemPath\n  ownerNodeId: Identifier\n  manifestId?: string\n  defer?: boolean\n  /**\n   * INTERNAL. Do not use `page.mode`, it can be removed at any time\n   * `page.mode` is currently reliable only in engines and `onPostBuild` hook\n   * (in develop it is dynamic and can change at any time)\n   * TODO: remove, see comments in utils/page-mode:materializePageMode\n   *\n   * @internal\n   */\n  mode: PageMode\n}\n\nexport interface IGatsbyFunction {\n  /** The route in the browser to access the function **/\n  functionRoute: string\n  /** The absolute path to the original function **/\n  originalAbsoluteFilePath: string\n  /** The relative path to the original function **/\n  originalRelativeFilePath: string\n  /** The relative path to the compiled function (always ends with .js) **/\n  relativeCompiledFilePath: string\n  /** The absolute path to the compiled function (doesn't transfer across machines) **/\n  absoluteCompiledFilePath: string\n  /** The matchPath regex created by path-to-regexp. Only created if the function is dynamic. **/\n  matchPath: string | undefined\n  /** The plugin that owns this function route **/\n  pluginName: string\n}\n\nexport interface IGatsbyConfig {\n  plugins?: Array<{\n    // This is the name of the plugin like `gatsby-plugin-manifest\n    resolve: string\n    options: {\n      [key: string]: unknown\n    }\n  }>\n  siteMetadata?: {\n    title?: string\n    author?: string\n    description?: string\n    siteUrl?: string\n    // siteMetadata is free form\n    [key: string]: unknown\n  }\n  // @deprecated\n  polyfill?: boolean\n  developMiddleware?: any\n  proxy?: any\n  pathPrefix?: string\n  assetPrefix?: string\n  mapping?: Record<string, string>\n  jsxRuntime?: \"classic\" | \"automatic\"\n  jsxImportSource?: string\n  trailingSlash?: TrailingSlash\n}\n\nexport interface IGatsbyNode {\n  id: Identifier\n  parent: Identifier\n  children: Array<Identifier>\n  internal: {\n    type: string\n    counter: number\n    owner: string\n    contentDigest: string\n    mediaType?: string\n    content?: string\n    description?: string\n  }\n  __gatsby_resolved: any // TODO\n  [key: string]: unknown\n  fields: Array<string>\n}\n\nexport interface IGatsbyPlugin {\n  id: Identifier\n  name: string\n  version: string\n  [key: string]: any\n}\n\nexport interface IGatsbyPluginContext {\n  [key: string]: (...args: Array<any>) => any\n}\n\nexport interface IGatsbyStaticQueryComponents {\n  name: string\n  componentPath: SystemPath\n  id: Identifier\n  query: string\n  hash: string\n}\n\nexport interface IGatsbyPageComponent {\n  componentPath: SystemPath\n  componentChunkName: string\n  query: string\n  pages: Set<string>\n  isInBootstrap: boolean\n  serverData: boolean\n  config: boolean\n}\n\nexport interface IDefinitionMeta {\n  name: string\n  def: DefinitionNode\n  filePath: string\n  text: string\n  templateLoc: any\n  printedAst: string\n  isHook: boolean\n  isStaticQuery: boolean\n  isFragment: boolean\n  hash: string\n}\n\ntype GatsbyNodes = Map<string, IGatsbyNode>\n\nexport interface IGatsbyIncompleteJobV2 {\n  job: InternalJob\n}\n\nexport interface IGatsbyIncompleteJob {\n  job: InternalJob\n  plugin: IGatsbyPlugin\n}\n\nexport interface IGatsbyCompleteJobV2 {\n  result: JobResultInterface\n  inputPaths: InternalJob[\"inputPaths\"]\n}\n\nexport interface IPlugin {\n  name: string\n  options: Record<string, any>\n}\n\nexport interface IBabelStage {\n  plugins: Array<IPlugin>\n  presets: Array<IPlugin>\n  options: {\n    cacheDirectory: boolean\n    sourceType: string\n    sourceMaps?: string\n  }\n}\n\ntype BabelStageKeys =\n  | \"develop\"\n  | \"develop-html\"\n  | \"build-html\"\n  | \"build-javascript\"\n\nexport interface IStateProgram extends IProgram {\n  extensions: Array<string>\n  browserslist: Array<string>\n}\n\nexport interface IQueryState {\n  dirty: number\n  running: number\n}\n\nexport interface IComponentState {\n  componentPath: string\n  query: string\n  pages: Set<Identifier>\n  errors: number\n}\n\nexport interface IHtmlFileState {\n  dirty: number\n  isDeleted: boolean\n  pageDataHash: string\n}\n\nexport interface IStaticQueryResultState {\n  dirty: number\n  staticQueryResultHash: string\n}\n\nexport type GatsbyNodeAPI =\n  | \"onPreBoostrap\"\n  | \"onPostBoostrap\"\n  | \"onCreateWebpackConfig\"\n  | \"onCreatePage\"\n  | \"onCreateNode\"\n  | \"sourceNodes\"\n  | \"createPagesStatefully\"\n  | \"createPages\"\n  | \"onPostBuild\"\n\nexport interface IGatsbyState {\n  program: IStateProgram\n  nodes: GatsbyNodes\n  nodesByType: Map<string, GatsbyNodes>\n  resolvedNodesCache: Map<string, any> // TODO\n  nodesTouched: Set<string>\n  nodeManifests: Array<INodeManifest>\n  lastAction: ActionsUnion\n  flattenedPlugins: Array<{\n    resolve: SystemPath\n    id: Identifier\n    name: string\n    version: string\n    pluginOptions: {\n      plugins: []\n      [key: string]: unknown\n    }\n    nodeAPIs: Array<GatsbyNodeAPI>\n    browserAPIs: Array<\n      | \"onRouteUpdate\"\n      | \"registerServiceWorker\"\n      | \"onServiceWorkerActive\"\n      | \"onPostPrefetchPathname\"\n    >\n    ssrAPIs: Array<\"onRenderBody\" | \"onPreRenderHTML\">\n    pluginFilepath: SystemPath\n    subPluginPaths?: Array<string>\n    modulePath?: string\n  }>\n  config: IGatsbyConfig\n  functions: Array<IGatsbyFunction>\n  pages: Map<string, IGatsbyPage>\n  schema: GraphQLSchema\n  definitions: Map<string, IDefinitionMeta>\n  status: {\n    plugins: Record<string, IGatsbyPlugin>\n    PLUGINS_HASH: Identifier\n    LAST_NODE_COUNTER: number\n  }\n  queries: {\n    byNode: Map<Identifier, Set<Identifier>>\n    byConnection: Map<string, Set<Identifier>>\n    queryNodes: Map<Identifier, Set<Identifier>>\n    trackedQueries: Map<Identifier, IQueryState>\n    trackedComponents: Map<string, IComponentState>\n    deletedQueries: Set<Identifier>\n    dirtyQueriesListToEmitViaWebsocket: Array<string>\n  }\n  components: Map<IGatsbyPageComponent[\"componentPath\"], IGatsbyPageComponent>\n  staticQueryComponents: Map<\n    IGatsbyStaticQueryComponents[\"id\"],\n    IGatsbyStaticQueryComponents\n  >\n  staticQueriesByTemplate: Map<SystemPath, Array<Identifier>>\n  pendingPageDataWrites: {\n    pagePaths: Set<string>\n  }\n  // @deprecated\n  jobs: {\n    active: Array<any> // TODO\n    done: Array<any> // TODO\n  }\n  jobsV2: {\n    incomplete: Map<Identifier, IGatsbyIncompleteJobV2>\n    complete: Map<Identifier, IGatsbyCompleteJobV2>\n    jobsByRequest: Map<string, Set<Identifier>>\n  }\n  webpack: any // TODO This should be the output from ./utils/webpack.config.js\n  webpackCompilationHash: string\n  redirects: Array<IRedirect>\n  babelrc: {\n    stages: {\n      [key in BabelStageKeys]: IBabelStage\n    }\n  }\n  schemaCustomization: {\n    composer: null | SchemaComposer<any>\n    context: Record<string, any>\n    fieldExtensions: GraphQLFieldExtensionDefinition\n    printConfig: {\n      path?: string\n      include?: { types?: Array<string>; plugins?: Array<string> }\n      exclude?: { types?: Array<string>; plugins?: Array<string> }\n      withFieldTypes?: boolean\n    } | null\n    thirdPartySchemas: Array<GraphQLSchema>\n    types: Array<\n      string | { typeOrTypeDef: DocumentNode; plugin: IGatsbyPlugin }\n    >\n  }\n  logs: IGatsbyCLIState\n  inferenceMetadata: {\n    step: string // TODO make enum or union\n    typeMap: {\n      [key: string]: ITypeMetadata\n    }\n  }\n  pageDataStats: Map<SystemPath, number>\n  visitedPages: Map<string, Set<string>>\n  html: {\n    trackedHtmlFiles: Map<Identifier, IHtmlFileState>\n    browserCompilationHash: string\n    ssrCompilationHash: string\n    trackedStaticQueryResults: Map<string, IStaticQueryResultState>\n    unsafeBuiltinWasUsedInSSR: boolean\n  }\n}\n\nexport type GatsbyStateKeys = keyof IGatsbyState\n\nexport interface ICachedReduxState {\n  nodes?: IGatsbyState[\"nodes\"]\n  status: IGatsbyState[\"status\"]\n  components: IGatsbyState[\"components\"]\n  jobsV2: IGatsbyState[\"jobsV2\"]\n  staticQueryComponents: IGatsbyState[\"staticQueryComponents\"]\n  webpackCompilationHash: IGatsbyState[\"webpackCompilationHash\"]\n  pageDataStats: IGatsbyState[\"pageDataStats\"]\n  pages?: IGatsbyState[\"pages\"]\n  staticQueriesByTemplate: IGatsbyState[\"staticQueriesByTemplate\"]\n  pendingPageDataWrites: IGatsbyState[\"pendingPageDataWrites\"]\n  queries: IGatsbyState[\"queries\"]\n  html: IGatsbyState[\"html\"]\n}\n\nexport type ActionsUnion =\n  | IAddChildNodeToParentNodeAction\n  | IAddFieldToNodeAction\n  | IAddThirdPartySchema\n  | IApiFinishedAction\n  | ICreateFieldExtension\n  | ICreateNodeAction\n  | ICreatePageAction\n  | ICreatePageDependencyAction\n  | ICreateTypes\n  | IDeleteCacheAction\n  | IDeleteNodeAction\n  | IDeletePageAction\n  | IPageQueryRunAction\n  | IPrintTypeDefinitions\n  | IQueryClearDirtyQueriesListToEmitViaWebsocket\n  | IQueryExtractedAction\n  | IQueryExtractedBabelSuccessAction\n  | IQueryExtractionBabelErrorAction\n  | IQueryExtractionGraphQLErrorAction\n  | IQueryStartAction\n  | IRemoveStaticQuery\n  | IReplaceComponentQueryAction\n  | IReplaceStaticQueryAction\n  | IReplaceWebpackConfigAction\n  | ISetPluginStatusAction\n  | ISetProgramStatusAction\n  | ISetResolvedNodesAction\n  | ISetSchemaAction\n  | ISetGraphQLDefinitionsAction\n  | ISetSiteFlattenedPluginsAction\n  | ISetWebpackCompilationHashAction\n  | ISetSSRWebpackCompilationHashAction\n  | ISetWebpackConfigAction\n  | ITouchNodeAction\n  | IUpdatePluginsHashAction\n  | ICreateJobV2Action\n  | IEndJobV2Action\n  | IRemoveStaleJobV2Action\n  | IAddPageDataStatsAction\n  | IRemoveTemplateComponentAction\n  | ISetBabelPluginAction\n  | ISetBabelPresetAction\n  | ISetBabelOptionsAction\n  | ICreateJobAction\n  | ISetJobAction\n  | IEndJobAction\n  | ISetStaticQueriesByTemplateAction\n  | IAddPendingPageDataWriteAction\n  | IAddPendingTemplateDataWriteAction\n  | IClearPendingPageDataWriteAction\n  | ICreateResolverContext\n  | IClearSchemaCustomizationAction\n  | ISetSchemaComposerAction\n  | IStartIncrementalInferenceAction\n  | IBuildTypeMetadataAction\n  | IDisableTypeInferenceAction\n  | ISetProgramAction\n  | ISetProgramExtensions\n  | IRemovedHtml\n  | ITrackedHtmlCleanup\n  | IGeneratedHtml\n  | IMarkHtmlDirty\n  | ISSRUsedUnsafeBuiltin\n  | ISetSiteConfig\n  | IMergeWorkerQueryState\n  | ISetComponentFeatures\n  | IMaterializePageMode\n  | ISetJobV2Context\n  | IClearJobV2Context\n\nexport interface ISetComponentFeatures {\n  type: `SET_COMPONENT_FEATURES`\n  payload: {\n    componentPath: string\n    serverData: boolean\n    config: boolean\n  }\n}\n\nexport interface IApiFinishedAction {\n  type: `API_FINISHED`\n  payload: {\n    apiName: GatsbyNodeAPI\n  }\n}\n\ninterface ISetBabelPluginAction {\n  type: `SET_BABEL_PLUGIN`\n  payload: {\n    stage: BabelStageKeys\n    name: IPlugin[\"name\"]\n    options: IPlugin[\"options\"]\n  }\n}\n\ninterface ISetBabelPresetAction {\n  type: `SET_BABEL_PRESET`\n  payload: {\n    stage: BabelStageKeys\n    name: IPlugin[\"name\"]\n    options: IPlugin[\"options\"]\n  }\n}\n\ninterface ISetBabelOptionsAction {\n  type: `SET_BABEL_OPTIONS`\n  payload: {\n    stage: BabelStageKeys\n    name: IPlugin[\"name\"]\n    options: IPlugin[\"options\"]\n  }\n}\n\nexport interface ICreateJobV2Action {\n  type: `CREATE_JOB_V2`\n  payload: {\n    job: IGatsbyIncompleteJobV2[\"job\"]\n  }\n  plugin: { name: string }\n}\n\nexport interface IEndJobV2Action {\n  type: `END_JOB_V2`\n  payload: {\n    jobContentDigest: string\n    result: JobResultInterface\n  }\n  plugin: { name: string }\n}\n\nexport interface IRemoveStaleJobV2Action {\n  type: `REMOVE_STALE_JOB_V2`\n  payload: {\n    contentDigest: string\n  }\n}\n\nexport type ICreateJobV2FromInternalAction = ThunkAction<\n  Promise<Record<string, unknown>>,\n  IGatsbyState,\n  void,\n  ActionsUnion\n>\n\ninterface ICreateJobAction {\n  type: `CREATE_JOB`\n  payload: {\n    id: string\n    job: IGatsbyIncompleteJob[\"job\"]\n  }\n  plugin: IGatsbyIncompleteJob[\"plugin\"]\n}\n\ninterface ISetJobAction {\n  type: `SET_JOB`\n  payload: {\n    id: string\n    job: IGatsbyIncompleteJob[\"job\"]\n  }\n  plugin: IGatsbyIncompleteJob[\"plugin\"]\n}\n\ninterface IEndJobAction {\n  type: `END_JOB`\n  payload: {\n    id: string\n    job: IGatsbyIncompleteJob[\"job\"]\n  }\n  plugin: IGatsbyIncompleteJob[\"plugin\"]\n}\n\nexport interface ICreatePageDependencyActionPayloadType {\n  path: string\n  nodeId?: string\n  connection?: string\n}\n\nexport interface ICreatePageDependencyAction {\n  type: `CREATE_COMPONENT_DEPENDENCY`\n  plugin?: string\n  payload: Array<ICreatePageDependencyActionPayloadType>\n}\n\nexport interface IDeleteComponentDependenciesAction {\n  type: \"DELETE_COMPONENTS_DEPENDENCIES\"\n  payload: {\n    paths: Array<string>\n  }\n}\n\nexport interface IReplaceComponentQueryAction {\n  type: \"REPLACE_COMPONENT_QUERY\"\n  payload: {\n    query: string\n    componentPath: string\n  }\n}\n\nexport interface IReplaceStaticQueryAction {\n  type: `REPLACE_STATIC_QUERY`\n  plugin: IGatsbyPlugin | null | undefined\n  payload: {\n    name: string\n    componentPath: string\n    id: string\n    query: string\n    hash: string\n  }\n}\n\nexport interface IQueryClearDirtyQueriesListToEmitViaWebsocket {\n  type: `QUERY_CLEAR_DIRTY_QUERIES_LIST_TO_EMIT_VIA_WEBSOCKET`\n}\n\nexport interface IQueryExtractedAction {\n  type: `QUERY_EXTRACTED`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: { componentPath: string; query: string }\n}\n\nexport interface IQueryExtractionGraphQLErrorAction {\n  type: `QUERY_EXTRACTION_GRAPHQL_ERROR`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: { componentPath: string; error: string }\n}\n\nexport interface IQueryExtractedBabelSuccessAction {\n  type: `QUERY_EXTRACTION_BABEL_SUCCESS`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: { componentPath: string }\n}\n\nexport interface IQueryExtractionBabelErrorAction {\n  type: `QUERY_EXTRACTION_BABEL_ERROR`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: {\n    componentPath: string\n    error: Error\n  }\n}\n\nexport interface ISetProgramStatusAction {\n  type: `SET_PROGRAM_STATUS`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: ProgramStatus\n}\n\nexport interface IPageQueryRunAction {\n  type: `PAGE_QUERY_RUN`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: {\n    path: string\n    componentPath: string\n    isPage: boolean\n    resultHash: string\n    queryHash: string\n  }\n}\n\nexport interface IQueryStartAction {\n  type: `QUERY_START`\n  plugin: IGatsbyPlugin\n  traceId: string | undefined\n  payload: { path: string; componentPath: string; isPage: boolean }\n}\n\nexport interface IRemoveStaleJobAction {\n  type: `REMOVE_STALE_JOB_V2`\n  plugin: IGatsbyPlugin | undefined\n  traceId?: string\n  payload: { contentDigest: string }\n}\n\nexport interface IAddThirdPartySchema {\n  type: `ADD_THIRD_PARTY_SCHEMA`\n  plugin: IGatsbyPlugin\n  traceId?: string\n  payload: GraphQLSchema\n}\n\nexport interface ICreateTypes {\n  type: `CREATE_TYPES`\n  plugin: IGatsbyPlugin\n  traceId?: string\n  payload: DocumentNode | Array<DocumentNode>\n}\n\nexport interface ICreateFieldExtension {\n  type: `CREATE_FIELD_EXTENSION`\n  plugin: IGatsbyPlugin\n  traceId?: string\n  payload: {\n    name: string\n    extension: GraphQLFieldExtensionDefinition\n  }\n}\n\nexport interface IPrintTypeDefinitions {\n  type: `PRINT_SCHEMA_REQUESTED`\n  plugin: IGatsbyPlugin\n  traceId?: string\n  payload: {\n    path?: string\n    include?: { types?: Array<string>; plugins?: Array<string> }\n    exclude?: { types?: Array<string>; plugins?: Array<string> }\n    withFieldTypes?: boolean\n  }\n}\n\nexport interface ICreateResolverContext {\n  type: `CREATE_RESOLVER_CONTEXT`\n  plugin: IGatsbyPlugin\n  traceId?: string\n  payload:\n    | IGatsbyPluginContext\n    | { [camelCasedPluginNameWithoutPrefix: string]: IGatsbyPluginContext }\n}\n\ninterface IClearSchemaCustomizationAction {\n  type: `CLEAR_SCHEMA_CUSTOMIZATION`\n}\n\ninterface ISetSchemaComposerAction {\n  type: `SET_SCHEMA_COMPOSER`\n  payload: SchemaComposer<any>\n}\n\nexport interface ICreateServerVisitedPage {\n  type: `CREATE_SERVER_VISITED_PAGE`\n  payload: IGatsbyPage\n  plugin?: IGatsbyPlugin\n}\n\nexport interface ICreatePageAction {\n  type: `CREATE_PAGE`\n  payload: IGatsbyPage\n  plugin?: IGatsbyPlugin\n  contextModified?: boolean\n  componentModified?: boolean\n}\n\nexport interface ICreateRedirectAction {\n  type: `CREATE_REDIRECT`\n  payload: IRedirect\n}\n\nexport interface IDeleteCacheAction {\n  type: `DELETE_CACHE`\n  cacheIsCorrupt?: boolean\n}\n\nexport interface IRemoveTemplateComponentAction {\n  type: `REMOVE_STATIC_QUERIES_BY_TEMPLATE`\n  payload: {\n    componentPath: string\n  }\n}\n\nexport interface ISetStaticQueriesByTemplateAction {\n  type: `SET_STATIC_QUERIES_BY_TEMPLATE`\n  payload: {\n    componentPath: string\n    staticQueryHashes: Array<Identifier>\n  }\n}\n\nexport interface IAddPendingPageDataWriteAction {\n  type: `ADD_PENDING_PAGE_DATA_WRITE`\n  payload: {\n    path: string\n  }\n}\n\nexport interface IAddPendingTemplateDataWriteAction {\n  type: `ADD_PENDING_TEMPLATE_DATA_WRITE`\n  payload: {\n    componentPath: SystemPath\n    pages: Array<string>\n  }\n}\n\nexport interface IClearPendingPageDataWriteAction {\n  type: `CLEAR_PENDING_PAGE_DATA_WRITE`\n  payload: {\n    page: string\n  }\n}\n\nexport interface IDeletePageAction {\n  type: `DELETE_PAGE`\n  payload: IGatsbyPage\n}\n\nexport interface IRemoveStaticQuery {\n  type: `REMOVE_STATIC_QUERY`\n  payload: IGatsbyStaticQueryComponents[\"id\"]\n}\n\nexport interface ISetWebpackCompilationHashAction {\n  type: `SET_WEBPACK_COMPILATION_HASH`\n  payload: IGatsbyState[\"webpackCompilationHash\"]\n}\n\nexport interface ISetSSRWebpackCompilationHashAction {\n  type: `SET_SSR_WEBPACK_COMPILATION_HASH`\n  payload: string\n}\n\nexport interface IUpdatePluginsHashAction {\n  type: `UPDATE_PLUGINS_HASH`\n  payload: Identifier\n}\n\nexport interface ISetPluginStatusAction {\n  type: `SET_PLUGIN_STATUS`\n  plugin: IGatsbyPlugin\n  payload: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any\n  }\n}\n\nexport interface IReplaceWebpackConfigAction {\n  type: `REPLACE_WEBPACK_CONFIG`\n  payload: IGatsbyState[\"webpack\"]\n}\n\nexport interface ISetWebpackConfigAction {\n  type: `SET_WEBPACK_CONFIG`\n  payload: Partial<IGatsbyState[\"webpack\"]>\n}\n\nexport interface ISetSchemaAction {\n  type: `SET_SCHEMA`\n  payload: IGatsbyState[\"schema\"]\n}\n\nexport interface ISetGraphQLDefinitionsAction {\n  type: `SET_GRAPHQL_DEFINITIONS`\n  payload: IGatsbyState[\"definitions\"]\n}\n\nexport interface ISetSiteConfig {\n  type: `SET_SITE_CONFIG`\n  payload: IGatsbyState[\"config\"]\n}\n\nexport interface ISetSiteFunctions {\n  type: `SET_SITE_FUNCTIONS`\n  payload: IGatsbyState[\"functions\"]\n}\n\nexport interface ICreateNodeAction {\n  type: `CREATE_NODE`\n  payload: IGatsbyNode\n  oldNode?: IGatsbyNode\n  traceId: string\n  parentSpan: Span\n  followsSpan: Span\n}\n\nexport interface IAddFieldToNodeAction {\n  type: `ADD_FIELD_TO_NODE`\n  payload: IGatsbyNode\n  addedField: string\n}\n\nexport interface IAddChildNodeToParentNodeAction {\n  type: `ADD_CHILD_NODE_TO_PARENT_NODE`\n  payload: IGatsbyNode\n}\n\nexport interface IDeleteNodeAction {\n  type: `DELETE_NODE`\n  // FIXME: figure out why payload can be undefined here\n  payload: IGatsbyNode | void\n}\n\nexport interface ISetSiteFlattenedPluginsAction {\n  type: `SET_SITE_FLATTENED_PLUGINS`\n  payload: IGatsbyState[\"flattenedPlugins\"]\n}\n\nexport interface ISetResolvedNodesAction {\n  type: `SET_RESOLVED_NODES`\n  payload: {\n    key: string\n    nodes: IGatsbyState[\"resolvedNodesCache\"]\n  }\n}\n\nexport interface IAddPageDataStatsAction {\n  type: `ADD_PAGE_DATA_STATS`\n  payload: {\n    pagePath: string\n    filePath: SystemPath\n    size: number\n    pageDataHash: string\n  }\n}\n\nexport interface ITouchNodeAction {\n  type: `TOUCH_NODE`\n  payload: Identifier\n}\n\ninterface IStartIncrementalInferenceAction {\n  type: `START_INCREMENTAL_INFERENCE`\n}\n\ninterface IBuildTypeMetadataAction {\n  type: `BUILD_TYPE_METADATA`\n  payload: {\n    nodes: Array<IGatsbyNode>\n    typeName: string\n  }\n}\n\ninterface IDisableTypeInferenceAction {\n  type: `DISABLE_TYPE_INFERENCE`\n  payload: Array<string>\n}\n\ninterface ISetProgramAction {\n  type: `SET_PROGRAM`\n  payload: IStateProgram\n}\n\ninterface ISetProgramExtensions {\n  type: `SET_PROGRAM_EXTENSIONS`\n  payload: Array<string>\n}\n\ninterface IRemovedHtml {\n  type: `HTML_REMOVED`\n  payload: string\n}\n\ninterface ITrackedHtmlCleanup {\n  type: `HTML_TRACKED_PAGES_CLEANUP`\n  payload: Set<string>\n}\n\ninterface IGeneratedHtml {\n  type: `HTML_GENERATED`\n  payload: Array<string>\n}\n\ninterface IMarkHtmlDirty {\n  type: `HTML_MARK_DIRTY_BECAUSE_STATIC_QUERY_RESULT_CHANGED`\n  payload: {\n    pages: Set<string>\n    staticQueryHashes: Set<string>\n  }\n}\n\ninterface ISSRUsedUnsafeBuiltin {\n  type: `SSR_USED_UNSAFE_BUILTIN`\n}\n\nexport interface ICreateNodeManifest {\n  type: `CREATE_NODE_MANIFEST`\n  payload: {\n    manifestId: string\n    node: IGatsbyNode\n    pluginName: string\n    updatedAtUTC?: string | number\n  }\n}\n\nexport interface IDeleteNodeManifests {\n  type: `DELETE_NODE_MANIFESTS`\n}\n\nexport interface INodeManifest {\n  manifestId: string\n  pluginName: string\n  node: {\n    id: string\n  }\n}\n\nexport interface IMergeWorkerQueryState {\n  type: `MERGE_WORKER_QUERY_STATE`\n  payload: {\n    workerId: number\n    queryStateChunk: IGatsbyState[\"queries\"]\n  }\n}\n\nexport interface IMaterializePageMode {\n  type: `MATERIALIZE_PAGE_MODE`\n  payload: {\n    path: string\n    pageMode: PageMode\n  }\n}\n\nexport interface ISetJobV2Context {\n  type: `SET_JOB_V2_CONTEXT`\n  payload: {\n    job: IGatsbyIncompleteJobV2[\"job\"]\n    requestId: string\n  }\n}\n\nexport interface IClearJobV2Context {\n  type: `CLEAR_JOB_V2_CONTEXT`\n  payload: {\n    requestId: string\n  }\n}\n"],"file":"types.js"}
{"version":3,"sources":["../../../../src/steps/create-schema-customization/transform-fields/field-transformers.js"],"names":["fieldTransformers","description","test","field","type","kind","ofType","transform","name","typeName","normalizedTypeName","fieldName","originalTypeName","typeKind","normalizedType","resolve","source","resolvedField","autoAliasedFieldPropertyName","aliasedField","gatsbyNodeTypes","pluginOptions","isAnInterfaceTypeOfGatsbyNodes","store","getState","remoteSchema","typeMap","get","possibleTypes","filter","possibleType","every","includes","transformGatsbyNodeObject","find","transformListOfGatsbyNodes","transformListOfUnions","transformUnion"],"mappings":"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","sourcesContent":["import { buildTypeName, findTypeName, findTypeKind } from \"../helpers\"\nimport { transformUnion, transformListOfUnions } from \"./transform-union\"\nimport { transformGatsbyNodeObject } from \"~/steps/create-schema-customization/transform-fields/transform-object\"\nimport { transformListOfGatsbyNodes } from \"./transform-object\"\nimport { getGatsbyNodeTypeNames } from \"~/steps/source-nodes/fetch-nodes/fetch-nodes\"\nimport { typeIsABuiltInScalar } from \"~/steps/create-schema-customization/helpers\"\nimport store from \"~/store\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { getPluginOptions } from \"~/utils/get-gatsby-api\"\n\nexport const fieldTransformers = [\n  {\n    description: `NON_NULL Scalar`,\n    test: field =>\n      field.type.kind === `NON_NULL` && field.type.ofType.kind === `SCALAR`,\n\n    transform: ({ field }) => {\n      if (typeIsABuiltInScalar(field.type)) {\n        return `${field.type.ofType.name}!`\n      } else {\n        return `JSON!`\n      }\n    },\n  },\n\n  {\n    description: `NON_NULL list type`,\n    test: field =>\n      field.type.kind === `NON_NULL` &&\n      field.type.ofType.kind === `LIST` &&\n      (field.type.ofType.name || field.type.ofType?.ofType?.name),\n\n    transform: ({ field }) => {\n      const typeName = findTypeName(field.type)\n      const normalizedTypeName = typeIsABuiltInScalar(field.type)\n        ? typeName\n        : buildTypeName(typeName)\n\n      return `[${normalizedTypeName}]!`\n    },\n  },\n\n  {\n    description: `NON_NULL lists of NON_NULL types`,\n    test: field =>\n      field.type.kind === `NON_NULL` &&\n      field.type.ofType.kind === `LIST` &&\n      field.type.ofType?.ofType?.kind === `NON_NULL`,\n\n    transform: ({ field, fieldName }) => {\n      const originalTypeName = findTypeName(field.type)\n      const typeKind = findTypeKind(field.type)\n\n      const normalizedType =\n        typeKind === `SCALAR` && typeIsABuiltInScalar(field.type)\n          ? originalTypeName\n          : buildTypeName(originalTypeName)\n\n      return {\n        type: `[${normalizedType}!]!`,\n        resolve: source => {\n          const resolvedField = source[fieldName]\n\n          if (typeof resolvedField !== `undefined`) {\n            return resolvedField ?? []\n          }\n\n          const autoAliasedFieldPropertyName = `${fieldName}__typename_${field?.type?.name}`\n\n          const aliasedField = source[autoAliasedFieldPropertyName]\n\n          return aliasedField ?? []\n        },\n      }\n    },\n  },\n\n  {\n    description: `Lists of NON_NULL builtin types`,\n    test: field =>\n      field.type.kind === `LIST` &&\n      field.type.ofType.kind === `NON_NULL` &&\n      (field.type.ofType.name ?? field.type.ofType?.ofType?.name) &&\n      typeIsABuiltInScalar(field.type),\n\n    transform: ({ field }) => `[${findTypeName(field.type)}!]`,\n  },\n\n  {\n    description: `Lists of NON_NULL types`,\n    test: field =>\n      field.type.kind === `LIST` &&\n      field.type.ofType.kind === `NON_NULL` &&\n      (field.type.ofType.name ?? field.type.ofType?.ofType?.name),\n\n    transform: ({ field }) => `[${buildTypeName(findTypeName(field.type))}!]`,\n  },\n\n  {\n    description: `ENUM type`,\n    test: field => field.type.kind === `ENUM`,\n    transform: ({ field }) => buildTypeName(field.type.name),\n  },\n\n  {\n    description: `Scalar type`,\n    test: field => field.type.kind === `SCALAR`,\n    transform: ({ field }) => {\n      if (typeIsABuiltInScalar(field.type)) {\n        return field.type.name\n      } else {\n        // custom scalars are typed as JSON\n        // @todo if frequently requested,\n        // make this hookable so a plugin could register a custom scalar\n        return `JSON`\n      }\n    },\n  },\n\n  {\n    description: `Gatsby Node Objects or Gatsby Node Interfaces where all possible types are Gatsby Nodes`,\n    test: field => {\n      const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n      const pluginOptions = getPluginOptions()\n\n      const isAnInterfaceTypeOfGatsbyNodes =\n        // if this is an interface\n        field.type.kind === `INTERFACE` &&\n        // and every possible type is a future gatsby node\n        store\n          .getState()\n          // get the full type for this interface\n          .remoteSchema.typeMap.get(findTypeName(field.type))\n          // filter out any excluded types\n          .possibleTypes?.filter(\n            possibleType =>\n              !typeIsExcluded({\n                pluginOptions,\n                typeName: possibleType.name,\n              })\n          )\n          // if every remaining type is a Gatsby node type\n          // then use this field transformer\n          ?.every(possibleType => gatsbyNodeTypes.includes(possibleType.name))\n\n      return (\n        (gatsbyNodeTypes.includes(field.type.name) &&\n          field.type.kind === `OBJECT`) ||\n        isAnInterfaceTypeOfGatsbyNodes\n      )\n    },\n\n    transform: transformGatsbyNodeObject,\n  },\n\n  {\n    description: `Lists of Gatsby Node Object types`,\n    test: field => {\n      const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n      const {\n        remoteSchema: { typeMap },\n      } = store.getState()\n\n      return (\n        // this is a list of Gatsby nodes\n        (field.type.kind === `LIST` &&\n          field.type.ofType.kind === `OBJECT` &&\n          gatsbyNodeTypes.includes(field.type.ofType.name)) ||\n        // or it's a list of an interface type which Gatsby nodes implement\n        (field.type.kind === `LIST` &&\n          field.type.ofType.kind === `INTERFACE` &&\n          typeMap\n            .get(field.type.ofType.name)\n            ?.possibleTypes?.find(possibleType =>\n              gatsbyNodeTypes.includes(possibleType.name)\n            ))\n      )\n    },\n\n    transform: transformListOfGatsbyNodes,\n  },\n\n  {\n    description: `Non-Gatsby Node Objects`,\n    test: field => field.type.kind === `OBJECT`,\n    transform: ({ field }) => buildTypeName(field.type.name),\n  },\n\n  {\n    description: `Lists of Non Gatsby Node Objects`,\n    test: field =>\n      field.type.kind === `LIST` &&\n      (field.type.ofType.kind === `OBJECT` ||\n        field.type.ofType.kind === `ENUM`),\n\n    transform: ({ field }) => `[${buildTypeName(field.type.ofType.name)}]`,\n  },\n\n  {\n    description: `Lists of Union types`,\n    test: field =>\n      field.type.kind === `LIST` && field.type.ofType.kind === `UNION`,\n\n    transform: transformListOfUnions,\n  },\n\n  {\n    description: `Lists of Scalar types`,\n    test: field =>\n      field.type.kind === `LIST` && field.type.ofType.kind === `SCALAR`,\n\n    transform: ({ field }) => {\n      if (typeIsABuiltInScalar(field.type)) {\n        return `[${field.type.ofType.name}]`\n      } else {\n        return `[JSON]`\n      }\n    },\n  },\n\n  {\n    description: `Lists of Interface types`,\n    test: field =>\n      field.type.kind === `LIST` && field.type.ofType.kind === `INTERFACE`,\n\n    transform: ({ field }) => `[${buildTypeName(field.type.ofType.name)}]`,\n  },\n\n  {\n    description: `Union type`,\n    test: field => field.type.kind === `UNION`,\n    transform: transformUnion,\n  },\n\n  {\n    description: `Interface type`,\n    test: field => field.type.kind === `INTERFACE`,\n    transform: ({ field }) => buildTypeName(field.type.name),\n  },\n\n  {\n    description: `Lists of NON_NULL types`,\n    test: field =>\n      findTypeKind(field.type) !== `LIST` && field.type.kind === `NON_NULL`,\n    transform: ({ field }) => `${buildTypeName(findTypeName(field.type))}!`,\n  },\n\n  // for finding unhandled types\n  // {\n  //   description: `Unhandled type`,\n  //   test: () => true,\n  //   transform: ({ field }) => dd(field),\n  // },\n]\n"],"file":"field-transformers.js"}
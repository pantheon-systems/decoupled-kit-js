{"version":3,"sources":["../../src/utils/js-chunk-names.ts"],"names":["kebabCase","_kebabCase","pathRelative","path","relative","replaceUnifiedRoutesKeys","kebabedName","filePath","newString","split","sep","forEach","part","match","exec","replace","chunkNameCache","Map","generateComponentChunkName","componentPath","has","get","program","store","getState","directory","name","chunkName","set"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA,MAAMA,SAAS,GAAG,uBAAQC,iBAAR,CAAlB;AACA,MAAMC,YAAY,GAAG,uBAAQC,cAAKC,QAAb,CAArB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,wBAAT,CACEC,WADF,EAEEC,QAFF,EAGU;AACR,MAAIC,SAAS,GAAGF,WAAhB;AAEAC,EAAAA,QAAQ,CAACE,KAAT,CAAeN,cAAKO,GAApB,EAAyBC,OAAzB,CAAiCC,IAAI,IAAI;AACvC,QAAIA,IAAI,CAAC,CAAD,CAAJ,KAAa,GAAb,IAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAa,GAApC,EAAwC;AACtC,YAAMC,KAAK,GAAG,sBAAsBC,IAAtB,CAA2BF,IAA3B,CAAd;AACAJ,MAAAA,SAAS,GAAGA,SAAS,CAACO,OAAV,CACT,IAAGF,KAAK,CAAE,CAAF,CAAL,IAAaA,KAAK,CAAE,CAAF,CAAK,GADjB,EAET,IAAGA,KAAK,CAAE,CAAF,CAAK,GAFJ,CAAZ;AAID;AACF,GARD;AAUA,SAAOL,SAAP;AACD;;AAED,MAAMQ,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;AACO,SAASC,0BAAT,CAAoCC,aAApC,EAAmE;AACxE,MAAIH,cAAc,CAACI,GAAf,CAAmBD,aAAnB,CAAJ,EAAuC;AACrC,WAAOH,cAAc,CAACK,GAAf,CAAmBF,aAAnB,CAAP;AACD,GAFD,MAEO;AACL,UAAM;AAAEG,MAAAA;AAAF,QAAcC,aAAMC,QAAN,EAApB;;AACA,UAAMC,SAAS,GAAG,CAAAH,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEG,SAAT,KAAuB,GAAzC;AACA,UAAMC,IAAI,GAAGxB,YAAY,CAACuB,SAAD,EAAYN,aAAZ,CAAzB;AAEA,UAAMQ,SAAS,GAAI,eAActB,wBAAwB,CACvDL,SAAS,CAAC0B,IAAD,CAD8C,EAEvDA,IAFuD,CAGvD,EAHF;AAKAV,IAAAA,cAAc,CAACY,GAAf,CAAmBT,aAAnB,EAAkCQ,SAAlC;AAEA,WAAOA,SAAP;AACD;AACF","sourcesContent":["import memoize from \"memoizee\"\nimport { kebabCase as _kebabCase } from \"lodash\"\nimport path from \"path\"\nimport { store } from \"../redux\"\n\nconst kebabCase = memoize(_kebabCase)\nconst pathRelative = memoize(path.relative)\n\n// unified routes adds support for files with [] and {},\n// the problem with our generateComponentChunkName is that when you\n// call kebabCase, is strips off characters like that. This means\n// that when you have a app with this sort of setup, the resolutions fail\n//\n// src/pages/products/{id}.js (collection route)\n// src/pages/products/[...id].js (should render when a non-matched id is passed in)\n//\n// without this function, what happens is that all visits to /products/__ resolve to only one\n// of these because the componentChunkName ends up being duplicate. This function ensures that\n// the {} and [] are kept in the componentChunkName. Also there are tests for this.\nfunction replaceUnifiedRoutesKeys(\n  kebabedName: string,\n  filePath: string\n): string {\n  let newString = kebabedName\n\n  filePath.split(path.sep).forEach(part => {\n    if (part[0] === `[` || part[0] === `{`) {\n      const match = /(\\[(.*)\\]|\\{(.*)\\})/.exec(part)\n      newString = newString.replace(\n        `-${match![2] || match![3]}-`,\n        `-${match![0]}-`\n      )\n    }\n  })\n\n  return newString\n}\n\nconst chunkNameCache = new Map()\nexport function generateComponentChunkName(componentPath: string): string {\n  if (chunkNameCache.has(componentPath)) {\n    return chunkNameCache.get(componentPath)\n  } else {\n    const { program } = store.getState()\n    const directory = program?.directory || `/`\n    const name = pathRelative(directory, componentPath)\n\n    const chunkName = `component---${replaceUnifiedRoutesKeys(\n      kebabCase(name),\n      name\n    )}`\n\n    chunkNameCache.set(componentPath, chunkName)\n\n    return chunkName\n  }\n}\n"],"file":"js-chunk-names.js"}
{"version":3,"sources":["../../../src/datastore/common/query.ts"],"names":["DbComparator","DB_COMPARATOR_VALUES","Set","Object","values","isDbComparator","value","has","createDbQueriesFromObject","filter","createDbQueriesFromObjectNested","path","keys","getOwnPropertyNames","_","flatMap","key","queries","map","query","type","nestedQuery","comparator","concat","dbQueryToDottedField","currentQuery","push","join","getFilterStatement","dbQuery","prefixResolvedFields","resolvedFields","dottedFields","objectToDottedField","dottedFieldKeys","forEach","prefixPath","some","dottedKey","startsWith","unshift","prepareQueryArgs","filterFields","filters","isPlainObject","Error","obj","result","pathResult","comparatorSpecificity","EQ","IN","GTE","LTE","GT","LT","NIN","NE","sortBySpecificity","all","sort","compareBySpecificityDesc","a","b","aComparator","bComparator","aSpecificity","bSpecificity"],"mappings":"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","sourcesContent":["import * as _ from \"lodash\"\nimport { prepareRegex } from \"../../utils/prepare-regex\"\nimport { makeRe } from \"micromatch\"\n\nexport interface IDbQueryQuery {\n  type: \"query\"\n  path: Array<string>\n  query: IDbFilterStatement\n}\n\nexport interface IDbQueryElemMatch {\n  type: \"elemMatch\"\n  path: Array<string>\n  nestedQuery: DbQuery\n}\n\nexport type DbQuery = IDbQueryQuery | IDbQueryElemMatch\n\nexport enum DbComparator {\n  EQ = `$eq`,\n  NE = `$ne`,\n  GT = `$gt`,\n  GTE = `$gte`,\n  LT = `$lt`,\n  LTE = `$lte`,\n  IN = `$in`,\n  NIN = `$nin`,\n  REGEX = `$regex`,\n  GLOB = `$glob`,\n}\n\nexport type FilterValueNullable =  // TODO: merge with DbComparatorValue\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | RegExp // Only valid for $regex\n  | Array<string | number | boolean | null | undefined>\n\n// This is filter value in most cases\nexport type FilterValue =\n  | string\n  | number\n  | boolean\n  | RegExp // Only valid for $regex\n  | Array<string | number | boolean>\n\n// The value is an object with arbitrary keys that are either filter values or,\n// recursively, an object with the same struct. Ie. `{a: {a: {a: 2}}}`\nexport interface IInputQuery {\n  [key: string]: FilterValueNullable | IInputQuery\n}\n// Similar to IInputQuery except the comparator leaf nodes will have their\n// key prefixed with `$` and their value, in some cases, normalized.\nexport interface IPreparedQueryArg {\n  [key: string]: FilterValueNullable | IPreparedQueryArg\n}\n\nconst DB_COMPARATOR_VALUES: Set<string> = new Set(Object.values(DbComparator))\n\nfunction isDbComparator(value: string): value is DbComparator {\n  return DB_COMPARATOR_VALUES.has(value)\n}\n\nexport type DbComparatorValue = string | number | boolean | RegExp | null\n\nexport interface IDbFilterStatement {\n  comparator: DbComparator\n  value: DbComparatorValue | Array<DbComparatorValue>\n}\n\n/**\n * Converts a nested mongo args object into array of DbQuery objects,\n * structured representation of each distinct path of the query. We convert\n * nested objects with multiple keys to separate instances.\n */\nexport function createDbQueriesFromObject(\n  filter: Record<string, any>\n): Array<DbQuery> {\n  return createDbQueriesFromObjectNested(filter)\n}\n\nfunction createDbQueriesFromObjectNested(\n  filter: Record<string, any>,\n  path: Array<string> = []\n): Array<DbQuery> {\n  const keys = Object.getOwnPropertyNames(filter)\n  return _.flatMap(keys, (key: string): Array<DbQuery> => {\n    if (key === `$elemMatch`) {\n      const queries = createDbQueriesFromObjectNested(filter[key])\n      return queries.map(query => {\n        return {\n          type: `elemMatch`,\n          path: path,\n          nestedQuery: query,\n        }\n      })\n    } else if (isDbComparator(key)) {\n      return [\n        {\n          type: `query`,\n          path,\n          query: {\n            comparator: key,\n            value: filter[key],\n          },\n        },\n      ]\n    } else {\n      return createDbQueriesFromObjectNested(filter[key], path.concat([key]))\n    }\n  })\n}\n\n/**\n * Takes a DbQuery structure and returns a dotted representation of a field referenced in this query.\n *\n * Example:\n * ```js\n *   const query = createDbQueriesFromObject({\n *     foo: { $elemMatch: { id: { $eq: 5 }, test: { $gt: 42 } } },\n *     bar: { $in: [`bar`] }\n *   })\n *   const result = query.map(dbQueryToDottedField)\n * ```\n * Returns:\n *   [`foo.id`, `foo.test`, `bar`]\n */\nexport function dbQueryToDottedField(query: DbQuery): string {\n  const path: Array<string> = [...query.path]\n  let currentQuery = query\n  while (currentQuery.type === `elemMatch`) {\n    currentQuery = currentQuery.nestedQuery\n    path.push(...currentQuery.path)\n  }\n  return path.join(`.`)\n}\n\nexport function getFilterStatement(dbQuery: DbQuery): IDbFilterStatement {\n  let currentQuery = dbQuery\n  while (currentQuery.type !== `query`) {\n    currentQuery = currentQuery.nestedQuery\n  }\n  return currentQuery.query\n}\n\nexport function prefixResolvedFields(\n  queries: Array<DbQuery>,\n  resolvedFields: Record<string, unknown>\n): Array<DbQuery> {\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.getOwnPropertyNames(dottedFields)\n  queries.forEach(query => {\n    const prefixPath = query.path.join(`.`)\n    if (\n      dottedFields[prefixPath] ||\n      (dottedFieldKeys.some(dottedKey => dottedKey.startsWith(prefixPath)) &&\n        query.type === `elemMatch`) ||\n      dottedFieldKeys.some(dottedKey => prefixPath.startsWith(dottedKey))\n    ) {\n      query.path.unshift(`__gatsby_resolved`)\n    }\n  })\n  return queries\n}\n\n/**\n * Transforms filters coming from input GraphQL query to mongodb-compatible format\n * (by prefixing comparators with \"$\").\n *\n * Example:\n *   { foo: { eq: 5 } } -> { foo: { $eq: 5 }}\n */\nexport function prepareQueryArgs(\n  filterFields: Array<IInputQuery> | IInputQuery = {}\n): IPreparedQueryArg {\n  const filters = {}\n  Object.keys(filterFields).forEach(key => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      filters[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(\n        value as IInputQuery\n      )\n    } else {\n      switch (key) {\n        case `regex`:\n          if (typeof value !== `string`) {\n            throw new Error(\n              `The $regex comparator is expecting the regex as a string, not an actual regex or anything else`\n            )\n          }\n          filters[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          filters[`$regex`] = makeRe(value)\n          break\n        default:\n          filters[`$${key}`] = value\n      }\n    }\n  })\n  return filters\n}\n\n// Converts a nested mongo args object into a dotted notation. acc\n// (accumulator) must be a reference to an empty object. The converted\n// fields will be added to it. E.g\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"\n//     },\n//     content: {\n//       $regex: new MiniMatch(v)\n//     }\n//   },\n//   id: {\n//     $regex: newMiniMatch(v)\n//   }\n// }\n//\n// After execution, acc would be:\n//\n// {\n//   \"internal.type\": {\n//     $eq: \"TestNode\"\n//   },\n//   \"internal.content\": {\n//     $regex: new MiniMatch(v)\n//   },\n//   \"id\": {\n//     $regex: // as above\n//   }\n// }\n\n// Like above, but doesn't handle $elemMatch\nexport function objectToDottedField(\n  obj: Record<string, unknown>,\n  path: Array<string> = []\n): Record<string, unknown> {\n  let result = {}\n  Object.keys(obj).forEach(key => {\n    const value = obj[key]\n    if (_.isPlainObject(value)) {\n      const pathResult = objectToDottedField(\n        value as Record<string, unknown>,\n        path.concat(key)\n      )\n      result = {\n        ...result,\n        ...pathResult,\n      }\n    } else {\n      result[path.concat(key).join(`.`)] = value\n    }\n  })\n  return result\n}\n\nconst comparatorSpecificity = {\n  [DbComparator.EQ]: 80,\n  [DbComparator.IN]: 70,\n  [DbComparator.GTE]: 60,\n  [DbComparator.LTE]: 50,\n  [DbComparator.GT]: 40,\n  [DbComparator.LT]: 30,\n  [DbComparator.NIN]: 20,\n  [DbComparator.NE]: 10,\n}\n\nexport function sortBySpecificity(all: Array<DbQuery>): Array<DbQuery> {\n  return [...all].sort(compareBySpecificityDesc)\n}\n\nfunction compareBySpecificityDesc(a: DbQuery, b: DbQuery): number {\n  const aComparator = getFilterStatement(a).comparator\n  const bComparator = getFilterStatement(b).comparator\n  if (aComparator === bComparator) {\n    return 0\n  }\n  const aSpecificity = comparatorSpecificity[aComparator]\n  const bSpecificity = comparatorSpecificity[bComparator]\n  if (!aSpecificity || !bSpecificity) {\n    throw new Error(\n      `Unexpected comparator pair: ${aComparator}, ${bComparator}`\n    )\n  }\n  return aSpecificity > bSpecificity ? -1 : 1\n}\n"],"file":"query.js"}
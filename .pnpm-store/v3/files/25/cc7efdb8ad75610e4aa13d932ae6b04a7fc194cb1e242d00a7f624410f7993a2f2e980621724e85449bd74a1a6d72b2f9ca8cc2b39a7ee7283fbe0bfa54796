{"version":3,"file":"rematch-immer.umd.js","sources":["../node_modules/immer/dist/immer.module.js","../node_modules/symbol-observable/es/index.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/redux/es/redux.js","../lib/index.js"],"sourcesContent":["var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) { cb(i, value[i], value); }\n  } else {\n    ownKeys(value).forEach(function (key) { return cb(key, value[key], value); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction deepFreeze(obj) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n  Object.freeze(obj);\n  if (Array.isArray(obj)) { obj.forEach(deepFreeze); }else { for (var key in obj) { deepFreeze(obj[key]); } }\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\n// but share them all instead\n\nvar descriptors = {};\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) { markChanged(state); }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nfunction willFinalize$1() {}\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\nvar objectTraps = {\n  get: get$1,\n\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) { return state; }\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createProxy$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n    if (isUnchanged) { return true; }\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  } else if (state.assigned[prop]) {\n    // if an originally not assigned property was deleted\n    delete state.assigned[prop];\n  }\n\n  if (state.copy) { delete state.copy[prop]; }\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n\n  return desc;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) { markChanged$1(state.parent); }\n  }\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n\n    var path = patch.path;\n    var op = patch.op;\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = base[path[i]];\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        // if value is an object, then it's assigned by reference\n        // in the following add or remove ops, the value field inside the patch will also be modifyed\n        // so we use value from the cloned patch\n        base[key] = value;\n        break;\n\n      case \"add\":\n        if (Array.isArray(base)) {\n          // TODO: support \"foo/-\" paths for appending to an array\n          base.splice(key, 0, value);\n        } else {\n          base[key] = value;\n        }\n\n        break;\n\n      case \"remove\":\n        if (Array.isArray(base)) {\n          base.splice(key, 1);\n        } else {\n          delete base[key];\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) { return undefined; }\n    if (result === undefined) { result = base; }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n\n        for (var prop in assigned) {\n          if (!assigned[prop]) { this.onDelete(state, prop); }\n        }\n      } else {\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === state.base[prop]) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze (value, deep) {\n    if ( deep === void 0 ) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    if (deep) { deepFreeze(value); }else { Object.freeze(value); }\n  }\n};\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","import $$observable from 'symbol-observable';\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),\n  REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) return false;\n\n  var proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    if (isDispatching) {\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.REPLACE });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && 'action \"' + String(actionType) + '\"' || 'an action';\n\n  return 'Given ' + actionDescription + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var store = createStore.apply(undefined, args);\n      var _dispatch = function dispatch() {\n        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(undefined, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning(\"You are currently using minified code outside of NODE_ENV === 'production'. \" + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar immer_1 = __importDefault(require(\"immer\"));\nvar redux_1 = require(\"redux\");\nfunction combineReducersWithImmer(reducers) {\n    var reducersWithImmer = {};\n    var _loop_1 = function (key) {\n        var reducerFn = reducers[key];\n        reducersWithImmer[key] = function (state, payload) {\n            return typeof state === 'object'\n                ? immer_1.default(state, function (draft) {\n                    var next = reducerFn(draft, payload);\n                    if (typeof next === 'object')\n                        return next;\n                })\n                : reducerFn(state, payload);\n        };\n    };\n    // reducer must return value because literal don't support immer\n    for (var _i = 0, _a = Object.keys(reducers); _i < _a.length; _i++) {\n        var key = _a[_i];\n        _loop_1(key);\n    }\n    return redux_1.combineReducers(reducersWithImmer);\n}\n// rematch plugin\nvar immerPlugin = function () { return ({\n    config: {\n        redux: {\n            combineReducers: combineReducersWithImmer,\n        },\n    },\n}); };\nexports.default = immerPlugin;\n//# sourceMappingURL=index.js.map"],"names":["obj","NOTHING","Symbol","DRAFTABLE","for","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","isPlainObject","constructor","assign","target","key","has","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","concat","shallowCopy","base","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","map","cloned","deepFreeze","isFrozen","freeze","ImmerScope","parent","this","drafts","canAutoFreeze","patches","revoke","draft","usePatches","patchListener","inversePatches","leave","current","enter","descriptors","createProxy","clonePotentialDraft","state","assertUnrevoked","peek","source","finalizing","prepareCopy","copy","set","assigned","modified","markChanged","proxyProperty","scope","finalized","revoke$1","revoked","push","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","keys","baseValue","undefined","state$1","descriptor","legacyProxy","willFinalize","result","isReplaced","markChangesRecursively","object","i$1","i$2","createProxy$1","ref","Proxy","revocable","arrayTraps","objectTraps","proxy","source$1","peek$1","isUnchanged","markChanged$1","deleteProperty","owner","setPrototypeOf","fn","arguments","apply","isNaN","parseInt","modernProxy","generatePatches","basePath","assign$1","delta","start","end","path","op","replaceCount","path$1","generateArrayPatches","assignedValue","origValue","generateObjectPatches","applyPatches","list","patch","join","splice","configDefaults","useProxies","autoFreeze","process","name","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","recipe","this$1","defaultBase","self","args","len","hasError","Promise","then","processResult","error","maybeFreeze","produceWithPatches","arg1","arg2","arg3","p","ip","createDraft","isManual","finishDraft","setAutoFreeze","baseDraft","finalize","finalizeTree","root","rootPath","needPatches","finalizeProperty","isDraftProp","deep","immer","applyPatches$1","observable","ponyfill","window","global","module","Function","ActionTypes","INIT","Math","random","toString","substring","split","REPLACE","_typeof","iterator","_extends","getUndefinedStateErrorMessage","action","actionType","type","String","bindActionCreator","actionCreator","dispatch","compose","_len","funcs","_key","arg","reduce","a","b","createStore","reducer","preloadedState","enhancer","_ref2","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","getState","subscribe","listener","isSubscribed","index","indexOf","listeners","replaceReducer","nextReducer","$$observable","_ref","outerSubscribe","observer","TypeError","observeState","next","unsubscribe","reducers","reducerKeys","finalReducers","finalReducerKeys","shapeAssertionError","assertReducerShape","e","hasChanged","nextState","_i","previousStateForKey","nextStateForKey","errorMessage","actionCreators","boundActionCreators","middlewares","_len2","_key2","store","_dispatch","middlewareAPI","chain","middleware","__importDefault","mod","__esModule","default","exports","immer_1","require$$0","combineReducersWithImmer","reducersWithImmer","_loop_1","reducerFn","payload","_a","redux_1","combineReducers","redux"],"mappings":"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"}
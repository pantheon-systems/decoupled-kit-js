{"version":3,"sources":["../../../../src/steps/source-nodes/update-nodes/content-update-interval.js"],"names":["checkForNodeUpdates","cache","emitter","store","dispatch","develop","pauseRefreshPolling","lastCompletedSourceTime","get","LAST_COMPLETED_SOURCE_TIME","since","data","actionMonitorActions","nodes","newActions","query","contentPollingQuery","variables","throwGqlErrors","throwFetchErrors","length","emit","webhookBody","refreshing","pluginName","set","Date","now","resumeRefreshPolling","refetcher","msRefetchInterval","helpers","reconnectionActivity","retryCount","refreshPollingIsPaused","getState","end","reporter","success","e","pluginOptions","debug","throwRefetchErrors","activityTimer","message","start","setStatus","retryTime","maxWait","waitFor","Promise","resolve","setTimeout","startedPolling","firstCompilationDone","startPollingForContentUpdates","process","env","WP_DISABLE_POLLING","ENABLE_GATSBY_REFRESH_ENDPOINT","verbose","gatsbyApi","nodeUpdateInterval","on","log","info"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMA,mBAAmB,GAAG,OAAO;AAAEC,EAAAA,KAAF;AAASC,EAAAA;AAAT,CAAP,KAA8B;AACxD;AACA;AACA;AACAC,iBAAMC,QAAN,CAAeC,OAAf,CAAuBC,mBAAvB,GAJwD,CAMxD;;;AACA,QAAMC,uBAAuB,GAAG,MAAMN,KAAK,CAACO,GAAN,CAAUC,qCAAV,CAAtC;AACA,QAAMC,KAAK,GAAGH,uBAAuB,GAAG,GAAxC,CARwD,CAUxD;;AACA,QAAM;AACJI,IAAAA,IAAI,EAAE;AACJC,MAAAA,oBAAoB,EAAE;AAAEC,QAAAA,KAAK,EAAEC;AAAT;AADlB;AADF,MAIF,MAAM,2BAAa;AACrBC,IAAAA,KAAK,EAAEC,mCADc;AAErBC,IAAAA,SAAS,EAAE;AACTP,MAAAA;AADS,KAFU;AAKrB;AACAQ,IAAAA,cAAc,EAAE,IANK;AAOrBC,IAAAA,gBAAgB,EAAE;AAPG,GAAb,CAJV;;AAcA,MAAIL,UAAU,CAACM,MAAf,EAAuB;AACrBlB,IAAAA,OAAO,CAACmB,IAAR,CAAc,kBAAd,EAAiC;AAC/BC,MAAAA,WAAW,EAAE;AACXZ,QAAAA,KADW;AAEXa,QAAAA,UAAU,EAAE;AAFD,OADkB;AAK/BC,MAAAA,UAAU,EAAG;AALkB,KAAjC;AAOD,GARD,MAQO;AACL;AACA,UAAMvB,KAAK,CAACwB,GAAN,CAAUhB,qCAAV,EAAsCiB,IAAI,CAACC,GAAL,EAAtC,CAAN;;AACAxB,mBAAMC,QAAN,CAAeC,OAAf,CAAuBuB,oBAAvB;AACD;AACF,CAtCD;;AAwCA,MAAMC,SAAS,GAAG,OAChBC,iBADgB,EAEhBC,OAFgB,EAGhB;AAAEC,EAAAA,oBAAoB,GAAG,IAAzB;AAA+BC,EAAAA,UAAU,GAAG;AAA5C,IAAkD,EAHlC,KAIb;AACH,MAAI;AACF,UAAM;AAAEC,MAAAA;AAAF,QAA6B/B,eAAMgC,QAAN,GAAiB9B,OAApD;;AAEA,QAAI,CAAC6B,sBAAL,EAA6B;AAC3B,YAAMlC,mBAAmB,CAAC+B,OAAD,CAAzB;AACD;;AAED,QAAIC,oBAAJ,EAA0B;AACxBA,MAAAA,oBAAoB,CAACI,GAArB;AACAL,MAAAA,OAAO,CAACM,QAAR,CAAiBC,OAAjB,CACE,wCACG,sCAAqCL,UAAW,IAC/CA,UAAU,KAAK,CAAf,GAAoB,KAApB,GAA4B,OAC7B,EAHH,CADF;AAQAD,MAAAA,oBAAoB,GAAG,IAAvB;AACAC,MAAAA,UAAU,GAAG,CAAb;AACD;AACF,GApBD,CAoBE,OAAOM,CAAP,EAAU;AAAA;;AACV,UAAM;AAAEC,MAAAA;AAAF,QAAoB,iCAA1B;;AACA,QAAIA,aAAJ,aAAIA,aAAJ,uCAAIA,aAAa,CAAEC,KAAnB,iDAAI,qBAAsBC,kBAA1B,EAA8C;AAC5C,YAAMH,CAAN;AACD;;AAED,QAAI,CAACP,oBAAL,EAA2B;AACzBA,MAAAA,oBAAoB,GAAGD,OAAO,CAACM,QAAR,CAAiBM,aAAjB,CACrB,wCAAkB,0BAAyBJ,CAAC,CAACK,OAAQ,GAArD,CADqB,CAAvB;AAGAZ,MAAAA,oBAAoB,CAACa,KAArB;AACAb,MAAAA,oBAAoB,CAACc,SAArB,CAAgC,aAAhC;AACD,KAND,MAMO;AACLb,MAAAA,UAAU;AACVD,MAAAA,oBAAoB,CAACc,SAArB,CAAgC,WAAUb,UAAW,QAArD;AACD,KAfS,CAiBV;;;AACA,UAAMc,SAAS,GAAGd,UAAU,GAAG,IAA/B,CAlBU,CAmBV;AACA;;AACA,UAAMe,OAAO,GAAG,KAAhB;AACA,UAAMC,OAAO,GAAGF,SAAS,IAAIC,OAAb,GAAuBA,OAAvB,GAAiCD,SAAjD;AAEA,UAAM,IAAIG,OAAJ,CAAYC,OAAO,IAAIC,UAAU,CAACD,OAAD,EAAUF,OAAV,CAAjC,CAAN;AACD;;AAEDG,EAAAA,UAAU,CACR,MACEvB,SAAS,CAACC,iBAAD,EAAoBC,OAApB,EAA6B;AACpCC,IAAAA,oBADoC;AAEpCC,IAAAA;AAFoC,GAA7B,CAFH,EAMRH,iBANQ,CAAV;AAQD,CA5DD;;AA8DA,IAAIuB,cAAc,GAAG,KAArB;AACA,IAAIC,oBAAoB,GAAG,KAA3B;AAEA;AACA;AACA;AACA;;AACA,MAAMC,6BAA6B,GAAGxB,OAAO,IAAI;AAC/C,MACEsB,cAAc,IACdG,OAAO,CAACC,GAAR,CAAYC,kBADZ,IAEAF,OAAO,CAACC,GAAR,CAAYE,8BAHd,EAIE;AACA;AACD;;AAEDN,EAAAA,cAAc,GAAG,IAAjB;;AAEA,QAAM;AAAEO,IAAAA,OAAF;AAAWvD,IAAAA;AAAX,MAAuBF,eAAMgC,QAAN,GAAiB0B,SAAjB,CAA2BrB,aAAxD;;AAEA,QAAMV,iBAAiB,GAAGzB,OAAO,CAACyD,kBAAlC;AAEA/B,EAAAA,OAAO,CAAC7B,OAAR,CAAgB6D,EAAhB,CAAoB,kBAApB,EAAuC,MAAM;AAC3C;AACJ;AACA;AACA;AACA;AACA;AACI,QAAI,CAACT,oBAAL,EAA2B;AACzBA,MAAAA,oBAAoB,GAAG,IAAvB,CADyB,CAGzB;;AACAF,MAAAA,UAAU,CAAC,MAAM;AACf,YAAIQ,OAAJ,EAAa;AACX7B,UAAAA,OAAO,CAACM,QAAR,CAAiB2B,GAAjB,CAAsB,EAAtB;AACAjC,UAAAA,OAAO,CAACM,QAAR,CAAiB4B,IAAjB,CACE,uCAAiB,gCADnB;AAGD;;AAEDpC,QAAAA,SAAS,CAACC,iBAAD,EAAoBC,OAApB,CAAT;AACD,OATS,EASP,IATO,CAAV;AAUD;AACF,GAtBD;AAuBD,CAtCD","sourcesContent":["import { formatLogMessage } from \"~/utils/format-log-message\"\nimport store from \"~/store\"\nimport { getGatsbyApi } from \"~/utils/get-gatsby-api\"\nimport { contentPollingQuery } from \"../../../utils/graphql-queries\"\nimport fetchGraphql from \"../../../utils/fetch-graphql\"\nimport { LAST_COMPLETED_SOURCE_TIME } from \"../../../constants\"\n\n/**\n * This function checks wether there is atleast 1 WPGatsby action ready to be processed by Gatsby\n * If there is, it calls the refresh webhook so that schema customization and source nodes run again.\n */\nconst checkForNodeUpdates = async ({ cache, emitter }) => {\n  // pause polling until we know wether or not there are new actions\n  // if there aren't any we will unpause below, if there are some we will unpause\n  // at the end of sourceNodes (triggered by WEBHOOK_RECEIVED below)\n  store.dispatch.develop.pauseRefreshPolling()\n\n  // get the last sourced time\n  const lastCompletedSourceTime = await cache.get(LAST_COMPLETED_SOURCE_TIME)\n  const since = lastCompletedSourceTime - 500\n\n  // make a graphql request for any actions that have happened since\n  const {\n    data: {\n      actionMonitorActions: { nodes: newActions },\n    },\n  } = await fetchGraphql({\n    query: contentPollingQuery,\n    variables: {\n      since,\n    },\n    // throw fetch errors and graphql errors so we can auto recover in refetcher()\n    throwGqlErrors: true,\n    throwFetchErrors: true,\n  })\n\n  if (newActions.length) {\n    emitter.emit(`WEBHOOK_RECEIVED`, {\n      webhookBody: {\n        since,\n        refreshing: true,\n      },\n      pluginName: `gatsby-source-wordpress`,\n    })\n  } else {\n    // set new last completed source time and move on\n    await cache.set(LAST_COMPLETED_SOURCE_TIME, Date.now())\n    store.dispatch.develop.resumeRefreshPolling()\n  }\n}\n\nconst refetcher = async (\n  msRefetchInterval,\n  helpers,\n  { reconnectionActivity = null, retryCount = 1 } = {}\n) => {\n  try {\n    const { refreshPollingIsPaused } = store.getState().develop\n\n    if (!refreshPollingIsPaused) {\n      await checkForNodeUpdates(helpers)\n    }\n\n    if (reconnectionActivity) {\n      reconnectionActivity.end()\n      helpers.reporter.success(\n        formatLogMessage(\n          `Content updates re-connected after ${retryCount} ${\n            retryCount === 1 ? `try` : `tries`\n          }`\n        )\n      )\n\n      reconnectionActivity = null\n      retryCount = 1\n    }\n  } catch (e) {\n    const { pluginOptions } = getGatsbyApi()\n    if (pluginOptions?.debug?.throwRefetchErrors) {\n      throw e\n    }\n\n    if (!reconnectionActivity) {\n      reconnectionActivity = helpers.reporter.activityTimer(\n        formatLogMessage(`Content update error: \"${e.message}\"`)\n      )\n      reconnectionActivity.start()\n      reconnectionActivity.setStatus(`retrying...`)\n    } else {\n      retryCount++\n      reconnectionActivity.setStatus(`retried ${retryCount} times`)\n    }\n\n    // retry after retry count times 5 seconds\n    const retryTime = retryCount * 5000\n    // if the retry time is greater than or equal to the max (60 seconds)\n    // use the max, otherwise use the retry time\n    const maxWait = 60000\n    const waitFor = retryTime >= maxWait ? maxWait : retryTime\n\n    await new Promise(resolve => setTimeout(resolve, waitFor))\n  }\n\n  setTimeout(\n    () =>\n      refetcher(msRefetchInterval, helpers, {\n        reconnectionActivity,\n        retryCount,\n      }),\n    msRefetchInterval\n  )\n}\n\nlet startedPolling = false\nlet firstCompilationDone = false\n\n/**\n * Starts constantly refetching the latest WordPress changes\n * so we can update Gatsby nodes when data changes\n */\nconst startPollingForContentUpdates = helpers => {\n  if (\n    startedPolling ||\n    process.env.WP_DISABLE_POLLING ||\n    process.env.ENABLE_GATSBY_REFRESH_ENDPOINT\n  ) {\n    return\n  }\n\n  startedPolling = true\n\n  const { verbose, develop } = store.getState().gatsbyApi.pluginOptions\n\n  const msRefetchInterval = develop.nodeUpdateInterval\n\n  helpers.emitter.on(`COMPILATION_DONE`, () => {\n    /**\n     * we only want to start our refetcher helper 1 time after the first COMPILATION_DONE event.\n     * This event happens when the dev server is ready. It also happens after saving a code change. We only want to run our code 1 time.\n     * onCreateDevServer (the node API we're hooking into) is called before the dev server is ready.\n     * Running our logic at that point is problematic because we could end up triggering the WEBHOOK_RECEIVED event before the dev server is ready and this can cause Gatsby to throw errors. So we're hooking into COMPILATION_DONE to avoid that problem.\n     */\n    if (!firstCompilationDone) {\n      firstCompilationDone = true\n\n      // wait a second so that terminal output is more smooth\n      setTimeout(() => {\n        if (verbose) {\n          helpers.reporter.log(``)\n          helpers.reporter.info(\n            formatLogMessage`Watching for WordPress changes`\n          )\n        }\n\n        refetcher(msRefetchInterval, helpers)\n      }, 1000)\n    }\n  })\n}\n\nexport { startPollingForContentUpdates }\n"],"file":"content-update-interval.js"}
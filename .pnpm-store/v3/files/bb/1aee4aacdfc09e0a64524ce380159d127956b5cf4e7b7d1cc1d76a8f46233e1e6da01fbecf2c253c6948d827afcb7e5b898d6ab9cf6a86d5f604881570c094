{"version":3,"sources":["../../../src/utils/webpack/bundle.ts"],"names":["build","webpackConfig","compiler","Promise","resolve","reject","run","err","stats","close","hasErrors","compilation","errors","watch","onWatch","watchOptions","watcher"],"mappings":";;;;;;;;AAAA;;AAEO,SAASA,KAAT,CAAeC,aAAf,EAGJ;AACD,QAAMC,QAAQ,GAAG,sBAAQD,aAAR,CAAjB;AAEA,SAAO,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCH,IAAAA,QAAQ,CAACI,GAAT,CAAa,CAACC,GAAD,EAAMC,KAAN,KAAgB;AAC3B;AACA,UAAID,GAAG,IAAI,CAACC,KAAZ,EAAmB;AACjB,eAAON,QAAQ,CAACO,KAAT,CAAe,MAAM;AAC1BJ,UAAAA,MAAM,CAACE,GAAD,CAAN;AACD,SAFM,CAAP;AAGD;;AAED,UAAIC,KAAK,CAACE,SAAN,EAAJ,EAAuB;AACrB,eAAOR,QAAQ,CAACO,KAAT,CAAe,MAAM;AAC1BJ,UAAAA,MAAM,CAACG,KAAK,CAACG,WAAN,CAAkBC,MAAnB,CAAN;AACD,SAFM,CAAP;AAGD;;AAED,aAAOR,OAAO,CAAC;AACbI,QAAAA,KADa;AAEbC,QAAAA,KAAK,EAAE,MACL,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KACVH,QAAQ,CAACO,KAAT,CAAeF,GAAG,IAAKA,GAAG,GAAGF,MAAM,CAACE,GAAD,CAAT,GAAiBH,OAAO,EAAlD,CADF;AAHW,OAAD,CAAd;AAOD,KArBD;AAsBD,GAvBM,CAAP;AAwBD;;AAEM,SAASS,KAAT,CACLZ,aADK,EAELa,OAFK,EAMLC,YAA8C,GAAG,EAN5C,EAUL;AACA,QAAMb,QAAQ,GAAG,sBAAQD,aAAR,CAAjB;AAEA,QAAMe,OAAO,GAAGd,QAAQ,CAACW,KAAT,CAAeE,YAAf,EAA6B,CAACR,GAAD,EAAMC,KAAN,KAAgB;AAC3D;AACAM,IAAAA,OAAO,CAACP,GAAD,EAAMC,KAAN,CAAP;AACD,GAHe,CAAhB;AAKA,SAAO;AACLQ,IAAAA,OADK;AAELP,IAAAA,KAAK,EAAE,MACL,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KACVW,OAAO,CAACP,KAAR,CAAcF,GAAG,IAAKA,GAAG,GAAGF,MAAM,CAACE,GAAD,CAAT,GAAiBH,OAAO,EAAjD,CADF;AAHG,GAAP;AAOD","sourcesContent":["import webpack from \"webpack\"\n\nexport function build(webpackConfig: webpack.Configuration): Promise<{\n  stats: webpack.Stats\n  close: () => Promise<void>\n}> {\n  const compiler = webpack(webpackConfig)\n\n  return new Promise((resolve, reject) => {\n    compiler.run((err, stats) => {\n      // stats can only be empty when an error occurs. Adding it to the if makes typescript happy.\n      if (err || !stats) {\n        return compiler.close(() => {\n          reject(err)\n        })\n      }\n\n      if (stats.hasErrors()) {\n        return compiler.close(() => {\n          reject(stats.compilation.errors)\n        })\n      }\n\n      return resolve({\n        stats,\n        close: (): Promise<void> =>\n          new Promise((resolve, reject) =>\n            compiler.close(err => (err ? reject(err) : resolve()))\n          ),\n      })\n    })\n  })\n}\n\nexport function watch(\n  webpackConfig: webpack.Configuration,\n  onWatch: (\n    err: Error | webpack.WebpackError | undefined,\n    stats: webpack.Stats | undefined\n  ) => void,\n  watchOptions: webpack.Watching[\"watchOptions\"] = {}\n): {\n  watcher: webpack.Watching\n  close: () => Promise<void>\n} {\n  const compiler = webpack(webpackConfig)\n\n  const watcher = compiler.watch(watchOptions, (err, stats) => {\n    // this runs multiple times\n    onWatch(err, stats)\n  })\n\n  return {\n    watcher,\n    close: (): Promise<void> =>\n      new Promise((resolve, reject) =>\n        watcher.close(err => (err ? reject(err) : resolve()))\n      ),\n  }\n}\n"],"file":"bundle.js"}
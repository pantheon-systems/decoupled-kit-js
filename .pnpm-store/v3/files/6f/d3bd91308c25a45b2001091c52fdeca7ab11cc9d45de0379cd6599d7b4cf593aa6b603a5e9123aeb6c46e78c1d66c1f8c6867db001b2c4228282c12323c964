"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSidebarItemsGenerator = exports.CategoryMetadataFilenamePattern = exports.CategoryMetadataFilenameBase = void 0;
const tslib_1 = require("tslib");
const lodash_1 = (0, tslib_1.__importDefault)(require("lodash"));
const utils_1 = require("@docusaurus/utils");
const logger_1 = (0, tslib_1.__importDefault)(require("@docusaurus/logger"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const docs_1 = require("../docs");
const BreadcrumbSeparator = '/';
// To avoid possible name clashes with a folder of the same name as the ID
const docIdPrefix = '$doc$/';
// Just an alias to the make code more explicit
function getLocalDocId(docId) {
    return lodash_1.default.last(docId.split('/'));
}
exports.CategoryMetadataFilenameBase = '_category_';
exports.CategoryMetadataFilenamePattern = '_category_.{json,yml,yaml}';
// Comment for this feature: https://github.com/facebook/docusaurus/issues/3464#issuecomment-818670449
const DefaultSidebarItemsGenerator = async ({ numberPrefixParser, isCategoryIndex, docs: allDocs, item: { dirName: autogenDir }, categoriesMetadata, }) => {
    const docsById = (0, docs_1.createDocsByIdIndex)(allDocs);
    const findDoc = (docId) => docsById[docId];
    const getDoc = (docId) => {
        const doc = findDoc(docId);
        if (!doc) {
            throw new Error(`Can't find any doc with id=${docId}.\nAvailable doc ids:\n- ${Object.keys(docsById).join('\n- ')}`);
        }
        return doc;
    };
    /**
     * Step 1. Extract the docs that are in the autogen dir.
     */
    function getAutogenDocs() {
        function isInAutogeneratedDir(doc) {
            return (
            // Doc at the root of the autogenerated sidebar dir
            doc.sourceDirName === autogenDir ||
                // autogen dir is . and doc is in subfolder
                autogenDir === '.' ||
                // autogen dir is not . and doc is in subfolder
                // "api/myDoc" startsWith "api/" (note "api2/myDoc" is not included)
                doc.sourceDirName.startsWith((0, utils_1.addTrailingSlash)(autogenDir)));
        }
        const docs = allDocs.filter(isInAutogeneratedDir);
        if (docs.length === 0) {
            logger_1.default.warn `No docs found in path=${autogenDir}: can't auto-generate a sidebar.`;
        }
        return docs;
    }
    /**
     * Step 2. Turn the linear file list into a tree structure.
     */
    function treeify(docs) {
        // Get the category breadcrumb of a doc (relative to the dir of the
        // autogenerated sidebar item)
        // autogenDir=a/b and docDir=a/b/c/d => returns [c, d]
        // autogenDir=a/b and docDir=a/b => returns []
        // TODO: try to use path.relative()
        function getRelativeBreadcrumb(doc) {
            return autogenDir === doc.sourceDirName
                ? []
                : doc.sourceDirName
                    .replace((0, utils_1.addTrailingSlash)(autogenDir), '')
                    .split(BreadcrumbSeparator);
        }
        const treeRoot = {};
        docs.forEach((doc) => {
            const breadcrumb = getRelativeBreadcrumb(doc);
            let currentDir = treeRoot; // We walk down the file's path to generate the fs structure
            breadcrumb.forEach((dir) => {
                if (typeof currentDir[dir] === 'undefined') {
                    currentDir[dir] = {}; // Create new folder.
                }
                currentDir = currentDir[dir]; // Go into the subdirectory.
            });
            currentDir[`${docIdPrefix}${doc.id}`] = null; // We've walked through the file path. Register the file in this directory.
        });
        return treeRoot;
    }
    /**
     * Step 3. Recursively transform the tree-like structure to sidebar items.
     * (From a record to an array of items, akin to normalizing shorthand)
     */
    function generateSidebar(fsModel) {
        function createDocItem(id) {
            const { sidebarPosition: position, frontMatter: { sidebar_label: label, sidebar_class_name: className }, } = getDoc(id);
            return {
                type: 'doc',
                id,
                position,
                // We don't want these fields to magically appear in the generated
                // sidebar
                ...(label !== undefined && { label }),
                ...(className !== undefined && { className }),
            };
        }
        async function createCategoryItem(dir, fullPath, folderName) {
            var _a, _b;
            const categoryMetadata = categoriesMetadata[(0, utils_1.posixPath)(path_1.default.join(autogenDir, fullPath))];
            const className = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.className;
            const { filename, numberPrefix } = numberPrefixParser(folderName);
            const allItems = await Promise.all(Object.entries(dir).map(([key, content]) => dirToItem(content, key, `${fullPath}/${key}`)));
            // Try to match a doc inside the category folder,
            // using the "local id" (myDoc) or "qualified id" (dirName/myDoc)
            function findDocByLocalId(localId) {
                return allItems.find((item) => item.type === 'doc' && getLocalDocId(item.id) === localId);
            }
            function findConventionalCategoryDocLink() {
                return allItems.find((item) => {
                    if (item.type !== 'doc') {
                        return false;
                    }
                    const doc = getDoc(item.id);
                    return isCategoryIndex((0, docs_1.toCategoryIndexMatcherParam)(doc));
                });
            }
            function getCategoryLinkedDocId() {
                var _a, _b;
                const link = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.link;
                if (link !== undefined) {
                    if (link && link.type === 'doc') {
                        return ((_a = findDocByLocalId(link.id)) === null || _a === void 0 ? void 0 : _a.id) || getDoc(link.id).id;
                    }
                    // If a link is explicitly specified, we won't apply conventions
                    return undefined;
                }
                // Apply default convention to pick index.md, README.md or
                // <categoryName>.md as the category doc
                return (_b = findConventionalCategoryDocLink()) === null || _b === void 0 ? void 0 : _b.id;
            }
            const categoryLinkedDocId = getCategoryLinkedDocId();
            const link = categoryLinkedDocId
                ? {
                    type: 'doc',
                    id: categoryLinkedDocId, // We "remap" a potentially "local id" to a "qualified id"
                }
                : categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.link;
            // If a doc is linked, remove it from the category subItems
            const items = allItems.filter((item) => !(item.type === 'doc' && item.id === categoryLinkedDocId));
            return {
                type: 'category',
                label: (_a = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.label) !== null && _a !== void 0 ? _a : filename,
                collapsible: categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.collapsible,
                collapsed: categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.collapsed,
                position: (_b = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.position) !== null && _b !== void 0 ? _b : numberPrefix,
                ...(className !== undefined && { className }),
                items,
                ...(link && { link }),
            };
        }
        async function dirToItem(dir, // The directory item to be transformed.
        itemKey, // For docs, it's the doc ID; for categories, it's used to generate the next `relativePath`.
        fullPath) {
            return dir
                ? createCategoryItem(dir, fullPath, itemKey)
                : createDocItem(itemKey.substring(docIdPrefix.length));
        }
        return Promise.all(Object.entries(fsModel).map(([key, content]) => dirToItem(content, key, key)));
    }
    /**
     * Step 4. Recursively sort the categories/docs + remove the "position"
     * attribute from final output. Note: the "position" is only used to sort
     * "inside" a sidebar slice. It is not used to sort across multiple
     * consecutive sidebar slices (i.e. a whole category composed of multiple
     * autogenerated items)
     */
    function sortItems(sidebarItems) {
        const processedSidebarItems = sidebarItems.map((item) => {
            if (item.type === 'category') {
                return { ...item, items: sortItems(item.items) };
            }
            return item;
        });
        const sortedSidebarItems = lodash_1.default.sortBy(processedSidebarItems, (item) => item.position);
        return sortedSidebarItems.map(({ position, ...item }) => item);
    }
    // TODO: the whole code is designed for pipeline operator
    const docs = getAutogenDocs();
    const fsModel = treeify(docs);
    const sidebarWithPosition = await generateSidebar(fsModel);
    const sortedSidebar = sortItems(sidebarWithPosition);
    return sortedSidebar;
};
exports.DefaultSidebarItemsGenerator = DefaultSidebarItemsGenerator;

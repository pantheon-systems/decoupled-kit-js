{"version":3,"sources":["../../src/utils/static-query-utils.ts"],"names":["join","path","posix","outputDir","process","cwd","getStaticQueryPath","hash","getStaticQueryResult","staticQueryPath","absoluteStaticQueryPath","staticQueryRaw","fs","readFile","JSON","parse","toString","staticQueryResultCache","Map","inFlightStaticQueryPromise","clearStaticQueryCaches","clear","getStaticQueryContext","staticQueryHashes","staticQueryResultPromises","staticQueryContext","staticQueryHash","memoizedStaticQueryResult","get","getStaticQueryPromise","set","then","delete","push","results","Promise","all","writeStaticQueryContext","templatePath","outputFilePath","stringifiedContext","stringify","outputFile"],"mappings":";;;;;;;;AAAA;;AACA;;;;;;AACA;AACA,MAAM;AAAEA,EAAAA;AAAF,IAAWC,IAAI,CAACC,KAAtB;AAIA,MAAMC,SAAS,GAAGF,IAAI,CAACD,IAAL,CAAUI,OAAO,CAACC,GAAR,EAAV,EAA0B,QAA1B,EAAoC,UAApC,CAAlB;;AAEO,MAAMC,kBAAkB,GAAIC,IAAD,IAChCP,IAAI,CAAE,WAAF,EAAe,IAAf,EAAqB,GAArB,EAA0B,GAAEO,IAAK,OAAjC,CADC;;;;AAGA,MAAMC,oBAAoB,GAAG,MAAOD,IAAP,IAAsC;AACxE,QAAME,eAAe,GAAGH,kBAAkB,CAACC,IAAD,CAA1C;AACA,QAAMG,uBAAuB,GAAGV,IAAI,CAACI,OAAO,CAACC,GAAR,EAAD,EAAiB,QAAjB,EAA0BI,eAA1B,CAApC;AACA,QAAME,cAAc,GAAG,MAAMC,iBAAGC,QAAH,CAAYH,uBAAZ,CAA7B;AAEA,SAAOI,IAAI,CAACC,KAAL,CAAWJ,cAAc,CAACK,QAAf,EAAX,CAAP;AACD,CANM;;;AAYP,MAAMC,sBAAsB,GAAG,IAAIC,GAAJ,EAA/B;AACA,MAAMC,0BAA0B,GAAG,IAAID,GAAJ,EAAnC;;AAEO,SAASE,sBAAT,GAAwC;AAC7CH,EAAAA,sBAAsB,CAACI,KAAvB;AACAF,EAAAA,0BAA0B,CAACE,KAA3B;AACD;;AAEM,MAAMC,qBAAqB,GAAG,MACnCC,iBADmC,IAI/B;AACJ,QAAMC,yBAA+C,GAAG,EAAxD;AACA,QAAMC,kBAA+D,GAAG,EAAxE;;AAEA,OAAK,MAAMC,eAAX,IAA8BH,iBAA9B,EAAiD;AAC/C,UAAMI,yBAAyB,GAC7BV,sBAAsB,CAACW,GAAvB,CAA2BF,eAA3B,CADF;;AAEA,QAAIC,yBAAJ,EAA+B;AAC7BF,MAAAA,kBAAkB,CAACC,eAAD,CAAlB,GAAsCC,yBAAtC;AACA;AACD;;AAED,QAAIE,qBAAqB,GAAGV,0BAA0B,CAACS,GAA3B,CAA+BF,eAA/B,CAA5B;;AACA,QAAI,CAACG,qBAAL,EAA4B;AAC1BA,MAAAA,qBAAqB,GAAGrB,oBAAoB,CAACkB,eAAD,CAA5C;AACAP,MAAAA,0BAA0B,CAACW,GAA3B,CAA+BJ,eAA/B,EAAgDG,qBAAhD;AACAA,MAAAA,qBAAqB,CAACE,IAAtB,CAA2B,MAAM;AAC/BZ,QAAAA,0BAA0B,CAACa,MAA3B,CAAkCN,eAAlC;AACD,OAFD;AAGD;;AAEDF,IAAAA,yBAAyB,CAACS,IAA1B,CACEJ,qBAAqB,CAACE,IAAtB,CAA2BG,OAAO,IAAI;AACpCT,MAAAA,kBAAkB,CAACC,eAAD,CAAlB,GAAsCQ,OAAtC;AACD,KAFD,CADF;AAKD;;AAED,QAAMC,OAAO,CAACC,GAAR,CAAYZ,yBAAZ,CAAN;AAEA,SAAO;AAAEC,IAAAA;AAAF,GAAP;AACD,CAnCM;;;;AAqCA,MAAMY,uBAAuB,GAAG,OACrCd,iBADqC,EAErCe,YAFqC,KAKjC;AACJ,QAAMC,cAAc,GAAGtC,IAAI,CAACD,IAAL,CACrBG,SADqB,EAEpB,YAFoB,EAGrBmC,YAHqB,EAIpB,iBAJoB,CAAvB;AAOA,QAAM;AAAEb,IAAAA;AAAF,MAAyB,MAAMH,qBAAqB,CAACC,iBAAD,CAA1D;AAEA,QAAMiB,kBAAkB,GAAG1B,IAAI,CAAC2B,SAAL,CAAehB,kBAAf,CAA3B;AACA,QAAMb,iBAAG8B,UAAH,CAAcH,cAAd,EAA8BC,kBAA9B,CAAN;AAEA,SAAO;AAAEf,IAAAA;AAAF,GAAP;AACD,CAnBM","sourcesContent":["import fs from \"fs-extra\"\nimport * as path from \"path\"\n// we want to force posix-style joins, so Windows doesn't produce backslashes for urls\nconst { join } = path.posix\nimport type { IScriptsAndStyles } from \"./client-assets-for-template\"\nimport { IPageDataWithQueryResult } from \"./page-data\"\n\nconst outputDir = path.join(process.cwd(), `.cache`, `page-ssr`)\n\nexport const getStaticQueryPath = (hash: string): string =>\n  join(`page-data`, `sq`, `d`, `${hash}.json`)\n\nexport const getStaticQueryResult = async (hash: string): Promise<any> => {\n  const staticQueryPath = getStaticQueryPath(hash)\n  const absoluteStaticQueryPath = join(process.cwd(), `public`, staticQueryPath)\n  const staticQueryRaw = await fs.readFile(absoluteStaticQueryPath)\n\n  return JSON.parse(staticQueryRaw.toString())\n}\n\nexport interface IResourcesForTemplate extends IScriptsAndStyles {\n  staticQueryContext: Record<string, { data: unknown }>\n}\n\nconst staticQueryResultCache = new Map<string, any>()\nconst inFlightStaticQueryPromise = new Map<string, Promise<any>>()\n\nexport function clearStaticQueryCaches(): void {\n  staticQueryResultCache.clear()\n  inFlightStaticQueryPromise.clear()\n}\n\nexport const getStaticQueryContext = async (\n  staticQueryHashes: IPageDataWithQueryResult[\"staticQueryHashes\"]\n): Promise<{\n  staticQueryContext: IResourcesForTemplate[\"staticQueryContext\"]\n}> => {\n  const staticQueryResultPromises: Array<Promise<void>> = []\n  const staticQueryContext: IResourcesForTemplate[\"staticQueryContext\"] = {}\n\n  for (const staticQueryHash of staticQueryHashes) {\n    const memoizedStaticQueryResult =\n      staticQueryResultCache.get(staticQueryHash)\n    if (memoizedStaticQueryResult) {\n      staticQueryContext[staticQueryHash] = memoizedStaticQueryResult\n      continue\n    }\n\n    let getStaticQueryPromise = inFlightStaticQueryPromise.get(staticQueryHash)\n    if (!getStaticQueryPromise) {\n      getStaticQueryPromise = getStaticQueryResult(staticQueryHash)\n      inFlightStaticQueryPromise.set(staticQueryHash, getStaticQueryPromise)\n      getStaticQueryPromise.then(() => {\n        inFlightStaticQueryPromise.delete(staticQueryHash)\n      })\n    }\n\n    staticQueryResultPromises.push(\n      getStaticQueryPromise.then(results => {\n        staticQueryContext[staticQueryHash] = results\n      })\n    )\n  }\n\n  await Promise.all(staticQueryResultPromises)\n\n  return { staticQueryContext }\n}\n\nexport const writeStaticQueryContext = async (\n  staticQueryHashes: IPageDataWithQueryResult[\"staticQueryHashes\"],\n  templatePath: string\n): Promise<{\n  staticQueryContext: IResourcesForTemplate[\"staticQueryContext\"]\n}> => {\n  const outputFilePath = path.join(\n    outputDir,\n    `sq-context`,\n    templatePath,\n    `sq-context.json`\n  )\n\n  const { staticQueryContext } = await getStaticQueryContext(staticQueryHashes)\n\n  const stringifiedContext = JSON.stringify(staticQueryContext)\n  await fs.outputFile(outputFilePath, stringifiedContext)\n\n  return { staticQueryContext }\n}\n"],"file":"static-query-utils.js"}
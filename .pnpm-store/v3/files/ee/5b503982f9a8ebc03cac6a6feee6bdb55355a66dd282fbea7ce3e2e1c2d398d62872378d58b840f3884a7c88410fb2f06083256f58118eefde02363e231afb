{"version":3,"sources":["../../../../src/datastore/lmdb/query/filter-using-index.ts"],"names":["BinaryInfinityNegative","Buffer","from","BinaryInfinityPositive","String","fromCharCode","repeat","ValueEdges","filterUsingIndex","args","context","createFilteringContext","ranges","getIndexRanges","entries","length","performRangeScan","performFullScan","usedQueries","size","dbQueries","narrowResultsIfPossible","isMultiKeyIndex","needsDeduplication","deduplicate","getIdentifier","usedLimit","usedSkip","countUsingIndexOnly","databases","indexes","indexMetadata","keyPrefix","Error","range","start","end","getValueEdgeAfter","snapshot","getKeysCount","count","undefined","Set","multiKeyFields","fieldsWithAppliedEq","forEach","q","filter","comparator","DbComparator","EQ","add","some","fieldName","has","stats","reverse","limit","skip","offset","maxKeysPerItem","lmdbRanges","push","GatsbyIterable","traverseRanges","undefinedSymbol","undefinedToEnd","topToUndefined","getRange","indexFields","Map","keyFields","positionInKey","set","filtersToApply","query","get","isNegatedQuery","key","fieldPositionInIndex","value","getSupportedQueries","isSupported","IN","GTE","LTE","GT","LT","NIN","NE","supportedQueries","isEqualityQuery","rangeStarts","rangeEndings","indexFieldInfo","getMostSpecificQuery","result","resolveIndexFieldRanges","i","rangeStartsProduct","rangeEndingsProduct","getFieldQueries","queries","indexField","fieldQueries","field","sortDirection","Array","isArray","arr","sort","a","b","hasNull","item","toIndexFieldValue","resolveRangeEdge","AFTER","rangeHead","rangeTail","predicate","edge","dbQuery","filterStatement","getValueEdgeBefore","filterValue","entry","id","out"],"mappings":"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","sourcesContent":["import { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  DbComparator,\n  DbComparatorValue,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  sortBySpecificity,\n} from \"../../common/query\"\nimport { IDataStore, ILmdbDatabases, NodeId } from \"../../types\"\nimport {\n  IIndexMetadata,\n  IndexFieldValue,\n  IndexKey,\n  undefinedSymbol,\n} from \"./create-index\"\nimport { cartesianProduct, matchesFilter } from \"./common\"\nimport { inspect } from \"util\"\n\n// JS values encoded by ordered-binary never start with 0 or 255 byte\nexport const BinaryInfinityNegative = Buffer.from([0])\nexport const BinaryInfinityPositive = String.fromCharCode(255).repeat(4)\n\ntype RangeEdgeAfter = [IndexFieldValue, typeof BinaryInfinityPositive]\ntype RangeEdgeBefore = [typeof undefinedSymbol, IndexFieldValue]\ntype RangeValue =\n  | IndexFieldValue\n  | RangeEdgeAfter\n  | RangeEdgeBefore\n  | typeof BinaryInfinityPositive\n  | typeof BinaryInfinityNegative\ntype RangeBoundary = Array<RangeValue>\n\nexport interface IIndexEntry {\n  key: IndexKey\n  value: NodeId\n}\n\ninterface IIndexRange {\n  start: RangeBoundary\n  end: RangeBoundary\n}\n\nenum ValueEdges {\n  BEFORE = -1,\n  EQ = 0,\n  AFTER = 1,\n}\n\nexport interface IFilterArgs {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  indexMetadata: IIndexMetadata\n  limit?: number\n  skip?: number\n  reverse?: boolean\n}\n\ninterface IFilterContext extends IFilterArgs {\n  usedLimit: number | undefined\n  usedSkip: number\n  usedQueries: Set<DbQuery>\n}\n\nexport interface IFilterResult {\n  entries: GatsbyIterable<IIndexEntry>\n  usedQueries: Set<DbQuery>\n  usedLimit: number | undefined\n  usedSkip: number\n}\n\ninterface ILmdbStoreRangeOptions {\n  start?: any\n  end?: any\n  limit?: number | undefined\n  offset?: number | undefined\n  revers?: boolean\n  snapshot?: boolean\n}\n\nexport function filterUsingIndex(args: IFilterArgs): IFilterResult {\n  const context = createFilteringContext(args)\n  const ranges = getIndexRanges(context)\n\n  let entries =\n    ranges.length > 0\n      ? performRangeScan(context, ranges)\n      : performFullScan(context)\n\n  if (context.usedQueries.size !== args.dbQueries.length) {\n    // Try to additionally filter out results using data stored in index\n    entries = narrowResultsIfPossible(context, entries)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    entries = entries.deduplicate(getIdentifier)\n  }\n  return {\n    entries,\n    usedQueries: context.usedQueries,\n    usedLimit: context.usedLimit,\n    usedSkip: context.usedSkip,\n  }\n}\n\nexport function countUsingIndexOnly(args: IFilterArgs): number {\n  const context = createFilteringContext(args)\n  const {\n    databases: { indexes },\n    dbQueries,\n    indexMetadata: { keyPrefix },\n  } = args\n\n  const ranges = getIndexRanges(context)\n\n  if (context.usedQueries.size !== dbQueries.length) {\n    throw new Error(`Cannot count using index only`)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    throw new Error(`Cannot count using MultiKey index.`)\n  }\n  if (ranges.length === 0) {\n    const range: ILmdbStoreRangeOptions = {\n      start: [keyPrefix],\n      end: [getValueEdgeAfter(keyPrefix)],\n      snapshot: false,\n    }\n    return indexes.getKeysCount(range)\n  }\n  let count = 0\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    // Assuming ranges are not overlapping\n    const range: ILmdbStoreRangeOptions = { start, end, snapshot: false }\n    count += indexes.getKeysCount(range)\n  }\n  return count\n}\n\nfunction createFilteringContext(args: IFilterArgs): IFilterContext {\n  return {\n    ...args,\n    usedLimit: undefined,\n    usedSkip: 0,\n    usedQueries: new Set<DbQuery>(),\n  }\n}\n\nfunction isMultiKeyIndex(context: IFilterContext): boolean {\n  return context.indexMetadata.multiKeyFields.length > 0\n}\n\nfunction needsDeduplication(context: IFilterContext): boolean {\n  if (!isMultiKeyIndex(context)) {\n    return false\n  }\n  // Deduplication is not needed if all multiKeyFields have applied `eq` filters\n  const fieldsWithAppliedEq = new Set<string>()\n  context.usedQueries.forEach(q => {\n    const filter = getFilterStatement(q)\n    if (filter.comparator === DbComparator.EQ) {\n      fieldsWithAppliedEq.add(dbQueryToDottedField(q))\n    }\n  })\n  return context.indexMetadata.multiKeyFields.some(\n    fieldName => !fieldsWithAppliedEq.has(fieldName)\n  )\n}\n\nfunction performRangeScan(\n  context: IFilterContext,\n  ranges: Array<IIndexRange>\n): GatsbyIterable<IIndexEntry> {\n  const {\n    indexMetadata: { keyPrefix, stats },\n    reverse,\n  } = context\n\n  let { limit, skip: offset = 0 } = context\n\n  if (context.dbQueries.length !== context.usedQueries.size) {\n    // Since this query is not fully satisfied by the index, we can't use limit/skip\n    limit = undefined\n    offset = 0\n  }\n  if (ranges.length > 1) {\n    // e.g. { in: [1, 2] }\n    // Cannot use offset: we will run several range queries and it's not clear which one to offset\n    // TODO: assuming ranges are sorted and not overlapping it should be possible to use offsets in this case\n    //   by running first range query, counting results while lazily iterating and\n    //   running the next range query when the previous iterator is done (and count is known)\n    //   with offset = offset - previousRangeCount, limit = limit - previousRangeCount\n    limit = typeof limit !== `undefined` ? offset + limit : undefined\n    offset = 0\n  }\n  if (limit && isMultiKeyIndex(context) && needsDeduplication(context)) {\n    // Cannot use limit:\n    // MultiKey index may contain duplicates - we can only set a safe upper bound\n    limit *= stats.maxKeysPerItem\n  }\n\n  // Assuming ranges are sorted and not overlapping, we can yield results sequentially\n  const lmdbRanges: Array<ILmdbStoreRangeOptions> = []\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    const range = !reverse\n      ? { start, end, limit, offset, snapshot: false }\n      : { start: end, end: start, limit, offset, reverse, snapshot: false }\n\n    lmdbRanges.push(range)\n  }\n  context.usedLimit = limit\n  context.usedSkip = offset\n  return new GatsbyIterable(() => traverseRanges(context, lmdbRanges))\n}\n\nfunction performFullScan(context: IFilterContext): GatsbyIterable<IIndexEntry> {\n  // *Caveat*: our old query implementation was putting undefined and null values at the end\n  //   of the list when ordered ascending. But lmdb-store keeps them at the top.\n  //   So in LMDB case, need to concat two ranges to conform to our old format:\n  //     concat(undefinedToEnd, topToUndefined)\n  const {\n    reverse,\n    indexMetadata: { keyPrefix },\n  } = context\n\n  let start: RangeBoundary = [keyPrefix, getValueEdgeAfter(undefinedSymbol)]\n  let end: RangeBoundary = [getValueEdgeAfter(keyPrefix)]\n  let range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const undefinedToEnd = range\n\n  // Concat null/undefined values\n  end = start\n  start = [keyPrefix, null]\n  range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const topToUndefined = range\n\n  const ranges: Array<ILmdbStoreRangeOptions> = !reverse\n    ? [undefinedToEnd, topToUndefined]\n    : [topToUndefined, undefinedToEnd]\n\n  return new GatsbyIterable(() => traverseRanges(context, ranges))\n}\n\nfunction* traverseRanges(\n  context: IFilterContext,\n  ranges: Array<ILmdbStoreRangeOptions>\n): Generator<IIndexEntry> {\n  const {\n    databases: { indexes },\n  } = context\n\n  for (const range of ranges) {\n    // @ts-ignore\n    yield* indexes.getRange(range)\n  }\n}\n\n/**\n * Takes results after the index scan and tries to filter them additionally with unused parts of the query.\n *\n * This is O(N) but the advantage is that it uses data available in the index.\n * So it effectively bypasses the `getNode()` call for such filters (with all associated deserialization complexity).\n *\n * Example:\n *   Imagine the index is: { foo: 1, bar: 1 }\n *\n * Now we run the query:\n *   sort: [`foo`]\n *   filter: { bar: { eq: `test` }}\n *\n * Initial filtering pass will have to perform a full index scan (because `bar` is the last field in the index).\n *\n * But we still have values of `bar` stored in the index itself,\n * so can filter by this value without loading the full node contents.\n */\nfunction narrowResultsIfPossible(\n  context: IFilterContext,\n  entries: GatsbyIterable<IIndexEntry>\n): GatsbyIterable<IIndexEntry> {\n  const { indexMetadata, dbQueries, usedQueries } = context\n\n  const indexFields = new Map<string, number>()\n  indexMetadata.keyFields.forEach(([fieldName], positionInKey) => {\n    // Every index key is [indexId, field1, field2, ...] and `indexMetadata.keyFields` contains [field1, field2, ...]\n    // As `indexId` is in the first column the fields need to be offset by +1 for correct addressing\n    indexFields.set(fieldName, positionInKey + 1)\n  })\n\n  type Filter = [filter: IDbFilterStatement, fieldPositionInIndex: number]\n  const filtersToApply: Array<Filter> = []\n\n  for (const query of dbQueries) {\n    const fieldName = dbQueryToDottedField(query)\n    const positionInKey = indexFields.get(fieldName)\n\n    if (typeof positionInKey === `undefined`) {\n      // No data for this field in index\n      continue\n    }\n    if (usedQueries.has(query)) {\n      // Filter is already applied\n      continue\n    }\n    if (isMultiKeyIndex(context) && isNegatedQuery(query)) {\n      // NE/NIN not supported with MultiKey indexes:\n      //   MultiKey indexes include duplicates; negated queries will only filter some of those\n      //   but may still incorrectly include others in final results\n      continue\n    }\n    const filter = getFilterStatement(query)\n    filtersToApply.push([filter, positionInKey])\n    usedQueries.add(query)\n  }\n\n  return filtersToApply.length === 0\n    ? entries\n    : entries.filter(({ key }) => {\n        for (const [filter, fieldPositionInIndex] of filtersToApply) {\n          const value =\n            key[fieldPositionInIndex] === undefinedSymbol\n              ? undefined\n              : key[fieldPositionInIndex]\n\n          if (!matchesFilter(filter, value)) {\n            // Mimic AND semantics\n            return false\n          }\n        }\n        return true\n      })\n}\n\n/**\n * Returns query clauses that can potentially use index.\n * Returned list is sorted by query specificity\n */\nfunction getSupportedQueries(\n  context: IFilterContext,\n  dbQueries: Array<DbQuery>\n): Array<DbQuery> {\n  const isSupported = new Set([\n    DbComparator.EQ,\n    DbComparator.IN,\n    DbComparator.GTE,\n    DbComparator.LTE,\n    DbComparator.GT,\n    DbComparator.LT,\n    DbComparator.NIN,\n    DbComparator.NE,\n  ])\n  let supportedQueries = dbQueries.filter(query =>\n    isSupported.has(getFilterStatement(query).comparator)\n  )\n  if (isMultiKeyIndex(context)) {\n    // Note:\n    // NE and NIN are not supported by multi-key indexes. Why?\n    //   Imagine a node { id: 1, field: [`foo`, `bar`] }\n    //   Then the filter { field: { ne: `foo` } } should completely remove this node from results.\n    //   But multikey index contains separate entries for `foo` and `bar` values.\n    //   Final range will exclude entry \"foo\" but it will still include entry for \"bar\" hence\n    //   will incorrectly include our node in results.\n    supportedQueries = supportedQueries.filter(query => !isNegatedQuery(query))\n  }\n  return sortBySpecificity(supportedQueries)\n}\n\nfunction isEqualityQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.EQ ||\n    filter.comparator === DbComparator.IN\n  )\n}\n\nfunction isNegatedQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.NE ||\n    filter.comparator === DbComparator.NIN\n  )\n}\n\nexport function getIndexRanges(context: IFilterContext): Array<IIndexRange> {\n  const {\n    dbQueries,\n    indexMetadata: { keyFields },\n  } = context\n  const rangeStarts: Array<RangeBoundary> = []\n  const rangeEndings: Array<RangeBoundary> = []\n  const supportedQueries = getSupportedQueries(context, dbQueries)\n\n  for (const indexFieldInfo of new Map(keyFields)) {\n    const query = getMostSpecificQuery(supportedQueries, indexFieldInfo)\n    if (!query) {\n      // Use index prefix, not all index fields\n      break\n    }\n    const result = resolveIndexFieldRanges(context, query, indexFieldInfo)\n    rangeStarts.push(result.rangeStarts)\n    rangeEndings.push(result.rangeEndings)\n\n    if (!isEqualityQuery(query)) {\n      // Compound index { a: 1, b: 1, c: 1 } supports only one non-eq (range) operator. E.g.:\n      //  Supported: { a: { eq: `foo` }, b: { eq: 8 }, c: { gt: 5 } }\n      //  Not supported: { a: { eq: `foo` }, b: { gt: 5 }, c: { eq: 5 } }\n      //  (or to be precise, can do a range scan only for { a: { eq: `foo` }, b: { gt: 5 } })\n      break\n    }\n  }\n  if (!rangeStarts.length) {\n    return []\n  }\n  // Only the last segment encloses the whole range.\n  // For example, given an index { a: 1, b: 1 } and a filter { a: { eq: `foo` }, b: { eq: `bar` } },\n  // It should produce this range:\n  // {\n  //   start: [`foo`, `bar`],\n  //   end: [`foo`, [`bar`, BinaryInfinityPositive]]\n  // }\n  //\n  // Not this:\n  // {\n  //   start: [`foo`, `bar`],\n  //   end: [[`foo`, BinaryInfinityPositive], [`bar`, BinaryInfinityPositive]]\n  // }\n  for (let i = 0; i < rangeStarts.length - 1; i++) {\n    rangeEndings[i] = rangeStarts[i]\n  }\n\n  // Example:\n  //   rangeStarts: [\n  //     [field1Start1, field1Start2],\n  //     [field2Start1],\n  //   ]\n  //   rangeEnds: [\n  //     [field1End1, field1End2],\n  //     [field2End1],\n  //   ]\n  // Need:\n  //   rangeStartsProduct: [\n  //     [field1Start1, field2Start1],\n  //     [field1Start2, field2Start1],\n  //   ]\n  //   rangeEndingsProduct: [\n  //     [field1End1, field2End1],\n  //     [field1End2, field2End1],\n  //   ]\n  const rangeStartsProduct = cartesianProduct(...rangeStarts)\n  const rangeEndingsProduct = cartesianProduct(...rangeEndings)\n\n  const ranges: Array<IIndexRange> = []\n  for (let i = 0; i < rangeStartsProduct.length; i++) {\n    ranges.push({\n      start: rangeStartsProduct[i],\n      end: rangeEndingsProduct[i],\n    })\n  }\n  // TODO: sort and intersect ranges. Also, we may want this at some point:\n  //   https://docs.mongodb.com/manual/core/multikey-index-bounds/\n  return ranges\n}\n\nfunction getFieldQueries(\n  queries: Array<DbQuery>,\n  fieldName: string\n): Array<DbQuery> {\n  return queries.filter(q => dbQueryToDottedField(q) === fieldName)\n}\n\nfunction getMostSpecificQuery(\n  queries: Array<DbQuery>,\n  [indexField]: [fieldName: string, sortDirection: number]\n): DbQuery | undefined {\n  const fieldQueries = getFieldQueries(queries, indexField)\n  // Assuming queries are sorted by specificity, the best bet is to pick the first query\n  return fieldQueries[0]\n}\n\nfunction resolveIndexFieldRanges(\n  context: IFilterContext,\n  query: DbQuery,\n  [field, sortDirection]: [fieldName: string, sortDirection: number]\n): {\n  rangeStarts: RangeBoundary\n  rangeEndings: RangeBoundary\n} {\n  // Tracking starts and ends separately instead of doing Array<[start, end]>\n  //  to simplify cartesian product creation later\n  const rangeStarts: RangeBoundary = []\n  const rangeEndings: RangeBoundary = []\n\n  const filter = getFilterStatement(query)\n\n  if (filter.comparator === DbComparator.IN && !Array.isArray(filter.value)) {\n    throw new Error(\"The argument to the `in` predicate should be an array\")\n  }\n\n  context.usedQueries.add(query)\n\n  switch (filter.comparator) {\n    case DbComparator.EQ:\n    case DbComparator.IN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n\n      let hasNull = false\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) hasNull = true\n        rangeStarts.push(value)\n        rangeEndings.push(getValueEdgeAfter(value))\n      }\n      // Special case: { eq: null } or { in: [null, `any`]} must also include values for undefined!\n      if (hasNull) {\n        rangeStarts.push(undefinedSymbol)\n        rangeEndings.push(getValueEdgeAfter(undefinedSymbol))\n      }\n      break\n    }\n    case DbComparator.LT:\n    case DbComparator.LTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const end =\n        filter.comparator === DbComparator.LT ? value : getValueEdgeAfter(value)\n\n      // Try to find matching GTE/GT filter\n      const start =\n        resolveRangeEdge(context, field, DbComparator.GTE) ??\n        resolveRangeEdge(context, field, DbComparator.GT, ValueEdges.AFTER)\n\n      // Do not include null or undefined in results unless null was requested explicitly\n      //\n      // Index ordering:\n      //  BinaryInfinityNegative\n      //  null\n      //  Symbol(`undef`)\n      //  -10\n      //  10\n      //  `Hello`\n      //  [`Hello`]\n      //  BinaryInfinityPositive\n      const rangeHead =\n        value === null\n          ? BinaryInfinityNegative\n          : getValueEdgeAfter(undefinedSymbol)\n\n      rangeStarts.push(start ?? rangeHead)\n      rangeEndings.push(end)\n      break\n    }\n    case DbComparator.GT:\n    case DbComparator.GTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const start =\n        filter.comparator === DbComparator.GTE\n          ? value\n          : getValueEdgeAfter(value)\n\n      // Try to find matching LT/LTE\n      const end =\n        resolveRangeEdge(context, field, DbComparator.LTE, ValueEdges.AFTER) ??\n        resolveRangeEdge(context, field, DbComparator.LT)\n\n      const rangeTail =\n        value === null ? getValueEdgeAfter(null) : BinaryInfinityPositive\n\n      rangeStarts.push(start)\n      rangeEndings.push(end ?? rangeTail)\n      break\n    }\n    case DbComparator.NE:\n    case DbComparator.NIN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n      const hasNull = arr.some(value => value === null)\n\n      if (hasNull) {\n        rangeStarts.push(getValueEdgeAfter(undefinedSymbol))\n      } else {\n        rangeStarts.push(BinaryInfinityNegative)\n      }\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) continue // already handled via hasNull case above\n        rangeEndings.push(value)\n        rangeStarts.push(getValueEdgeAfter(value))\n      }\n      rangeEndings.push(BinaryInfinityPositive)\n      break\n    }\n    default:\n      throw new Error(`Unsupported predicate: ${filter.comparator}`)\n  }\n  return { rangeStarts, rangeEndings }\n}\n\nfunction resolveRangeEdge(\n  context: IFilterContext,\n  indexField: string,\n  predicate: DbComparator,\n  edge: ValueEdges = ValueEdges.EQ\n): IndexFieldValue | RangeEdgeBefore | RangeEdgeAfter | undefined {\n  const fieldQueries = getFieldQueries(context.dbQueries, indexField)\n  for (const dbQuery of fieldQueries) {\n    if (context.usedQueries.has(dbQuery)) {\n      continue\n    }\n    const filterStatement = getFilterStatement(dbQuery)\n    if (filterStatement.comparator !== predicate) {\n      continue\n    }\n    context.usedQueries.add(dbQuery)\n    const value = filterStatement.value\n    if (Array.isArray(value)) {\n      throw new Error(`Range filter ${predicate} should not have array value`)\n    }\n    if (typeof value === `object` && value !== null) {\n      throw new Error(\n        `Range filter ${predicate} should not have value of type ${typeof value}`\n      )\n    }\n    if (edge === 0) {\n      return value\n    }\n    return edge < 0 ? getValueEdgeBefore(value) : getValueEdgeAfter(value)\n  }\n  return undefined\n}\n\n/**\n * Returns the edge after the given value, suitable for lmdb range queries.\n *\n * Example:\n * Get all items from index starting with [\"foo\"] prefix up to the next existing prefix:\n *\n * ```js\n *   db.getRange({ start: [\"foo\"], end: [getValueEdgeAfter(\"foo\")] })\n * ```\n *\n * This method relies on ordered-binary format used by lmdb-store to persist keys\n * and assumes keys are composite and represented as arrays.\n *\n * Implementation detail: ordered-binary treats `null` as multipart separator within binary sequence\n */\nfunction getValueEdgeAfter(value: IndexFieldValue): RangeEdgeAfter {\n  return [value, BinaryInfinityPositive]\n}\nfunction getValueEdgeBefore(value: IndexFieldValue): RangeEdgeBefore {\n  return [undefinedSymbol, value]\n}\n\nfunction toIndexFieldValue(\n  filterValue: DbComparatorValue,\n  filter: IDbFilterStatement\n): IndexFieldValue {\n  if (typeof filterValue === `object` && filterValue !== null) {\n    throw new Error(\n      `Bad filter value for predicate ${filter.comparator}: ${inspect(\n        filter.value\n      )}`\n    )\n  }\n  return filterValue\n}\n\nfunction getIdentifier(entry: IIndexEntry): number | string {\n  const id = entry.key[entry.key.length - 1]\n  if (typeof id !== `number` && typeof id !== `string`) {\n    const out = inspect(id)\n    throw new Error(\n      `Last element of index key is expected to be numeric or string id, got ${out}`\n    )\n  }\n  return id\n}\n"],"file":"filter-using-index.js"}
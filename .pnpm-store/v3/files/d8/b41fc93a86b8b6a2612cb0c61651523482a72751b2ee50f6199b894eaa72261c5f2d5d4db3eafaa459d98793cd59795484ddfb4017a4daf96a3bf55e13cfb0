{"version":3,"sources":["../../../src/utils/jobs/manager.ts"],"names":["activityForJobs","activeJobs","isListeningForMessages","hasShownIPCDisabledWarning","jobsInProcess","Map","externalJobsMap","convertPathsToAbsolute","filePath","path","isAbsolute","Error","createFileHash","hasha","fromFileSync","algorithm","hasActiveJobs","hasExternalJobsEnabled","process","env","ENABLE_GATSBY_EXTERNAL_JOBS","runLocalWorker","workerFn","job","fs","ensureDir","outputDir","Promise","resolve","reject","setImmediate","inputPaths","args","err","WorkerError","isJobsIPCMessage","msg","type","payload","id","has","listenForJobMessages","on","deferred","get","MESSAGE_TYPES","JOB_COMPLETED","result","JOB_FAILED","error","JOB_NOT_WHITELISTED","runJob","delete","runExternalWorker","set","jobCreatedMessage","JOB_CREATED","send","promise","forceLocal","plugin","worker","name","isLocal","reporter","warn","version","isInternalJob","undefined","contentDigest","createInternalJob","inputPathsWithContentDigest","map","pth","internalJob","uuid","v4","includes","inputPath","activitiesForJobTypes","enqueueJob","phantomActivity","start","jobType","activityForJobsProgress","createProgress","total","_","isPlainObject","end","tick","getInProcessJobPromise","removeInProgressJob","waitUntilAllJobsComplete","progressActivity","values","clear","waitJobs","jobDigests","promises","digest","push","all","isJobStale","areInputPathsStale","some","existsSync","fileHash"],"mappings":"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","sourcesContent":["import path from \"path\"\nimport hasha from \"hasha\"\nimport fs from \"fs-extra\"\nimport pDefer from \"p-defer\"\nimport _ from \"lodash\"\nimport { createContentDigest, slash, uuid } from \"gatsby-core-utils\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { IPhantomReporter } from \"gatsby-cli\"\nimport {\n  JobInput,\n  InternalJob,\n  MESSAGE_TYPES,\n  IJobCreatedMessage,\n  IJobCompletedMessage,\n  IJobFailed,\n  IJobNotWhitelisted,\n  WorkerError,\n} from \"./types\"\nimport { requireGatsbyPlugin } from \"../require-gatsby-plugin\"\n\ntype IncomingMessages = IJobCompletedMessage | IJobFailed | IJobNotWhitelisted\n\ntype OutgoingMessages = IJobCreatedMessage\n\nexport { InternalJob }\nexport type JobResultInterface = Record<string, unknown>\n\nlet activityForJobs: IPhantomReporter | null = null\nlet activeJobs = 0\nlet isListeningForMessages = false\nlet hasShownIPCDisabledWarning = false\n\nconst jobsInProcess: Map<\n  string,\n  { id: string; deferred: pDefer.DeferredPromise<Record<string, unknown>> }\n> = new Map()\nconst externalJobsMap: Map<\n  string,\n  { job: InternalJob; deferred: pDefer.DeferredPromise<any> }\n> = new Map()\n\n/**\n * We want to use absolute paths to make sure they are on the filesystem\n */\nfunction convertPathsToAbsolute(filePath: string): string {\n  if (!path.isAbsolute(filePath)) {\n    throw new Error(`${filePath} should be an absolute path.`)\n  }\n\n  return slash(filePath)\n}\n/**\n * Get contenthash of a file\n */\nfunction createFileHash(path: string): string {\n  return hasha.fromFileSync(path, { algorithm: `sha1` })\n}\n\nlet hasActiveJobs: pDefer.DeferredPromise<void> | null = null\n\nfunction hasExternalJobsEnabled(): boolean {\n  return (\n    process.env.ENABLE_GATSBY_EXTERNAL_JOBS === `true` ||\n    process.env.ENABLE_GATSBY_EXTERNAL_JOBS === `1`\n  )\n}\n\n/**\n * Get the local worker function and execute it on the user's machine\n */\nasync function runLocalWorker<T>(\n  workerFn: { ({ inputPaths, outputDir, args }: InternalJob): T },\n  job: InternalJob\n): Promise<T> {\n  await fs.ensureDir(job.outputDir)\n\n  return new Promise((resolve, reject) => {\n    // execute worker nextTick\n    // TODO should we think about threading/queueing here?\n    setImmediate(() => {\n      try {\n        resolve(\n          workerFn({\n            inputPaths: job.inputPaths,\n            outputDir: job.outputDir,\n            args: job.args,\n          } as InternalJob)\n        )\n      } catch (err) {\n        reject(new WorkerError(err))\n      }\n    })\n  })\n}\n\nfunction isJobsIPCMessage(msg: any): msg is IncomingMessages {\n  return (\n    msg &&\n    msg.type &&\n    msg.payload &&\n    msg.payload.id &&\n    externalJobsMap.has(msg.payload.id)\n  )\n}\n\nfunction listenForJobMessages(): void {\n  process.on(`message`, msg => {\n    if (isJobsIPCMessage(msg)) {\n      const { job, deferred } = externalJobsMap.get(msg.payload.id)!\n\n      switch (msg.type) {\n        case MESSAGE_TYPES.JOB_COMPLETED: {\n          deferred.resolve(msg.payload.result)\n          break\n        }\n        case MESSAGE_TYPES.JOB_FAILED: {\n          deferred.reject(new WorkerError(msg.payload.error))\n          break\n        }\n        case MESSAGE_TYPES.JOB_NOT_WHITELISTED: {\n          deferred.resolve(runJob(job, true))\n          break\n        }\n      }\n\n      externalJobsMap.delete(msg.payload.id)\n    }\n  })\n}\n\nfunction runExternalWorker(job: InternalJob): Promise<any> {\n  const deferred = pDefer<any>()\n\n  externalJobsMap.set(job.id, {\n    job,\n    deferred,\n  })\n\n  const jobCreatedMessage: OutgoingMessages = {\n    type: MESSAGE_TYPES.JOB_CREATED,\n    payload: job,\n  }\n\n  process.send!(jobCreatedMessage)\n\n  return deferred.promise\n}\n\n/**\n * Make sure we have everything we need to run a job\n * If we do, run it locally.\n * TODO add external job execution through ipc\n */\nfunction runJob(\n  job: InternalJob,\n  forceLocal = false\n): Promise<Record<string, unknown>> {\n  const { plugin } = job\n  try {\n    const worker = requireGatsbyPlugin(plugin, `gatsby-worker`)\n    if (!worker[job.name]) {\n      throw new Error(`No worker function found for ${job.name}`)\n    }\n\n    if (!forceLocal && !job.plugin.isLocal && hasExternalJobsEnabled()) {\n      if (process.send) {\n        if (!isListeningForMessages) {\n          isListeningForMessages = true\n          listenForJobMessages()\n        }\n\n        return runExternalWorker(job)\n      } else {\n        // only show the offloading warning once\n        if (!hasShownIPCDisabledWarning) {\n          hasShownIPCDisabledWarning = true\n          reporter.warn(\n            `Offloading of a job failed as IPC could not be detected. Running job locally.`\n          )\n        }\n      }\n    }\n    return runLocalWorker(worker[job.name], job)\n  } catch (err) {\n    throw new Error(\n      `We couldn't find a gatsby-worker.js(${plugin.resolve}/gatsby-worker.js) file for ${plugin.name}@${plugin.version}`\n    )\n  }\n}\n\nfunction isInternalJob(job: JobInput | InternalJob): job is InternalJob {\n  return (\n    (job as InternalJob).id !== undefined &&\n    (job as InternalJob).contentDigest !== undefined\n  )\n}\n\n/**\n * Create an internal job object\n */\nexport function createInternalJob(\n  job: JobInput | InternalJob,\n  plugin: { name: string; version: string; resolve: string }\n): InternalJob {\n  // It looks like we already have an augmented job so we shouldn't redo this work\n  if (isInternalJob(job)) {\n    return job\n  }\n\n  const { name, inputPaths, outputDir, args } = job\n\n  // TODO see if we can make this async, filehashing might be expensive to wait for\n  // currently this needs to be sync as we could miss jobs to have been scheduled and\n  // are still processing their hashes\n  const inputPathsWithContentDigest = inputPaths.map((pth: string) => {\n    return {\n      path: convertPathsToAbsolute(pth),\n      contentDigest: createFileHash(pth),\n    }\n  })\n\n  const internalJob: InternalJob = {\n    id: uuid.v4(),\n    name,\n    contentDigest: ``,\n    inputPaths: inputPathsWithContentDigest,\n    outputDir: convertPathsToAbsolute(outputDir),\n    args,\n    plugin: {\n      name: plugin.name,\n      version: plugin.version,\n      resolve: plugin.resolve,\n      isLocal: !plugin.resolve.includes(`/node_modules/`),\n    },\n  }\n\n  // generate a contentDigest based on all parameters including file content\n  internalJob.contentDigest = createContentDigest({\n    name: job.name,\n    inputPaths: internalJob.inputPaths.map(\n      inputPath => inputPath.contentDigest\n    ),\n    outputDir: internalJob.outputDir,\n    args: internalJob.args,\n    plugin: internalJob.plugin,\n  })\n\n  return internalJob\n}\n\nconst activitiesForJobTypes = new Map<\n  string,\n  ReturnType<typeof reporter.createProgress>\n>()\n\n/**\n * Creates a job\n */\nexport async function enqueueJob(\n  job: InternalJob\n): Promise<Record<string, unknown>> {\n  // When we already have a job that's executing, return the same promise.\n  // we have another check in our createJobV2 action to return jobs that have been done in a previous gatsby run\n  if (jobsInProcess.has(job.contentDigest)) {\n    return jobsInProcess.get(job.contentDigest)!.deferred.promise\n  }\n\n  if (activeJobs === 0) {\n    hasActiveJobs = pDefer<void>()\n  }\n\n  // Bump active jobs\n  activeJobs++\n  if (!activityForJobs) {\n    activityForJobs = reporter.phantomActivity(`Running jobs v2`)\n    activityForJobs!.start()\n  }\n\n  const jobType = `${job.plugin.name}.${job.name}`\n\n  let activityForJobsProgress = activitiesForJobTypes.get(jobType)\n\n  if (!activityForJobsProgress) {\n    activityForJobsProgress = reporter.createProgress(\n      `Running ${jobType} jobs`,\n      1,\n      0\n    )\n    activityForJobsProgress.start()\n    activitiesForJobTypes.set(jobType, activityForJobsProgress)\n  } else {\n    activityForJobsProgress.total++\n  }\n\n  const deferred = pDefer<Record<string, unknown>>()\n  jobsInProcess.set(job.contentDigest, {\n    id: job.id,\n    deferred,\n  })\n\n  try {\n    const result = await runJob(job)\n    // this check is to keep our worker results consistent for cloud\n    if (result != null && !_.isPlainObject(result)) {\n      throw new Error(\n        `Result of a worker should be an object, type of \"${typeof result}\" was given`\n      )\n    }\n    deferred.resolve(result)\n  } catch (err) {\n    deferred.reject(new WorkerError(err))\n  } finally {\n    // when all jobs are done we end the activity\n    if (--activeJobs === 0) {\n      hasActiveJobs!.resolve()\n      activityForJobs!.end()\n      // eslint-disable-next-line require-atomic-updates\n      activityForJobs = null\n    }\n\n    activityForJobsProgress.tick()\n  }\n\n  return deferred.promise\n}\n\n/**\n * Get in progress job promise\n */\nexport function getInProcessJobPromise(\n  contentDigest: string\n): Promise<Record<string, unknown>> | undefined {\n  return jobsInProcess.get(contentDigest)?.deferred.promise\n}\n\n/**\n * Remove a job from our inProgressQueue to reduce memory usage\n */\nexport function removeInProgressJob(contentDigest: string): void {\n  jobsInProcess.delete(contentDigest)\n}\n\n/**\n * Wait for all processing jobs to have finished\n */\nexport async function waitUntilAllJobsComplete(): Promise<void> {\n  await (hasActiveJobs ? hasActiveJobs.promise : Promise.resolve())\n  for (const progressActivity of activitiesForJobTypes.values()) {\n    progressActivity.end()\n  }\n  activitiesForJobTypes.clear()\n}\n\n/**\n * Wait for specific jobs for engines\n */\nexport async function waitJobs(jobDigests: Set<string>): Promise<void> {\n  const promises: Array<Promise<any>> = []\n  for (const [digest, job] of jobsInProcess) {\n    if (jobDigests.has(digest)) {\n      promises.push(job.deferred.promise)\n    }\n  }\n  await Promise.all(promises)\n}\n\nexport function isJobStale(\n  job: Partial<InternalJob> & { inputPaths: InternalJob[\"inputPaths\"] }\n): boolean {\n  const areInputPathsStale = job.inputPaths.some(inputPath => {\n    // does the inputPath still exists?\n    if (!fs.existsSync(inputPath.path)) {\n      return true\n    }\n\n    // check if we're talking about the same file\n    const fileHash = createFileHash(inputPath.path)\n    return fileHash !== inputPath.contentDigest\n  })\n\n  return areInputPathsStale\n}\n"],"file":"manager.js"}
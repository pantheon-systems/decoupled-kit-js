{"version":3,"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/build-query-on-field-name.js"],"names":["buildReusableFragments","fragments","Object","values","map","name","type","fields","inlineFragments","buildSelectionSet","buildInlineFragments","join","generateReusableFragments","selectionSet","fragmentsValues","length","builtFragments","regenerateFragments","forEach","includes","buildNodesQueryOnFieldName","fieldName","builtSelectionSet","queryVariables","fieldVariables","buildQuery","queryName","variables","buildVariables","buildInlineFragment","inlineFragment","transformedInlineFragments","remoteSchema","typeMap","store","getState","buildFieldSelectionSet","field","fieldType","internalType","fragment","find","builtInlineFragments","fullFieldType","get","inlineFragmentsSelectionSet","filter","Boolean","buildNodeQueryOnFieldName","fieldInputArguments"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport { findTypeName } from \"~/steps/create-schema-customization/helpers\"\n\nconst buildReusableFragments = ({ fragments }) =>\n  Object.values(fragments)\n    .map(\n      ({\n        name,\n        type,\n        fields,\n        inlineFragments,\n      }) => `fragment ${name} on ${type} {\n      ${buildSelectionSet(fields)}\n      ${buildInlineFragments(inlineFragments)}\n    }`\n    )\n    .join(` `)\n\n/**\n * Takes in a fragments object (built up during the buildSelectionSet function)\n * transforms that object into an actual fragment,\n * then checks for unused fragments and potential regenerates again\n * with the unused fragments removed\n */\nexport const generateReusableFragments = ({ fragments, selectionSet }) => {\n  const fragmentsValues = Object.values(fragments)\n\n  if (!fragmentsValues.length) {\n    return ``\n  }\n\n  let builtFragments = buildReusableFragments({ fragments })\n\n  if (fragments) {\n    let regenerateFragments = false\n\n    fragmentsValues.forEach(({ name, type }) => {\n      // if our query didn't use the fragment due to the query depth AND the fragment isn't used in another fragment, delete it\n      // @todo these fragments shouldn't be generated if they wont be used.\n      // if we fix this todo, we can use the buildReusableFragments function directly\n      // instead of running it twice to remove unused fragments\n      if (\n        !selectionSet.includes(`...${name}`) &&\n        !builtFragments.includes(`...${name}`)\n      ) {\n        delete fragments[type]\n        regenerateFragments = true\n      }\n    })\n\n    if (regenerateFragments) {\n      builtFragments = buildReusableFragments({ fragments })\n    }\n  }\n\n  return builtFragments\n}\n\nexport const buildNodesQueryOnFieldName = ({\n  fieldName,\n  builtSelectionSet,\n  builtFragments = ``,\n  queryVariables = ``,\n  fieldVariables = ``,\n}) =>\n  buildQuery({\n    queryName: `NODE_LIST_QUERY`,\n    variables: `$first: Int!, $after: String, ${queryVariables}`,\n    fieldName,\n    fieldVariables: `first: $first, after: $after, ${fieldVariables}`,\n    builtSelectionSet: `\n        nodes {\n          ${builtSelectionSet}\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      `,\n    builtFragments,\n  })\n\nconst buildVariables = variables =>\n  variables && typeof variables === `string` ? `(${variables})` : ``\n\nconst buildInlineFragment = ({ name, fields, fragments }) => `\n  ... on ${name} {\n    ${buildSelectionSet(fields, { fragments })}\n  }\n`\n\nconst buildInlineFragments = (inlineFragments, { fragments = {} } = {}) =>\n  inlineFragments\n    ? `\n      __typename\n      ${inlineFragments\n        .map(inlineFragment =>\n          buildInlineFragment({ ...inlineFragment, fragments })\n        )\n        .join(` `)}\n    `\n    : ``\n\nexport const buildSelectionSet = (\n  fields,\n  { fragments = {}, transformedInlineFragments = [] } = {}\n) => {\n  if (!fields || !fields.length) {\n    return ``\n  }\n\n  const {\n    remoteSchema: { typeMap },\n  } = store.getState()\n\n  const buildFieldSelectionSet = field => {\n    if (typeof field === `string`) {\n      return field\n    }\n\n    let {\n      fieldName,\n      variables,\n      fields,\n      inlineFragments,\n      fieldType,\n      internalType,\n      builtSelectionSet,\n    } = field\n\n    if (internalType === `Fragment`) {\n      return `...${field.fragment.name}`\n    }\n\n    if (\n      (!variables || variables === ``) &&\n      fields?.find(field => field.fieldName === `nodes`)\n    ) {\n      // @todo instead of checking for a nodes field, include the field type here\n      // and check for input args instead. Maybe some kind of input args API or something would be helpful\n      variables = `first: 100`\n    }\n\n    const selectionSet =\n      builtSelectionSet ||\n      buildSelectionSet(fields, {\n        fragments,\n      })\n\n    const builtInlineFragments = buildInlineFragments(inlineFragments, {\n      fragments,\n    })\n\n    if (fieldName && (builtInlineFragments !== `` || selectionSet !== ``)) {\n      return `\n        ${fieldName} ${buildVariables(variables)} {\n          ${selectionSet}\n          ${builtInlineFragments}\n        }\n      `\n    } else if (fieldName) {\n      const fullFieldType = typeMap.get(findTypeName(fieldType))\n\n      // if this field has subfields but we didn't build a selection set for it\n      // we shouldn't fetch this field. This can happen when we have self referencing types that are limited by the schema.circularQueryLimit plugin option.\n      // @todo the above should be fixed in recursively-transform-fields.js instead of here. recursion is hard :p\n      if (fullFieldType.fields) {\n        return null\n      }\n\n      return fieldName\n    }\n\n    return null\n  }\n\n  let inlineFragmentsSelectionSet = ``\n\n  if (transformedInlineFragments?.length) {\n    inlineFragmentsSelectionSet = transformedInlineFragments.map(\n      inlineFragment => `... on ${inlineFragment.name} {\n        ${inlineFragment.fields.map(buildFieldSelectionSet).filter(Boolean)\n          .join(`\n        `)}\n      }`\n    )\n  }\n\n  const selectionSet = fields.map(buildFieldSelectionSet).filter(Boolean).join(`\n    `)\n\n  return `${inlineFragmentsSelectionSet} ${selectionSet}`\n}\n\nconst buildQuery = ({\n  queryName,\n  fieldName,\n  fieldVariables,\n  variables,\n  builtSelectionSet,\n  builtFragments = ``,\n}) => `\n  query ${queryName} ${buildVariables(variables)} {\n    ${fieldName} ${buildVariables(fieldVariables)} {\n      ${builtSelectionSet}\n    }\n  }\n\n  ${builtFragments}\n`\n\nexport const buildNodeQueryOnFieldName = ({\n  fieldName,\n  builtFragments,\n  builtSelectionSet,\n  variables = `$id: ID!`,\n  fieldInputArguments = `id: $id`,\n  queryName = `SINGLE_CONTENT_QUERY`,\n}) =>\n  buildQuery({\n    queryName,\n    variables,\n    fieldName,\n    fieldVariables: fieldInputArguments,\n    builtFragments,\n    builtSelectionSet,\n  })\n"],"file":"build-query-on-field-name.js"}
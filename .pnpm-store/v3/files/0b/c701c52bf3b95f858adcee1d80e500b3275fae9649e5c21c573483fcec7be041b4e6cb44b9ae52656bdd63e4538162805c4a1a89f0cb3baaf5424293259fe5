{"version":3,"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/generate-queries-from-ingestable-types.js"],"names":["recursivelyAliasFragments","field","inlineFragments","map","fragment","fields","fragmentField","updatedFragmentField","forEach","possiblyConflictingFragment","name","possiblyConflictingField","fieldNamesMatch","fieldName","fieldTypeKindsDontMatch","fieldType","kind","fieldTypeNamesDontMatch","autoAliasedFieldName","aliasConflictingFieldFields","aliasConflictingFields","transformedFields","aliasConflictingFragmentFields","fragments","fragmentKey","Object","entries","aliasedFragment","generateNodeQueriesFromIngestibleFields","remoteSchema","gatsbyApi","helpers","reporter","pluginOptions","debug","graphql","copyNodeSourcingQueryAndExit","store","getState","fieldBlacklist","nodeListFilter","typeMap","ingestibles","nodeListRootFields","rootFields","get","nodeQueries","type","includes","fieldFields","nodesField","find","nodesType","ofType","possibleTypes","settings","exclude","nodeListQueries","singleNodeRootFieldInfo","warn","singleFieldName","parentType","mainType","push","transformedInlineFragments","buildGatsbyNodeFields","inlineFragment","aliasedTransformedFields","selectionSet","fieldPath","builtFragments","nodeQuery","builtSelectionSet","previewQuery","fieldInputArguments","queryName","fieldVariables","where","queries","recursivelyTransformFields","buildNodesQueryOnFieldName","length","nodeListQuery","process","env","NODE_ENV","log","clipboardy","write","prettier","format","parser","exit","e","error","typeInfo","singularName","pluralName","nodesTypeName"],"mappings":"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","sourcesContent":["import recursivelyTransformFields, {\n  transformInlineFragments,\n} from \"./recursively-transform-fields\"\n\nimport {\n  buildNodesQueryOnFieldName,\n  buildNodeQueryOnFieldName,\n  buildSelectionSet,\n  generateReusableFragments,\n} from \"./build-query-on-field-name\"\n\nimport clipboardy from \"clipboardy\"\n\nimport store from \"~/store\"\nimport { getTypeSettingsByType } from \"~/steps/create-schema-customization/helpers\"\nimport prettier from \"prettier\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\n\nconst recursivelyAliasFragments = field =>\n  field.inlineFragments.map(fragment => {\n    // for each of this inlineFragments fields\n    fragment.fields = fragment.fields.map(fragmentField => {\n      if (typeof fragmentField === `string`) {\n        return fragmentField\n      }\n\n      // compare it against each field of each other fragment\n      let updatedFragmentField = fragmentField\n\n      field.inlineFragments.forEach(possiblyConflictingFragment => {\n        // don't compare this fragment against itself\n        if (possiblyConflictingFragment.name === fragment.name) {\n          return\n        }\n\n        possiblyConflictingFragment.fields.forEach(possiblyConflictingField => {\n          const fieldNamesMatch =\n            fragmentField.fieldName === possiblyConflictingField.fieldName\n\n          const fieldTypeKindsDontMatch =\n            possiblyConflictingField?.fieldType?.kind !==\n            fragmentField?.fieldType?.kind\n\n          const fieldTypeNamesDontMatch =\n            possiblyConflictingField?.fieldType?.name !==\n            fragmentField?.fieldType?.name\n\n          // if the fields have the same name but a different type kind\n          // alias them\n          if (\n            fieldNamesMatch &&\n            (fieldTypeKindsDontMatch || fieldTypeNamesDontMatch)\n          ) {\n            const autoAliasedFieldName = `${fragmentField.fieldName}__typename_${fragmentField.fieldType.name}: ${fragmentField.fieldName}`\n\n            updatedFragmentField = {\n              ...fragmentField,\n              fieldName: autoAliasedFieldName,\n            }\n\n            return\n          }\n        })\n      })\n      // if the fields have the same name but a different type AND the field has sub fields, compare those sub fields against any fragment fields subfields where the field name matches\n      // if any subfields have conflicting types, alias them\n\n      if (updatedFragmentField.inlineFragments) {\n        updatedFragmentField.inlineFragments =\n          recursivelyAliasFragments(updatedFragmentField)\n      }\n\n      return updatedFragmentField\n    })\n\n    return fragment\n  })\n\nconst aliasConflictingFieldFields = field => {\n  // we only have conflicting fields in inlineFragments\n  // if there are no inlineFragments, do nothing\n  if (!field.inlineFragments) {\n    return field\n  }\n\n  field.inlineFragments = recursivelyAliasFragments(field)\n\n  if (field.fields) {\n    field.fields = aliasConflictingFields({\n      transformedFields: field.fields,\n    })\n  }\n\n  return field\n}\n\nconst aliasConflictingFields = ({ transformedFields }) =>\n  transformedFields.map(aliasConflictingFieldFields)\n\nconst aliasConflictingFragmentFields = ({ fragments }) => {\n  for (const [fragmentKey, fragment] of Object.entries(fragments)) {\n    const aliasedFragment = aliasConflictingFieldFields(fragment)\n\n    fragments[fragmentKey] = aliasedFragment\n  }\n}\n\n/**\n * generateNodeQueriesFromIngestibleFields\n *\n * Takes in data from an introspection query and\n * processes it to build GraphQL query strings/info\n *\n * @param {object} introspectionData\n * @returns {Object} GraphQL query info including gql query strings\n */\nconst generateNodeQueriesFromIngestibleFields = async () => {\n  const {\n    remoteSchema,\n    gatsbyApi: {\n      helpers: { reporter },\n      pluginOptions: {\n        debug: {\n          graphql: { copyNodeSourcingQueryAndExit },\n        },\n      },\n    },\n  } = store.getState()\n\n  const {\n    fieldBlacklist,\n    nodeListFilter,\n    typeMap,\n    ingestibles: { nodeListRootFields },\n  } = remoteSchema\n\n  const rootFields = typeMap.get(`RootQuery`).fields\n\n  const nodeQueries = {}\n\n  for (const { type, name } of nodeListRootFields) {\n    if (fieldBlacklist.includes(name)) {\n      continue\n    }\n\n    // nested fields\n    const fieldFields = typeMap.get(type.name).fields\n\n    // a nested field containing a list of nodes\n    const nodesField = fieldFields.find(nodeListFilter)\n\n    // the type of this query\n    const nodesType = typeMap.get(nodesField.type.ofType.name)\n\n    const { fields, possibleTypes } = nodesType\n\n    const settings = getTypeSettingsByType(nodesType)\n\n    if (settings.exclude) {\n      continue\n    }\n\n    let nodeListQueries = []\n\n    const singleNodeRootFieldInfo = rootFields.find(\n      field => field.type.name === nodesType.name\n    )\n\n    if (!singleNodeRootFieldInfo) {\n      // @todo handle cases where there is a nodelist field but no individual field. we can't do data updates or preview on this type.\n      reporter.warn(\n        formatLogMessage(\n          `Unable to find a single Node query for ${nodesType.name}\\n\\tThis type will not be available in Gatsby.\\n`\n        )\n      )\n      continue\n    }\n\n    const fragments = {}\n\n    const singleFieldName = singleNodeRootFieldInfo?.name\n\n    const transformedFields = recursivelyTransformFields({\n      fields,\n      fragments,\n      parentType: type,\n      mainType: type,\n    })\n\n    // we need this for node interface types on the WPGQL side\n    transformedFields.push(`__typename`)\n\n    let transformedInlineFragments\n\n    if (possibleTypes) {\n      transformedInlineFragments = transformInlineFragments({\n        possibleTypes,\n        fragments,\n        parentType: nodesType,\n        mainType: nodesType,\n        debug: true,\n        // normally we only want the id for gatsby node fields\n        // but in this case we're at the top level and need to query\n        // these fields\n        buildGatsbyNodeFields: true,\n      })\n\n      // alias conflicting inline fragment fields\n      transformedInlineFragments = transformedInlineFragments.map(\n        ({ fields, ...inlineFragment }) => {\n          return {\n            ...inlineFragment,\n            fields: aliasConflictingFields({\n              transformedFields: fields,\n            }),\n          }\n        }\n      )\n    }\n\n    // mutates the fragments..\n    aliasConflictingFragmentFields({ fragments })\n\n    const aliasedTransformedFields = aliasConflictingFields({\n      transformedFields,\n      parentType: type,\n    })\n\n    const selectionSet = buildSelectionSet(aliasedTransformedFields, {\n      fieldPath: name,\n      fragments,\n      transformedInlineFragments,\n    })\n\n    const builtFragments = generateReusableFragments({\n      fragments,\n      selectionSet,\n    })\n\n    const nodeQuery = buildNodeQueryOnFieldName({\n      fields: transformedFields,\n      fieldName: singleFieldName,\n      settings,\n      builtFragments,\n      builtSelectionSet: selectionSet,\n    })\n\n    const previewQuery = buildNodeQueryOnFieldName({\n      fields: transformedFields,\n      fieldName: singleFieldName,\n      fieldInputArguments: `id: $id, idType: ID, asPreview: true`,\n      queryName: `PREVIEW_QUERY`,\n      settings,\n      builtFragments,\n      builtSelectionSet: selectionSet,\n    })\n\n    const fieldVariables = settings.where ? `where: { ${settings.where} }` : ``\n\n    if (\n      settings.nodeListQueries &&\n      typeof settings.nodeListQueries === `function`\n    ) {\n      const queries = settings.nodeListQueries({\n        name,\n        fields,\n        selectionSet,\n        builtFragments,\n        singleFieldName,\n        singleNodeRootFieldInfo,\n        settings,\n        store,\n        fieldVariables,\n        remoteSchema,\n        transformedFields,\n        helpers: {\n          recursivelyTransformFields,\n          buildNodesQueryOnFieldName,\n        },\n      })\n\n      if (queries && queries.length) {\n        nodeListQueries = queries\n      }\n    }\n\n    if (!nodeListQueries || !nodeListQueries.length) {\n      const nodeListQuery = buildNodesQueryOnFieldName({\n        fields: transformedFields,\n        fieldName: name,\n        fieldVariables,\n        settings,\n        builtFragments,\n        builtSelectionSet: selectionSet,\n      })\n\n      nodeListQueries = [nodeListQuery]\n    }\n\n    if (\n      process.env.NODE_ENV === `development` &&\n      nodesType.name === copyNodeSourcingQueryAndExit\n    ) {\n      try {\n        reporter.log(``)\n        reporter.warn(\n          formatLogMessage(\n            `Query debug mode. Writing node list query for the ${nodesType.name} node type to the system clipboard and exiting\\n\\n`\n          )\n        )\n        await clipboardy.write(\n          prettier.format(nodeListQueries[0], { parser: `graphql` })\n        )\n        process.exit()\n      } catch (e) {\n        reporter.log(``)\n        reporter.error(e)\n        reporter.log(``)\n        reporter.warn(\n          formatLogMessage(\n            `Query debug mode failed. There was a failed attempt to copy the query for the ${nodesType.name} node type to your clipboard.\\n\\n`\n          )\n        )\n        reporter.error(e)\n      }\n    }\n\n    // build a query info object containing gql query strings for fetching\n    // node lists or single nodes, as well as type info and plugin\n    // settings for this type\n    nodeQueries[name] = {\n      typeInfo: {\n        singularName: singleFieldName,\n        pluralName: name,\n        nodesTypeName: nodesType.name,\n      },\n      nodeListQueries,\n      nodeQuery,\n      previewQuery,\n      selectionSet,\n      builtFragments,\n      settings,\n    }\n  }\n\n  return nodeQueries\n}\n\nexport default generateNodeQueriesFromIngestibleFields\n"],"file":"generate-queries-from-ingestable-types.js"}
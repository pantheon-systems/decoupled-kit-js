{"version":3,"sources":["../../src/utils/page-data.ts"],"names":["readPageData","publicDir","pagePath","filePath","rawPageData","fs","readFile","JSON","parse","removePageData","existsSync","remove","Promise","resolve","pageDataExists","lmdbPageQueryResultsCache","getLMDBPageQueryResultsCache","GatsbyCacheLmdbImpl","require","default","name","encoding","init","savePageQueryResultsPromise","waitUntilPageQueryResultsAreStored","savePageQueryResult","programDir","stringifiedResult","set","pageQueryResultsPath","path","join","replace","outputFile","readPageQueryResult","get","Error","writePageData","pageData","result","outputFilePath","body","pageDataSize","Buffer","byteLength","store","dispatch","type","payload","size","pageDataHash","isFlushPending","isFlushing","isFlushEnqueued","flush","parentSpan","pendingPageDataWrites","pages","program","staticQueriesByTemplate","queries","getState","isBuild","_","pagePaths","writePageDataActivity","nodeManifestPagePathMap","reporter","createProgress","id","start","flushQueue","cb","page","manifestId","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","query","trackedQueries","dirty","FLAG_DIRTY_NEW_PAGE","setImmediate","staticQueryHashes","componentPath","directory","tick","websocketManager","emitPageData","push","idle","drain","end","enqueueFlush","handleStalePageData","pathExists","activity","activityTimer","pageDataFilesFromPreviousBuilds","reject","results","Set","stream","on","data","add","e","expectedPageDataFiles","forEach","deletionPromises","pageDataFilePath","has","all"],"mappings":"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","sourcesContent":["import { walkStream as fsWalkStream, Entry } from \"@nodelib/fs.walk\"\nimport fs from \"fs-extra\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport fastq from \"fastq\"\nimport path from \"path\"\nimport { createContentDigest, generatePageDataPath } from \"gatsby-core-utils\"\nimport { websocketManager } from \"./websocket-manager\"\nimport { isWebpackStatusPending } from \"./webpack-status\"\nimport { store } from \"../redux\"\nimport { hasFlag, FLAG_DIRTY_NEW_PAGE } from \"../redux/reducers/queries\"\nimport { isLmdbStore } from \"../datastore\"\nimport type GatsbyCacheLmdb from \"./cache-lmdb\"\nimport {\n  constructPageDataString,\n  reverseFixedPagePath,\n  IPageData,\n} from \"./page-data-helpers\"\nimport { Span } from \"opentracing\"\n\nexport { reverseFixedPagePath }\nimport { processNodeManifests } from \"../utils/node-manifest\"\nimport { IExecutionResult } from \"../query/types\"\nimport { getPageMode } from \"./page-mode\"\n\nexport interface IPageDataWithQueryResult extends IPageData {\n  result: IExecutionResult\n}\n\nexport async function readPageData(\n  publicDir: string,\n  pagePath: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawPageData)\n}\n\nexport async function removePageData(\n  publicDir: string,\n  pagePath: string\n): Promise<void> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n\n  if (fs.existsSync(filePath)) {\n    return await fs.remove(filePath)\n  }\n\n  return Promise.resolve()\n}\n\nexport function pageDataExists(publicDir: string, pagePath: string): boolean {\n  return fs.existsSync(generatePageDataPath(publicDir, pagePath))\n}\n\nlet lmdbPageQueryResultsCache: GatsbyCacheLmdb\nfunction getLMDBPageQueryResultsCache(): GatsbyCacheLmdb {\n  if (!lmdbPageQueryResultsCache) {\n    const GatsbyCacheLmdbImpl = require(`./cache-lmdb`).default\n    lmdbPageQueryResultsCache = new GatsbyCacheLmdbImpl({\n      name: `internal-tmp-query-results`,\n      encoding: `string`,\n    }).init()\n  }\n  return lmdbPageQueryResultsCache\n}\n\nlet savePageQueryResultsPromise = Promise.resolve()\n\nexport function waitUntilPageQueryResultsAreStored(): Promise<void> {\n  return savePageQueryResultsPromise\n}\n\nexport async function savePageQueryResult(\n  programDir: string,\n  pagePath: string,\n  stringifiedResult: string\n): Promise<void> {\n  if (isLmdbStore()) {\n    savePageQueryResultsPromise = getLMDBPageQueryResultsCache().set(\n      pagePath,\n      stringifiedResult\n    ) as Promise<void>\n  } else {\n    const pageQueryResultsPath = path.join(\n      programDir,\n      `.cache`,\n      `json`,\n      `${pagePath.replace(/\\//g, `_`)}.json`\n    )\n    await fs.outputFile(pageQueryResultsPath, stringifiedResult)\n  }\n}\n\nexport async function readPageQueryResult(\n  publicDir: string,\n  pagePath: string\n): Promise<string | Buffer> {\n  if (isLmdbStore()) {\n    const stringifiedResult = await getLMDBPageQueryResultsCache().get(pagePath)\n    if (typeof stringifiedResult === `string`) {\n      return stringifiedResult\n    }\n    throw new Error(`Couldn't find temp query result for \"${pagePath}\".`)\n  } else {\n    const pageQueryResultsPath = path.join(\n      publicDir,\n      `..`,\n      `.cache`,\n      `json`,\n      `${pagePath.replace(/\\//g, `_`)}.json`\n    )\n    return fs.readFile(pageQueryResultsPath)\n  }\n}\n\nexport async function writePageData(\n  publicDir: string,\n  pageData: IPageData\n): Promise<string> {\n  const result = await readPageQueryResult(publicDir, pageData.path)\n\n  const outputFilePath = generatePageDataPath(publicDir, pageData.path)\n\n  const body = constructPageDataString(pageData, result)\n\n  // transform asset size to kB (from bytes) to fit 64 bit to numbers\n  const pageDataSize = Buffer.byteLength(body) / 1000\n\n  store.dispatch({\n    type: `ADD_PAGE_DATA_STATS`,\n    payload: {\n      pagePath: pageData.path,\n      filePath: outputFilePath,\n      size: pageDataSize,\n      pageDataHash: createContentDigest(body),\n    },\n  })\n\n  await fs.outputFile(outputFilePath, body)\n  return body\n}\n\nlet isFlushPending = false\nlet isFlushing = false\n\nexport function isFlushEnqueued(): boolean {\n  return isFlushPending\n}\n\nexport async function flush(parentSpan?: Span): Promise<void> {\n  if (isFlushing) {\n    // We're already in the middle of a flush\n    return\n  }\n  await waitUntilPageQueryResultsAreStored()\n  isFlushPending = false\n  isFlushing = true\n  const {\n    pendingPageDataWrites,\n    pages,\n    program,\n    staticQueriesByTemplate,\n    queries,\n  } = store.getState()\n  const isBuild = program?._?.[0] !== `develop`\n\n  const { pagePaths } = pendingPageDataWrites\n  let writePageDataActivity\n\n  let nodeManifestPagePathMap\n\n  if (pagePaths.size > 0) {\n    // we process node manifests in this location because we need to add the manifestId to the page data.\n    // We use this manifestId to determine if the page data is up to date when routing. Here we create a map of \"pagePath\": \"manifestId\" while processing and writing node manifest files.\n    // We only do this when there are pending page-data writes because otherwise we could flush pending createNodeManifest calls before page-data.json files are written. Which means those page-data files wouldn't have the corresponding manifest id's written to them.\n    nodeManifestPagePathMap = await processNodeManifests()\n\n    writePageDataActivity = reporter.createProgress(\n      `Writing page-data.json files to public directory`,\n      pagePaths.size,\n      0,\n      { id: `write-page-data-public-directory`, parentSpan }\n    )\n    writePageDataActivity.start()\n  }\n\n  const flushQueue = fastq(async (pagePath, cb) => {\n    const page = pages.get(pagePath)\n\n    // It's a gloomy day in Bombay, let me tell you a short story...\n    // Once upon a time, writing page-data.json files were atomic\n    // After this change (#24808), they are not and this means that\n    // between adding a pending write for a page and actually flushing\n    // them, a page might not exist anymore щ（ﾟДﾟщ）\n    // This is why we need this check\n    if (page) {\n      if (page.path && nodeManifestPagePathMap) {\n        page.manifestId = nodeManifestPagePathMap.get(page.path)\n      }\n\n      if (!isBuild && process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n        // check if already did run query for this page\n        // with query-on-demand we might have pending page-data write due to\n        // changes in static queries assigned to page template, but we might not\n        // have query result for it\n        const query = queries.trackedQueries.get(page.path)\n        if (!query) {\n          // this should not happen ever\n          throw new Error(\n            `We have a page, but we don't have registered query for it (???)`\n          )\n        }\n\n        if (hasFlag(query.dirty, FLAG_DIRTY_NEW_PAGE)) {\n          // query results are not written yet\n          setImmediate(() => cb(null, true))\n          return\n        }\n      }\n\n      // In develop we rely on QUERY_ON_DEMAND so we just go through\n      // In build we only build these page-json for SSG pages\n      if (\n        _CFLAGS_.GATSBY_MAJOR !== `4` ||\n        !isBuild ||\n        (isBuild && getPageMode(page) === `SSG`)\n      ) {\n        const staticQueryHashes =\n          staticQueriesByTemplate.get(page.componentPath) || []\n\n        const result = await writePageData(\n          path.join(program.directory, `public`),\n          {\n            ...page,\n            staticQueryHashes,\n          }\n        )\n\n        writePageDataActivity.tick()\n\n        if (!isBuild) {\n          websocketManager.emitPageData({\n            id: pagePath,\n            result: JSON.parse(result) as IPageDataWithQueryResult,\n          })\n        }\n      }\n    }\n\n    store.dispatch({\n      type: `CLEAR_PENDING_PAGE_DATA_WRITE`,\n      payload: {\n        page: pagePath,\n      },\n    })\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many non-SSG pages\n    setImmediate(() => cb(null, true))\n    return\n  }, 25)\n\n  for (const pagePath of pagePaths) {\n    flushQueue.push(pagePath, () => {})\n  }\n\n  if (!flushQueue.idle()) {\n    await new Promise(resolve => {\n      flushQueue.drain = resolve as () => unknown\n    })\n  }\n  if (writePageDataActivity) {\n    writePageDataActivity.end()\n  }\n\n  isFlushing = false\n\n  return\n}\n\nexport function enqueueFlush(parentSpan?: Span): void {\n  if (isWebpackStatusPending()) {\n    isFlushPending = true\n  } else {\n    flush(parentSpan)\n  }\n}\n\nexport async function handleStalePageData(parentSpan: Span): Promise<void> {\n  if (!(await fs.pathExists(`public/page-data`))) {\n    return\n  }\n\n  // public directory might have stale page-data files from previous builds\n  // we get the list of those and compare against expected page-data files\n  // and remove ones that shouldn't be there anymore\n\n  const activity = reporter.activityTimer(`Cleaning up stale page-data`, {\n    parentSpan,\n  })\n  activity.start()\n\n  const pageDataFilesFromPreviousBuilds = await new Promise<Set<string>>(\n    (resolve, reject) => {\n      const results = new Set<string>()\n\n      const stream = fsWalkStream(`public/page-data`)\n\n      stream.on(`data`, (data: Entry) => {\n        if (data.name === `page-data.json`) {\n          results.add(data.path)\n        }\n      })\n\n      stream.on(`error`, e => {\n        reject(e)\n      })\n\n      stream.on(`end`, () => resolve(results))\n    }\n  )\n\n  const expectedPageDataFiles = new Set<string>()\n  store.getState().pages.forEach(page => {\n    expectedPageDataFiles.add(generatePageDataPath(`public`, page.path))\n  })\n\n  const deletionPromises: Array<Promise<void>> = []\n  pageDataFilesFromPreviousBuilds.forEach(pageDataFilePath => {\n    if (!expectedPageDataFiles.has(pageDataFilePath)) {\n      deletionPromises.push(fs.remove(pageDataFilePath))\n    }\n  })\n\n  await Promise.all(deletionPromises)\n\n  activity.end()\n}\n"],"file":"page-data.js"}
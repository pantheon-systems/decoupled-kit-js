{"version":3,"sources":["../../../src/schema/graphql-engine/entry.ts"],"names":["tracerReadyPromise","process","env","GATSBY_OPEN_TRACING_CONFIG_FILE","GraphQLEngine","constructor","dbPath","getRunner","_doGetRunner","wrapActivity","reporter","phantomActivity","start","store","dispatch","actions","createTypes","SCHEMA_SNAPSHOT","type","payload","flattenedPlugins","pluginName","Object","keys","gatsbyNodes","name","resolve","gatsbyWorkers","parentSpan","span","fullMetadataBuild","GraphQLRunner","end","runnerPromise","ready","runQuery","query","context","opts","engineContext","requestId","uuid","v4","doRunQuery","queryName","undefined","gettingRunnerActivity","graphqlRunner","result","waitingForJobsCreatedByCurrentRequestActivity","findPageByPath","pathName","state","pages","get","getNode","values","iterateNodesByType"],"mappings":";;;;;;;AAEA;;AAGA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AAMA;;;;AAMA,MAAMA,kBAAkB,GAAG,iDACzBC,OAAO,CAACC,GAAR,CAAYC,+BADa,yEACuB,EADvB,CAA3B;;AAIO,MAAMC,aAAN,CAAoB;AACzB;AAGAC,EAAAA,WAAW,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAiC;AAC1C,uCAAe;AAAEA,MAAAA;AAAF,KAAf,EAD0C,CAE1C;;AACA,SAAKC,SAAL;AACD;;AAEyB,QAAZC,YAAY,GAA2B;AACnD,UAAMR,kBAAN;;AAEA,UAAMS,YAAY,GAAGC,kBAASC,eAAT,CAA0B,6BAA1B,CAArB;;AACAF,IAAAA,YAAY,CAACG,KAAb;;AACA,QAAI;AACF;AACAC,mBAAMC,QAAN,CAAeC,iBAAQC,WAAR,CAAoBC,eAApB,CAAf,EAFE,CAIF;AACA;;;AACAJ,mBAAMC,QAAN,CAAe;AACbI,QAAAA,IAAI,EAAG,4BADM;AAEbC,QAAAA,OAAO,EAAEC;AAFI,OAAf;;AAKA,WAAK,MAAMC,UAAX,IAAyBC,MAAM,CAACC,IAAP,CAAYC,+BAAZ,CAAzB,EAAmD;AACjD,uDACE;AAAEC,UAAAA,IAAI,EAAEJ,UAAR;AAAoBK,UAAAA,OAAO,EAAG;AAA9B,SADF,EAEG,aAFH,EAGEF,gCAAYH,UAAZ,CAHF;AAKD;;AACD,WAAK,MAAMA,UAAX,IAAyBC,MAAM,CAACC,IAAP,CAAYI,iCAAZ,CAAzB,EAAqD;AACnD,uDACE;AAAEF,UAAAA,IAAI,EAAEJ,UAAR;AAAoBK,UAAAA,OAAO,EAAG;AAA9B,SADF,EAEG,eAFH,EAGEC,kCAAcN,UAAd,CAHF;AAKD;;AAED,UAAI,QAA2B,GAA/B,EAAmC;AACjC,cAAM,4BAAe,cAAf,EAA8B;AAAEO,UAAAA,UAAU,EAAEnB,YAAY,CAACoB;AAA3B,SAA9B,CAAN;AACD,OAFD,MAEO;AACL,cAAM,4BAAe,uBAAf,EAAuC;AAC3CD,UAAAA,UAAU,EAAEnB,YAAY,CAACoB;AADkB,SAAvC,CAAN;AAGD;;AACD,YAAM,4BAAe,2BAAf,EAA2C;AAC/CD,QAAAA,UAAU,EAAEnB,YAAY,CAACoB;AADsB,OAA3C,CAAN,CAjCE,CAqCF;AACA;;AACA,YAAM,kBAAM;AAAEC,QAAAA,iBAAiB,EAAE,KAArB;AAA4BF,QAAAA,UAAU,EAAEnB,YAAY,CAACoB;AAArD,OAAN,CAAN;AAEA,aAAO,IAAIE,4BAAJ,CAAkBlB,YAAlB,CAAP;AACD,KA1CD,SA0CU;AACRJ,MAAAA,YAAY,CAACuB,GAAb;AACD;AACF;;AAEsB,QAATzB,SAAS,GAA2B;AAChD,QAAI,CAAC,KAAK0B,aAAV,EAAyB;AACvB,WAAKA,aAAL,GAAqB,KAAKzB,YAAL,EAArB;AACD;;AACD,WAAO,KAAKyB,aAAZ;AACD;;AAEiB,QAALC,KAAK,GAAkB;AAClC;AACA;AACA;AACA,UAAM,KAAK3B,SAAL,EAAN;AACD;;AAEoB,QAAR4B,QAAQ,CACnBC,KADmB,EAEnBC,OAA4B,GAAG,EAFZ,EAGnBC,IAHmB,EAIO;AAC1B,UAAMC,aAAa,GAAG;AACpBC,MAAAA,SAAS,EAAEC,sBAAKC,EAAL;AADS,KAAtB;;AAIA,UAAMC,UAAU,GAAG,YAAsC;AACvD,UAAI,CAACL,IAAL,EAAW;AACTA,QAAAA,IAAI,GAAG;AACLM,UAAAA,SAAS,EAAG,sBADP;AAELhB,UAAAA,UAAU,EAAEiB;AAFP,SAAP;AAID;;AAED,UAAIC,qBAAJ;AACA,UAAIC,aAAJ;;AACA,UAAI;AACF,YAAIT,IAAI,CAACV,UAAT,EAAqB;AACnBkB,UAAAA,qBAAqB,GAAGpC,kBAASC,eAAT,CACrB,oCADqB,EAEtB;AACEiB,YAAAA,UAAU,EAAEU,IAAI,CAACV;AADnB,WAFsB,CAAxB;AAMAkB,UAAAA,qBAAqB,CAAClC,KAAtB;AACD;;AACDmC,QAAAA,aAAa,GAAG,MAAM,KAAKxC,SAAL,EAAtB;AACD,OAXD,SAWU;AACR,YAAIuC,qBAAJ,EAA2B;AACzBA,UAAAA,qBAAqB,CAACd,GAAtB;AACD;AACF,OAzBsD,CA2BvD;;;AACA,YAAMgB,MAAM,GAAG,MAAMD,aAAa,CAACX,KAAd,CAAoBA,KAApB,EAA2BC,OAA3B,EAAoCC,IAApC,CAArB;AAEA,UAAIW,6CAAJ;;AACA,UAAI;AACF,YAAIX,IAAI,CAACV,UAAT,EAAqB;AACnBqB,UAAAA,6CAA6C,GAC3CvC,kBAASC,eAAT,CAA0B,4BAA1B,EAAuD;AACrDiB,YAAAA,UAAU,EAAEU,IAAI,CAACV;AADoC,WAAvD,CADF;AAIAqB,UAAAA,6CAA6C,CAACrC,KAA9C;AACD;;AACD,cAAM,8CAAkB2B,aAAa,CAACC,SAAhC,CAAN;AACD,OATD,SASU;AACR,YAAIS,6CAAJ,EAAmD;AACjDA,UAAAA,6CAA6C,CAACjB,GAA9C;AACD;AACF;;AACD,aAAOgB,MAAP;AACD,KA9CD;;AAgDA,QAAI;AACF,aAAO,MAAM,yCAAqBT,aAArB,EAAoCI,UAApC,CAAb;AACD,KAFD,SAEU;AACR;AACA9B,mBAAMC,QAAN,CAAe;AACbI,QAAAA,IAAI,EAAG,sBADM;AAEbC,QAAAA,OAAO,EAAEoB;AAFI,OAAf;AAID;AACF;;AAEMW,EAAAA,cAAc,CAACC,QAAD,EAA4C;AAC/D;AACA;AACA,UAAMC,KAAK,GAAG;AACZC,MAAAA,KAAK,EAAE;AACLC,QAAAA,GAAG,CAACH,QAAD,EAA4C;AAC7C,iBAAO,+BAAeI,OAAf,CAAwB,YAAWJ,QAAS,EAA5C,CAAP;AAGD,SALI;;AAMLK,QAAAA,MAAM,GAA0B;AAC9B,iBAAO,+BAAeC,kBAAf,CACJ,UADI,CAAP;AAGD;;AAVI;AADK,KAAd;AAeA,WAAO,oCAAeL,KAAf,EAAsBD,QAAtB,EAAgC,KAAhC,CAAP;AACD;;AAnKwB;;;eAsKZ;AAAE/C,EAAAA;AAAF,C","sourcesContent":["// \"engines-fs-provider\" must be first import, as it sets up global\n// fs and this need to happen before anything else tries to import fs\nimport \"../../utils/engines-fs-provider\"\n\nimport { ExecutionResult, Source } from \"graphql\"\nimport { uuid } from \"gatsby-core-utils\"\nimport { build } from \"../index\"\nimport { setupLmdbStore } from \"../../datastore/lmdb/lmdb-datastore\"\nimport { store } from \"../../redux\"\nimport { actions } from \"../../redux/actions\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { GraphQLRunner, IQueryOptions } from \"../../query/graphql-runner\"\nimport { waitJobsByRequest } from \"../../utils/wait-until-jobs-complete\"\nimport { setGatsbyPluginCache } from \"../../utils/require-gatsby-plugin\"\nimport apiRunnerNode from \"../../utils/api-runner-node\"\nimport type { IGatsbyPage, IGatsbyState } from \"../../redux/types\"\nimport { findPageByPath } from \"../../utils/find-page-by-path\"\nimport { runWithEngineContext } from \"../../utils/engine-context\"\nimport { getDataStore } from \"../../datastore\"\nimport {\n  gatsbyNodes,\n  gatsbyWorkers,\n  flattenedPlugins,\n  // @ts-ignore\n} from \".cache/query-engine-plugins\"\nimport { initTracer } from \"../../utils/tracer\"\n\ntype MaybePhantomActivity =\n  | ReturnType<typeof reporter.phantomActivity>\n  | undefined\n\nconst tracerReadyPromise = initTracer(\n  process.env.GATSBY_OPEN_TRACING_CONFIG_FILE ?? ``\n)\n\nexport class GraphQLEngine {\n  // private schema: GraphQLSchema\n  private runnerPromise?: Promise<GraphQLRunner>\n\n  constructor({ dbPath }: { dbPath: string }) {\n    setupLmdbStore({ dbPath })\n    // start initializing runner ASAP\n    this.getRunner()\n  }\n\n  private async _doGetRunner(): Promise<GraphQLRunner> {\n    await tracerReadyPromise\n\n    const wrapActivity = reporter.phantomActivity(`Initializing GraphQL Engine`)\n    wrapActivity.start()\n    try {\n      // @ts-ignore SCHEMA_SNAPSHOT is being \"inlined\" by bundler\n      store.dispatch(actions.createTypes(SCHEMA_SNAPSHOT))\n\n      // TODO: FLATTENED_PLUGINS needs to be merged with plugin options from gatsby-config\n      //  (as there might be non-serializable options, i.e. functions)\n      store.dispatch({\n        type: `SET_SITE_FLATTENED_PLUGINS`,\n        payload: flattenedPlugins,\n      })\n\n      for (const pluginName of Object.keys(gatsbyNodes)) {\n        setGatsbyPluginCache(\n          { name: pluginName, resolve: `` },\n          `gatsby-node`,\n          gatsbyNodes[pluginName]\n        )\n      }\n      for (const pluginName of Object.keys(gatsbyWorkers)) {\n        setGatsbyPluginCache(\n          { name: pluginName, resolve: `` },\n          `gatsby-worker`,\n          gatsbyWorkers[pluginName]\n        )\n      }\n\n      if (_CFLAGS_.GATSBY_MAJOR === `4`) {\n        await apiRunnerNode(`onPluginInit`, { parentSpan: wrapActivity.span })\n      } else {\n        await apiRunnerNode(`unstable_onPluginInit`, {\n          parentSpan: wrapActivity.span,\n        })\n      }\n      await apiRunnerNode(`createSchemaCustomization`, {\n        parentSpan: wrapActivity.span,\n      })\n\n      // Build runs\n      // Note: skipping inference metadata because we rely on schema snapshot\n      await build({ fullMetadataBuild: false, parentSpan: wrapActivity.span })\n\n      return new GraphQLRunner(store)\n    } finally {\n      wrapActivity.end()\n    }\n  }\n\n  private async getRunner(): Promise<GraphQLRunner> {\n    if (!this.runnerPromise) {\n      this.runnerPromise = this._doGetRunner()\n    }\n    return this.runnerPromise\n  }\n\n  public async ready(): Promise<void> {\n    // We don't want to expose internal runner freely. We do expose `runQuery` function already.\n    // The way internal runner works can change, so we should not make it a public API.\n    // Here we just want to expose way to await it being ready\n    await this.getRunner()\n  }\n\n  public async runQuery(\n    query: string | Source,\n    context: Record<string, any> = {},\n    opts?: IQueryOptions\n  ): Promise<ExecutionResult> {\n    const engineContext = {\n      requestId: uuid.v4(),\n    }\n\n    const doRunQuery = async (): Promise<ExecutionResult> => {\n      if (!opts) {\n        opts = {\n          queryName: `GraphQL Engine query`,\n          parentSpan: undefined,\n        }\n      }\n\n      let gettingRunnerActivity: MaybePhantomActivity\n      let graphqlRunner: GraphQLRunner\n      try {\n        if (opts.parentSpan) {\n          gettingRunnerActivity = reporter.phantomActivity(\n            `Waiting for graphql runner to init`,\n            {\n              parentSpan: opts.parentSpan,\n            }\n          )\n          gettingRunnerActivity.start()\n        }\n        graphqlRunner = await this.getRunner()\n      } finally {\n        if (gettingRunnerActivity) {\n          gettingRunnerActivity.end()\n        }\n      }\n\n      // graphqlRunner creates it's own Span as long as we pass `parentSpan`\n      const result = await graphqlRunner.query(query, context, opts)\n\n      let waitingForJobsCreatedByCurrentRequestActivity: MaybePhantomActivity\n      try {\n        if (opts.parentSpan) {\n          waitingForJobsCreatedByCurrentRequestActivity =\n            reporter.phantomActivity(`Waiting for jobs to finish`, {\n              parentSpan: opts.parentSpan,\n            })\n          waitingForJobsCreatedByCurrentRequestActivity.start()\n        }\n        await waitJobsByRequest(engineContext.requestId)\n      } finally {\n        if (waitingForJobsCreatedByCurrentRequestActivity) {\n          waitingForJobsCreatedByCurrentRequestActivity.end()\n        }\n      }\n      return result\n    }\n\n    try {\n      return await runWithEngineContext(engineContext, doRunQuery)\n    } finally {\n      // Reset job-to-request mapping\n      store.dispatch({\n        type: `CLEAR_JOB_V2_CONTEXT`,\n        payload: engineContext,\n      })\n    }\n  }\n\n  public findPageByPath(pathName: string): IGatsbyPage | undefined {\n    // adapter so `findPageByPath` use SitePage nodes in datastore\n    // instead of `pages` redux slice\n    const state = {\n      pages: {\n        get(pathName: string): IGatsbyPage | undefined {\n          return getDataStore().getNode(`SitePage ${pathName}`) as\n            | IGatsbyPage\n            | undefined\n        },\n        values(): Iterable<IGatsbyPage> {\n          return getDataStore().iterateNodesByType(\n            `SitePage`\n          ) as Iterable<IGatsbyPage>\n        },\n      },\n    } as unknown as IGatsbyState\n\n    return findPageByPath(state, pathName, false)\n  }\n}\n\nexport default { GraphQLEngine }\n"],"file":"entry.js"}
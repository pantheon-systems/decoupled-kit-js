{"version":3,"sources":["../../../src/steps/create-schema-customization/build-types.js"],"names":["unionType","typeBuilderApi","schema","type","pluginOptions","types","possibleTypes","filter","possibleType","typeName","name","map","length","resolveType","node","__typename","extensions","infer","buildUnionType","interfaceType","gatsbyNodeTypes","fieldAliases","fieldBlacklist","state","store","getState","ingestibles","typeMap","remoteSchema","nodeInterfaceTypes","allTypes","values","implementingTypes","Array","from","interfaces","find","singleInterface","get","kind","transformedFields","parentInterfacesImplementingTypes","fields","typeDef","includes","buildInterfaceType","objectType","isAGatsbyNode","parentType","Object","keys","description","interfaceTypeSettings","exclude","buildObjectType","enumType","buildEnumType","enumValues","reduce","accumulator"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport { transformFields } from \"./transform-fields\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport {\n  buildTypeName,\n  fieldOfTypeWasFetched,\n  getTypeSettingsByType,\n  filterTypeDefinition,\n} from \"./helpers\"\n\nconst unionType = typeBuilderApi => {\n  const { schema, type, pluginOptions } = typeBuilderApi\n\n  const types = type.possibleTypes\n    .filter(\n      possibleType =>\n        !typeIsExcluded({\n          pluginOptions,\n          typeName: possibleType.name,\n        })\n    )\n    .map(possibleType => buildTypeName(possibleType.name))\n\n  if (!types || !types.length) {\n    return false\n  }\n\n  let unionType = {\n    name: buildTypeName(type.name),\n    types,\n    resolveType: node => {\n      if (node.__typename) {\n        return buildTypeName(node.__typename)\n      }\n\n      return null\n    },\n    extensions: {\n      infer: false,\n    },\n  }\n\n  // @todo add this as a plugin option\n  unionType = filterTypeDefinition(unionType, typeBuilderApi, `UNION`)\n\n  return schema.buildUnionType(unionType)\n}\n\nconst interfaceType = typeBuilderApi => {\n  const { type, schema, gatsbyNodeTypes, fieldAliases, fieldBlacklist } =\n    typeBuilderApi\n\n  const state = store.getState()\n  const { ingestibles, typeMap } = state.remoteSchema\n  const { nodeInterfaceTypes } = ingestibles\n\n  const allTypes = typeMap.values()\n\n  const implementingTypes = Array.from(allTypes)\n    .filter(\n      ({ interfaces }) =>\n        interfaces &&\n        // find types that implement this interface type\n        interfaces.find(singleInterface => singleInterface.name === type.name)\n    )\n    .map(type => typeMap.get(type.name))\n    .filter(\n      type =>\n        type.kind !== `UNION` ||\n        // if this is a union type, make sure the union type has one or more member types, otherwise schema customization will throw an error\n        (!!type.possibleTypes && !!type.possibleTypes.length)\n    )\n\n  const transformedFields = transformFields({\n    parentInterfacesImplementingTypes: implementingTypes,\n    fields: type.fields,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n  })\n\n  let typeDef = {\n    name: buildTypeName(type.name),\n    fields: transformedFields,\n    extensions: { infer: false },\n  }\n\n  // if this is a node interface type\n  if (nodeInterfaceTypes.includes(type.name)) {\n    // we add nodeType (post type) to all nodes as they're fetched\n    // so we can add them to node interfaces as well in order to filter\n    // by a couple different content types\n    typeDef.fields[`nodeType`] = `String`\n    typeDef.interfaces = [`Node`]\n  } else {\n    // otherwise this is a regular interface type so we need to resolve the type name\n    typeDef.resolveType = node =>\n      node?.__typename ? buildTypeName(node.__typename) : null\n  }\n\n  // @todo add this as a plugin option\n  typeDef = filterTypeDefinition(typeDef, typeBuilderApi, `INTERFACE`)\n\n  return schema.buildInterfaceType(typeDef)\n}\n\nconst objectType = typeBuilderApi => {\n  const {\n    type,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n    schema,\n    isAGatsbyNode,\n  } = typeBuilderApi\n\n  const transformedFields = transformFields({\n    fields: type.fields,\n    parentType: type,\n    gatsbyNodeTypes,\n    fieldAliases,\n    fieldBlacklist,\n  })\n\n  // if all child fields are excluded, this type shouldn't exist.\n  // check null first, otherwise cause:\n  // TypeError: Cannot convert undefined or null to object at Function.keys (<anonymous>)\n  // Also cause wordpress blog site build failure in createSchemaCustomization step\n  if (!transformedFields || !Object.keys(transformedFields).length) {\n    return false\n  }\n\n  let objectType = {\n    name: buildTypeName(type.name),\n    fields: transformedFields,\n    description: type.description,\n    extensions: {\n      infer: false,\n    },\n  }\n\n  if (type.interfaces) {\n    objectType.interfaces = type.interfaces\n      .filter(interfaceType => {\n        const interfaceTypeSettings = getTypeSettingsByType(interfaceType)\n\n        return !interfaceTypeSettings.exclude && fieldOfTypeWasFetched(type)\n      })\n      .map(({ name }) => buildTypeName(name))\n  }\n\n  if (\n    gatsbyNodeTypes.includes(type.name) ||\n    isAGatsbyNode ||\n    // this accounts for Node types that weren't fetched because\n    // they have no root field to fetch a single node of this type\n    // removing them from the schema breaks the build though\n    // @todo instead, if a node type isn't fetched, remove it\n    // from the entire schema\n    type?.interfaces?.find(({ name }) => name === `Node`)\n  ) {\n    // this is used to filter the node interfaces\n    // by different content types (post types)\n    objectType.fields[`nodeType`] = `String`\n\n    objectType.interfaces = [`Node`, ...objectType.interfaces]\n  }\n\n  // @todo add this as a plugin option\n  objectType = filterTypeDefinition(objectType, typeBuilderApi, `OBJECT`)\n\n  return schema.buildObjectType(objectType)\n}\n\nconst enumType = ({ schema, type }) =>\n  schema.buildEnumType({\n    name: buildTypeName(type.name),\n    values: type.enumValues.reduce((accumulator, { name }) => {\n      accumulator[name] = { name }\n\n      return accumulator\n    }, {}),\n    description: type.description,\n  })\n\nexport default { unionType, interfaceType, objectType, enumType }\n"],"file":"build-types.js"}
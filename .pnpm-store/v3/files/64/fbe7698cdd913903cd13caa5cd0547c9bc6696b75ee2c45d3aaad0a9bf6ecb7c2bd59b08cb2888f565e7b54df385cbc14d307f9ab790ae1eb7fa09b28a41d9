{"version":3,"sources":["../../../../src/steps/create-schema-customization/transform-fields/index.js"],"names":["handleCustomScalars","field","fieldTypeIsACustomScalar","type","kind","name","fieldTypeOfTypeIsACustomScalar","ofType","getAliasedFieldName","fieldAliases","returnAliasedFieldName","excludeField","fieldName","thisTypeSettings","fieldBlacklist","parentTypeSettings","parentInterfacesImplementingTypeSettings","excludeFieldNames","includes","find","typeSetting","excludedFieldName","exclude","args","arg","transformFields","fields","parentType","parentInterfacesImplementingTypes","gatsbyNodeTypes","length","map","transformedFields","reduce","fieldsObject","typeMap","store","getState","remoteSchema","get","includedChildFields","filter","childFieldTypeSettings","Array","isArray","transform","description","fieldTransformers","test","transformerApi","transformedField","resolve"],"mappings":"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","sourcesContent":["import { fieldTransformers } from \"./field-transformers\"\nimport store from \"~/store\"\n\nimport {\n  fieldOfTypeWasFetched,\n  typeIsASupportedScalar,\n  getTypeSettingsByType,\n  findTypeName,\n} from \"~/steps/create-schema-customization/helpers\"\n\nimport { buildDefaultResolver } from \"./default-resolver\"\n\nconst handleCustomScalars = field => {\n  const fieldTypeIsACustomScalar =\n    field.type.kind === `SCALAR` && !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.name = `JSON`\n  }\n\n  const fieldTypeOfTypeIsACustomScalar =\n    field.type.ofType &&\n    field.type.ofType.kind === `SCALAR` &&\n    !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeOfTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.ofType.name = `JSON`\n  }\n\n  return field\n}\n\n// this is used to alias fields that conflict with Gatsby node fields\n// for ex Gatsby and WPGQL both have a `parent` field\nexport const getAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? fieldAliases[field.name]\n    : field.name\n\nexport const returnAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? `${fieldAliases[field.name]}: ${field.name}`\n    : field.name\n\nconst excludeField = ({\n  field,\n  fieldName,\n  thisTypeSettings,\n  fieldBlacklist,\n  parentTypeSettings,\n  parentInterfacesImplementingTypeSettings,\n}) =>\n  // this field wasn't previously fetched, so we shouldn't\n  // add it to our schema\n  !fieldOfTypeWasFetched(field.type) ||\n  // this field was excluded on it's parent fields Type\n  (parentTypeSettings.excludeFieldNames &&\n    parentTypeSettings.excludeFieldNames.includes(fieldName)) ||\n  // this field is on an interface type and one of the implementing types has this field excluded on it.\n  (parentInterfacesImplementingTypeSettings &&\n    parentInterfacesImplementingTypeSettings.find(\n      typeSetting =>\n        typeSetting.excludeFieldNames &&\n        typeSetting.excludeFieldNames.find(\n          excludedFieldName => fieldName === excludedFieldName\n        )\n    )) ||\n  // the type of this field was excluded via plugin options\n  thisTypeSettings.exclude ||\n  // field is blacklisted\n  fieldBlacklist.includes(fieldName) ||\n  // this field has required input args\n  (field.args && field.args.find(arg => arg.type.kind === `NON_NULL`)) ||\n  // this field has no typeName\n  !findTypeName(field.type) ||\n  // field is a non null object\n  // @todo this looks unnecessary. Need to look into why non null object types are excluded\n  (field.type.kind === `NON_NULL` && field.type.ofType.kind === `OBJECT`) ||\n  // field is a non null enum\n  (field.type.kind === `NON_NULL` && field.type.ofType.kind === `ENUM`)\n\n/**\n * Transforms fields from the WPGQL schema to work in the Gatsby schema\n * with proper node linking and type namespacing\n * also filters out unusable fields and types\n */\n\nexport const transformFields = ({\n  fields,\n  fieldAliases,\n  fieldBlacklist,\n  parentType,\n  parentInterfacesImplementingTypes,\n  gatsbyNodeTypes,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  const parentTypeSettings = getTypeSettingsByType(parentType)\n\n  const parentInterfacesImplementingTypeSettings =\n    parentInterfacesImplementingTypes\n      ? parentInterfacesImplementingTypes.map(type =>\n          getTypeSettingsByType(type)\n        )\n      : null\n\n  const transformedFields = fields.reduce((fieldsObject, field) => {\n    // if there's no field name this field is unusable\n    if (field.name === ``) {\n      return fieldsObject\n    }\n\n    const thisTypeSettings = getTypeSettingsByType(field.type)\n\n    const fieldName = getAliasedFieldName({ fieldAliases, field })\n\n    if (\n      excludeField({\n        field,\n        fieldName,\n        thisTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    ) {\n      return fieldsObject\n    }\n\n    const { typeMap } = store.getState().remoteSchema\n\n    const type = typeMap.get(findTypeName(field.type))\n\n    const includedChildFields = type?.fields?.filter(field => {\n      const childFieldTypeSettings = getTypeSettingsByType(field.type)\n      const fieldName = getAliasedFieldName({ fieldAliases, field })\n      return !excludeField({\n        field,\n        fieldName,\n        thisTypeSettings: childFieldTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings: thisTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    })\n\n    // if the child fields of this field are all excluded,\n    // we shouldn't add this field\n    // @todo move this to a central location.\n    // if a type is missing all it's child fields due to exclusion\n    // it should be globally excluded automatically.\n    if (Array.isArray(includedChildFields) && !includedChildFields.length) {\n      return fieldsObject\n    }\n\n    field = handleCustomScalars(field)\n\n    const { transform, description } =\n      fieldTransformers.find(({ test }) => test(field)) || {}\n\n    if (transform && typeof transform === `function`) {\n      const transformerApi = {\n        field,\n        fieldsObject,\n        fieldName,\n        gatsbyNodeTypes,\n        description,\n      }\n\n      let transformedField = transform(transformerApi)\n\n      // add default resolver\n      if (typeof transformedField === `string`) {\n        // we need to add a custom resolver to override the default resolver\n        // and check for aliased fields\n        // fields are aliased automatically if they have conflicting types\n        // with other fields of the same name when placed in side-by-side\n        // inlineFragments on the same union or interface type.\n        transformedField = {\n          type: transformedField,\n          resolve: buildDefaultResolver(transformerApi),\n          description: field.description,\n        }\n      } else {\n        transformedField.description = field.description\n      }\n\n      fieldsObject[fieldName] = transformedField\n    }\n\n    return fieldsObject\n  }, {})\n\n  return transformedFields\n}\n"],"file":"index.js"}
{"version":3,"sources":["../../../src/bootstrap/load-plugins/process-plugin.ts"],"names":["processPlugin","plugin","rootDir","parentDir","info","pluginOptions","plugins","options","option","Error","resolve","subPluginPaths","subPluginPath","segments","split","roots","pathToSwap","segment","slice","length","flat","map","root","processed","result","push","name","id","version","modulePath","module","Array","from","undefined"],"mappings":"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","sourcesContent":["import { IPluginInfo, PluginRef } from \"./types\"\nimport { createPluginId } from \"./utils/create-id\"\nimport { resolvePlugin } from \"./resolve-plugin\"\nimport { isString, isEmpty, set, merge } from \"lodash\"\n\nexport function processPlugin(plugin: PluginRef, rootDir: string): IPluginInfo {\n  // Respect the directory that the plugin was sourced from initially\n  rootDir = (!isString(plugin) && plugin.parentDir) || rootDir\n\n  if (isString(plugin)) {\n    const info = resolvePlugin(plugin, rootDir)\n\n    return {\n      ...info,\n      pluginOptions: {\n        plugins: [],\n      },\n    }\n  }\n\n  plugin.options = plugin.options || {}\n\n  // Throw an error if there is an \"option\" key.\n  if (\n    isEmpty(plugin.options) &&\n    !isEmpty((plugin as { option?: unknown }).option)\n  ) {\n    throw new Error(\n      `Plugin \"${plugin.resolve}\" has an \"option\" key in the configuration. Did you mean \"options\"?`\n    )\n  }\n\n  // Plugins can have plugins.\n  if (plugin.subPluginPaths) {\n    for (const subPluginPath of plugin.subPluginPaths) {\n      const segments = subPluginPath.split(`.`)\n      let roots: Array<any> = [plugin.options]\n\n      let pathToSwap = segments\n\n      for (const segment of segments) {\n        if (segment === `[]`) {\n          pathToSwap = pathToSwap.slice(0, pathToSwap.length - 1)\n          roots = roots.flat()\n        } else {\n          roots = roots.map(root => root[segment])\n        }\n      }\n      roots = roots.flat()\n\n      const processed: Array<IPluginInfo> = []\n\n      for (const root of roots) {\n        const result = processPlugin(root, rootDir)\n        processed.push(result)\n      }\n\n      set(plugin.options, pathToSwap, processed)\n    }\n  }\n\n  // Add some default values for tests as we don't actually\n  // want to try to load anything during tests.\n  if (plugin.resolve === `___TEST___`) {\n    const name = `TEST`\n\n    return {\n      id: createPluginId(name, plugin),\n      name,\n      version: `0.0.0-test`,\n      pluginOptions: {\n        plugins: [],\n      },\n      resolve: `__TEST__`,\n    }\n  }\n\n  const info = resolvePlugin(plugin, rootDir)\n\n  return {\n    ...info,\n    modulePath: plugin.modulePath,\n    module: plugin.module,\n    subPluginPaths: plugin.subPluginPaths\n      ? Array.from(plugin.subPluginPaths)\n      : undefined,\n    id: createPluginId(info.name, plugin),\n    pluginOptions: merge({ plugins: [] }, plugin.options),\n  }\n}\n"],"file":"process-plugin.js"}
{"version":3,"sources":["../../../../src/steps/source-nodes/fetch-nodes/fetch-nodes.js"],"names":["fetchWPGQLContentNodes","queryInfo","pluginOptions","helpers","store","getState","gatsbyApi","reporter","url","schema","perPage","nodeListQueries","typeInfo","settings","typeName","nodesTypeName","dispatch","logger","createActivityTimer","allNodesOfContentType","nodeListQuery","contentNodes","first","after","contentTypePlural","pluralName","nodeTypeName","query","stopActivityTimer","length","singular","singularName","plural","getContentTypeQueryInfos","nodeQueries","remoteSchema","queryInfos","Object","values","filter","exclude","getGatsbyNodeTypeNames","typeMap","queryableTypenames","map","implementingNodeTypes","reduce","accumulator","typename","type","get","possibleTypes","name","Set","runFnForEachNodeQuery","fn","chunkSize","requestConcurrency","chunkedQueries","queries","Promise","all","lazyNodes","usingGatsbyV4OrGreater","fetchWPGQLContentNodesByContentType","contentNodeGroups","contentNodeGroup","push","fetchAndCreateAllNodes","activity","activityTimer","start","subscribe","setStatus","entityCount","createdNodeIds","hardCachedNodes","wpgqlNodesByContentType","createNodesActivity","end","key","CREATED_NODE_IDS","value"],"mappings":"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","sourcesContent":["import { createGatsbyNodesFromWPGQLContentNodes } from \"../create-nodes/create-nodes\"\nimport { paginatedWpNodeFetch } from \"./fetch-nodes-paginated\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\nimport { CREATED_NODE_IDS } from \"~/constants\"\nimport { usingGatsbyV4OrGreater } from \"~/utils/gatsby-version\"\n\nimport store from \"~/store\"\nimport { getGatsbyApi, getPluginOptions } from \"~/utils/get-gatsby-api\"\nimport chunk from \"lodash/chunk\"\n\nimport {\n  getHardCachedNodes,\n  restoreHardCachedNodes,\n  setHardCachedNodes,\n  setPersistentCache,\n} from \"~/utils/cache\"\n\n/**\n * fetchWPGQLContentNodes\n *\n * fetches and paginates remote nodes by post type while reporting progress\n */\nexport const fetchWPGQLContentNodes = async ({ queryInfo }) => {\n  const { pluginOptions, helpers } = store.getState().gatsbyApi\n  const { reporter } = helpers\n  const {\n    url,\n    schema: { perPage },\n  } = pluginOptions\n\n  const { nodeListQueries, typeInfo, settings } = queryInfo\n\n  const typeName = typeInfo.nodesTypeName\n\n  store.dispatch.logger.createActivityTimer({\n    typeName,\n    pluginOptions,\n    reporter,\n  })\n\n  let allNodesOfContentType = []\n\n  // there's normally just one query here, but more can be added using the settings.nodeListQueries api\n  for (const nodeListQuery of nodeListQueries) {\n    const contentNodes = await paginatedWpNodeFetch({\n      first: perPage,\n      after: null,\n      contentTypePlural: typeInfo.pluralName,\n      nodeTypeName: typeInfo.nodesTypeName,\n      query: nodeListQuery,\n      url,\n      settings,\n      helpers,\n    })\n\n    allNodesOfContentType = [...allNodesOfContentType, ...contentNodes]\n  }\n\n  store.dispatch.logger.stopActivityTimer({ typeName })\n\n  if (allNodesOfContentType && allNodesOfContentType.length) {\n    return {\n      singular: queryInfo.typeInfo.singularName,\n      plural: queryInfo.typeInfo.pluralName,\n      allNodesOfContentType,\n    }\n  }\n\n  return false\n}\n\n/**\n * getContentTypeQueryInfos\n *\n * returns query infos (Type info & GQL query strings) filtered to\n * remove types that are excluded in the plugin options\n *\n * @returns {Array} Type info & GQL query strings\n */\nexport const getContentTypeQueryInfos = () => {\n  const { nodeQueries } = store.getState().remoteSchema\n  const queryInfos = Object.values(nodeQueries).filter(\n    ({ settings }) => !settings.exclude\n  )\n  return queryInfos\n}\n\nexport const getGatsbyNodeTypeNames = () => {\n  const { typeMap } = store.getState().remoteSchema\n\n  const queryableTypenames = getContentTypeQueryInfos().map(\n    query => query.typeInfo.nodesTypeName\n  )\n\n  const implementingNodeTypes = queryableTypenames.reduce(\n    (accumulator, typename) => {\n      const type = typeMap.get(typename)\n\n      if (type.possibleTypes?.length) {\n        accumulator = [\n          ...accumulator,\n          ...type.possibleTypes.map(({ name }) => name),\n        ]\n      }\n\n      return accumulator\n    },\n    []\n  )\n\n  return [...new Set([...queryableTypenames, ...implementingNodeTypes])]\n}\n\n/**\n * fetchWPGQLContentNodesByContentType\n *\n * fetches nodes from the remote WPGQL server and groups them by post type\n *\n * @returns {Array}\n */\nexport const runFnForEachNodeQuery = async fn => {\n  const nodeQueries = getContentTypeQueryInfos()\n\n  const chunkSize = getPluginOptions()?.schema?.requestConcurrency || 15\n  const chunkedQueries = chunk(nodeQueries, chunkSize)\n\n  for (const queries of chunkedQueries) {\n    await Promise.all(\n      queries.map(async queryInfo => {\n        if (\n          // if the type settings call for lazyNodes, don't fetch them upfront here\n          (queryInfo.settings.lazyNodes &&\n            // but not in Gatsby v4+ since lazyNodes isn't supported in 4+\n            !usingGatsbyV4OrGreater) ||\n          // for media items we only want to fetch referenced nodes so don't fetch them here.\n          queryInfo.typeInfo.nodesTypeName === `MediaItem`\n        ) {\n          return\n        }\n\n        await fn({ queryInfo })\n      })\n    )\n  }\n}\n\nexport const fetchWPGQLContentNodesByContentType = async () => {\n  const contentNodeGroups = []\n\n  await runFnForEachNodeQuery(async ({ queryInfo }) => {\n    const contentNodeGroup = await fetchWPGQLContentNodes({ queryInfo })\n\n    if (contentNodeGroup) {\n      contentNodeGroups.push(contentNodeGroup)\n    }\n  })\n\n  return contentNodeGroups\n}\n\n/**\n * fetchAndCreateAllNodes\n *\n * uses query info (generated from introspection in onPreBootstrap) to\n * fetch and create Gatsby nodes from any lists of nodes in the remote schema\n */\nexport const fetchAndCreateAllNodes = async () => {\n  const { helpers } = getGatsbyApi()\n  const { reporter } = helpers\n\n  //\n  // fetch nodes from WPGQL\n  const activity = reporter.activityTimer(formatLogMessage(`fetching nodes`))\n  activity.start()\n\n  store.subscribe(() => {\n    activity.setStatus(`${store.getState().logger.entityCount} total`)\n  })\n\n  let createdNodeIds\n\n  const hardCachedNodes = await getHardCachedNodes()\n\n  if (!hardCachedNodes) {\n    const wpgqlNodesByContentType = await fetchWPGQLContentNodesByContentType()\n\n    const createNodesActivity = reporter.activityTimer(\n      formatLogMessage(`creating nodes`)\n    )\n    createNodesActivity.start()\n\n    //\n    // Create Gatsby nodes from WPGQL response\n    createdNodeIds = await createGatsbyNodesFromWPGQLContentNodes({\n      wpgqlNodesByContentType,\n      createNodesActivity,\n    })\n\n    await setHardCachedNodes({ helpers })\n\n    createNodesActivity.end()\n    activity.end()\n  } else if (hardCachedNodes) {\n    createdNodeIds = await restoreHardCachedNodes({\n      hardCachedNodes,\n    })\n  }\n\n  // save the node id's so we can touch them on the next build\n  // so that we don't have to refetch all nodes\n  await setPersistentCache({ key: CREATED_NODE_IDS, value: createdNodeIds })\n}\n"],"file":"fetch-nodes.js"}
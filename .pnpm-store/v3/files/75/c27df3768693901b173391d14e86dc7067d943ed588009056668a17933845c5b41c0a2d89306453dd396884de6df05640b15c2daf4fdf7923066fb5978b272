{"version":3,"file":"rematch-immer.esm.js","sources":["../node_modules/immer/dist/immer.module.js","../node_modules/symbol-observable/es/index.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/redux/es/redux.js","../lib/index.js"],"sourcesContent":["var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) { cb(i, value[i], value); }\n  } else {\n    ownKeys(value).forEach(function (key) { return cb(key, value[key], value); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction deepFreeze(obj) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n  Object.freeze(obj);\n  if (Array.isArray(obj)) { obj.forEach(deepFreeze); }else { for (var key in obj) { deepFreeze(obj[key]); } }\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\n// but share them all instead\n\nvar descriptors = {};\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) { markChanged(state); }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nfunction willFinalize$1() {}\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\nvar objectTraps = {\n  get: get$1,\n\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) { return state; }\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createProxy$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n    if (isUnchanged) { return true; }\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  } else if (state.assigned[prop]) {\n    // if an originally not assigned property was deleted\n    delete state.assigned[prop];\n  }\n\n  if (state.copy) { delete state.copy[prop]; }\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n\n  return desc;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) { markChanged$1(state.parent); }\n  }\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n\n    var path = patch.path;\n    var op = patch.op;\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = base[path[i]];\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        // if value is an object, then it's assigned by reference\n        // in the following add or remove ops, the value field inside the patch will also be modifyed\n        // so we use value from the cloned patch\n        base[key] = value;\n        break;\n\n      case \"add\":\n        if (Array.isArray(base)) {\n          // TODO: support \"foo/-\" paths for appending to an array\n          base.splice(key, 0, value);\n        } else {\n          base[key] = value;\n        }\n\n        break;\n\n      case \"remove\":\n        if (Array.isArray(base)) {\n          base.splice(key, 1);\n        } else {\n          delete base[key];\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) { return undefined; }\n    if (result === undefined) { result = base; }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n\n        for (var prop in assigned) {\n          if (!assigned[prop]) { this.onDelete(state, prop); }\n        }\n      } else {\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === state.base[prop]) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze (value, deep) {\n    if ( deep === void 0 ) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    if (deep) { deepFreeze(value); }else { Object.freeze(value); }\n  }\n};\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","import $$observable from 'symbol-observable';\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),\n  REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) return false;\n\n  var proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    if (isDispatching) {\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.REPLACE });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && 'action \"' + String(actionType) + '\"' || 'an action';\n\n  return 'Given ' + actionDescription + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var store = createStore.apply(undefined, args);\n      var _dispatch = function dispatch() {\n        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(undefined, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning(\"You are currently using minified code outside of NODE_ENV === 'production'. \" + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar immer_1 = __importDefault(require(\"immer\"));\nvar redux_1 = require(\"redux\");\nfunction combineReducersWithImmer(reducers) {\n    var reducersWithImmer = {};\n    var _loop_1 = function (key) {\n        var reducerFn = reducers[key];\n        reducersWithImmer[key] = function (state, payload) {\n            return typeof state === 'object'\n                ? immer_1.default(state, function (draft) {\n                    var next = reducerFn(draft, payload);\n                    if (typeof next === 'object')\n                        return next;\n                })\n                : reducerFn(state, payload);\n        };\n    };\n    // reducer must return value because literal don't support immer\n    for (var _i = 0, _a = Object.keys(reducers); _i < _a.length; _i++) {\n        var key = _a[_i];\n        _loop_1(key);\n    }\n    return redux_1.combineReducers(reducersWithImmer);\n}\n// rematch plugin\nvar immerPlugin = function () { return ({\n    config: {\n        redux: {\n            combineReducers: combineReducersWithImmer,\n        },\n    },\n}); };\nexports.default = immerPlugin;\n//# sourceMappingURL=index.js.map"],"names":["obj","NOTHING","Symbol","DRAFTABLE","for","DRAFT_STATE","isDraft","value","isDraftable","isPlainObject","constructor","Array","isArray","proto","Object","getPrototypeOf","prototype","original","base","assign","target","key","has","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","concat","shallowCopy","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","map","cloned","deepFreeze","isFrozen","freeze","ImmerScope","parent","this","drafts","canAutoFreeze","patches","revoke","draft","usePatches","patchListener","inversePatches","leave","current","enter","descriptors","willFinalize","scope","result","isReplaced","finalizing","markChangesSweep","markChangesRecursively","createProxy","clonePotentialDraft","proxyProperty","createHiddenProperty","modified","finalized","assigned","copy","revoke$1","revoked","push","source","state","peek","assertUnrevoked","prepareCopy","set","markChanged","JSON","stringify","hasArrayChanges","hasObjectChanges","object","i$1","i$2","undefined","keys","baseValue","state$1","descriptor","legacyProxy","willFinalize$1","createProxy$1","ref","Proxy","revocable","arrayTraps","objectTraps","proxy","get$1","source$1","set$1","deleteProperty","setPrototypeOf","peek$1","markChanged$1","owner","fn","arguments","apply","isNaN","parseInt","modernProxy","generatePatches","basePath","generateArrayPatches","generateObjectPatches","assign$1","delta","start","end","path","op","replaceCount","path$1","assignedValue","origValue","applyPatches","list","patch","join","splice","verifyMinified","configDefaults","useProxies","autoFreeze","process","name","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","recipe","this$1","defaultBase","self","args","len","hasError","Promise","then","processResult","error","maybeFreeze","produceWithPatches","arg1","arg2","arg3","p","ip","createDraft","isManual","finishDraft","setAutoFreeze","baseDraft","finalize","finalizeTree","root","rootPath","needPatches","finalizeProperty","isDraftProp","deep","immer","applyPatches$1","symbolObservablePonyfill","observable","ponyfill","window","global","module","Function","ActionTypes","INIT","Math","random","toString","substring","split","REPLACE","_typeof","iterator","_extends","createStore","reducer","preloadedState","enhancer","_ref2","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","getState","subscribe","listener","isSubscribed","index","indexOf","dispatch","action","type","listeners","replaceReducer","nextReducer","$$observable","_ref","outerSubscribe","observer","TypeError","observeState","next","unsubscribe","getUndefinedStateErrorMessage","actionType","String","assertReducerShape","reducers","combineReducers","reducerKeys","finalReducers","finalReducerKeys","shapeAssertionError","e","hasChanged","nextState","_i","_key","previousStateForKey","nextStateForKey","errorMessage","bindActionCreator","actionCreator","bindActionCreators","actionCreators","boundActionCreators","compose","_len","funcs","arg","reduce","a","b","applyMiddleware","middlewares","_len2","_key2","store","_dispatch","middlewareAPI","chain","middleware","__importDefault","mod","__esModule","default","exports","immer_1","require$$0","combineReducersWithImmer","reducersWithImmer","_loop_1","reducerFn","payload","_a","redux_1","redux"],"mappings":"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"}
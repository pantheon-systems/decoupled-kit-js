{"version":3,"sources":["../../../../src/utils/worker/child/queries.ts"],"names":["setComponents","saveQueriesDependencies","pickNecessaryQueryState","state","queries","queryNodes","Map","process","env","GATSBY_WORKER_ID","gqlRunner","getGraphqlRunner","GraphQLRunner","store","collectStats","graphqlTracing","getState","program","runQueries","queryIds","actionsToReplay","unsubscribe","subscribe","action","lastAction","type","push","doRunQueries","workerStore","schemaCustomization","composer","graphqlRunner","ready"],"mappings":";;;;;;;AAAA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AASA;;AAEO,SAASA,aAAT,GAA+B;AACpC,uBAAS,CAAE,YAAF,EAAgB,uBAAhB,CAAT;AACD;;AAEM,eAAeC,uBAAf,GAAwD;AAC7D;AACA;AACA,QAAMC,uBAAuB,GAC3BC,KAD8B,IAExB;AAAA;;AACN,QAAI,EAACA,KAAD,aAACA,KAAD,iCAACA,KAAK,CAAEC,OAAR,2CAAC,eAAgBC,UAAjB,CAAJ,EAAiC,OAAOF,KAAP;AACjC,WAAO,EAAE,GAAGA,KAAL;AAAYC,MAAAA,OAAO,EAAE,EAAE,GAAGD,KAAK,CAACC,OAAX;AAAoBC,QAAAA,UAAU,EAAE,IAAIC,GAAJ;AAAhC;AAArB,KAAP;AACD,GALD;;AAMA,qCACE,CAAE,SAAF,CADF,EAEEC,OAAO,CAACC,GAAR,CAAYC,gBAFd,EAGEP,uBAHF,EAT6D,CAe7D;;AACA,QAAM,mDAAN;AACD;;AAED,IAAIQ,SAAJ;;AAEA,SAASC,gBAAT,GAA2C;AACzC,MAAI,CAACD,SAAL,EAAgB;AACdA,IAAAA,SAAS,GAAG,IAAIE,4BAAJ,CAAkBC,YAAlB,EAAyB;AACnCC,MAAAA,YAAY,EAAE,IADqB;AAEnCC,MAAAA,cAAc,EAAEF,aAAMG,QAAN,GAAiBC,OAAjB,CAAyBF;AAFN,KAAzB,CAAZ;AAID;;AACD,SAAOL,SAAP;AACD;;AASM,eAAeQ,UAAf,CACLC,QADK,EAEqB;AAC1B,QAAMC,eAAgC,GAAG,EAAzC;;AAEA,QAAMC,WAAW,GAAGR,aAAMS,SAAN,CAAgB,MAAM;AACxC,UAAMC,MAAM,GAAGV,aAAMG,QAAN,GAAiBQ,UAAhC;;AACA,QACED,MAAM,CAACE,IAAP,KAAiB,aAAjB,IACAF,MAAM,CAACE,IAAP,KAAiB,gBADjB,IAEAF,MAAM,CAACE,IAAP,KAAiB,6BAHnB,CAIE;AACA;AALF,MAME;AACAL,MAAAA,eAAe,CAACM,IAAhB,CAAqBH,MAArB;AACD;AACF,GAXmB,CAApB;;AAaA,MAAI;AACF,UAAMI,YAAY,CAACR,QAAD,CAAlB;AACA,WAAOC,eAAP;AACD,GAHD,SAGU;AACRC,IAAAA,WAAW;AACZ;AACF;;AAED,eAAeM,YAAf,CAA4BR,QAA5B,EAAuE;AACrE,QAAMS,WAAW,GAAGf,aAAMG,QAAN,EAApB,CADqE,CAGrE;;;AACA,MAAIY,WAAW,CAACC,mBAAZ,CAAgCC,QAAhC,KAA6C,IAAjD,EAAuD;AACrD,UAAM,0BAAN;AACD;;AAED,QAAMC,aAAa,GAAGpB,gBAAgB,EAAtC;AAEA,QAAM,gCAAiB;AACrBQ,IAAAA,QADqB;AAErBN,IAAAA,KAAK,EAALA,YAFqB;AAGrBkB,IAAAA;AAHqB,GAAjB,CAAN;AAMA,QAAM,8BAAe;AACnBZ,IAAAA,QADmB;AAEnBN,IAAAA,KAAK,EAALA,YAFmB;AAGnBkB,IAAAA;AAHmB,GAAf,CAAN;AAMA,QAAM,+BAAeC,KAAf,EAAN;AACD","sourcesContent":["import {\n  IGroupedQueryIds,\n  runPageQueries,\n  runStaticQueries,\n} from \"../../../services\"\nimport { savePartialStateToDisk, store } from \"../../../redux\"\nimport { GraphQLRunner } from \"../../../query/graphql-runner\"\nimport { getDataStore } from \"../../../datastore\"\nimport { setState } from \"./state\"\nimport { buildSchema } from \"./schema\"\nimport {\n  IAddPendingPageDataWriteAction,\n  ICreatePageDependencyAction,\n  IGatsbyState,\n  IPageQueryRunAction,\n  IQueryStartAction,\n} from \"../../../redux/types\"\nimport { DeepPartial } from \"redux\"\nimport { waitUntilPageQueryResultsAreStored } from \"../../page-data\"\n\nexport function setComponents(): void {\n  setState([`components`, `staticQueryComponents`])\n}\n\nexport async function saveQueriesDependencies(): Promise<void> {\n  // Drop `queryNodes` from query state - it can be restored from other pieces of state\n  // and is there only as a perf optimization\n  const pickNecessaryQueryState = <T extends DeepPartial<IGatsbyState>>(\n    state: T\n  ): T => {\n    if (!state?.queries?.queryNodes) return state\n    return { ...state, queries: { ...state.queries, queryNodes: new Map() } }\n  }\n  savePartialStateToDisk(\n    [`queries`],\n    process.env.GATSBY_WORKER_ID,\n    pickNecessaryQueryState\n  )\n\n  // make sure page query results we put in lmdb-store are flushed\n  await waitUntilPageQueryResultsAreStored()\n}\n\nlet gqlRunner\n\nfunction getGraphqlRunner(): GraphQLRunner {\n  if (!gqlRunner) {\n    gqlRunner = new GraphQLRunner(store, {\n      collectStats: true,\n      graphqlTracing: store.getState().program.graphqlTracing,\n    })\n  }\n  return gqlRunner\n}\n\ntype ActionsToReplay = Array<\n  | IQueryStartAction\n  | IPageQueryRunAction\n  | IAddPendingPageDataWriteAction\n  | ICreatePageDependencyAction\n>\n\nexport async function runQueries(\n  queryIds: IGroupedQueryIds\n): Promise<ActionsToReplay> {\n  const actionsToReplay: ActionsToReplay = []\n\n  const unsubscribe = store.subscribe(() => {\n    const action = store.getState().lastAction\n    if (\n      action.type === `QUERY_START` ||\n      action.type === `PAGE_QUERY_RUN` ||\n      action.type === `ADD_PENDING_PAGE_DATA_WRITE`\n      // Note: Instead of saving/replaying `CREATE_COMPONENT_DEPENDENCY` action\n      // we do state merging once at the end of the query running (replaying this action is expensive)\n    ) {\n      actionsToReplay.push(action)\n    }\n  })\n\n  try {\n    await doRunQueries(queryIds)\n    return actionsToReplay\n  } finally {\n    unsubscribe()\n  }\n}\n\nasync function doRunQueries(queryIds: IGroupedQueryIds): Promise<void> {\n  const workerStore = store.getState()\n\n  // If buildSchema() didn't run yet, execute it\n  if (workerStore.schemaCustomization.composer === null) {\n    await buildSchema()\n  }\n\n  const graphqlRunner = getGraphqlRunner()\n\n  await runStaticQueries({\n    queryIds,\n    store,\n    graphqlRunner,\n  })\n\n  await runPageQueries({\n    queryIds,\n    store,\n    graphqlRunner,\n  })\n\n  await getDataStore().ready()\n}\n"],"file":"queries.js"}
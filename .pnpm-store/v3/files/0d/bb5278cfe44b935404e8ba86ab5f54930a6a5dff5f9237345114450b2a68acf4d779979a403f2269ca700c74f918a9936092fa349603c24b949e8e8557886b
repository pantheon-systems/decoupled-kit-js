{"version":3,"sources":["../../src/utils/source-nodes.ts"],"names":["deleteNode","actions","discoverPluginsWithoutNodes","storeState","nodes","nodeOwnerSet","Set","forEach","node","add","internal","owner","flattenedPlugins","filter","plugin","nodeAPIs","includes","has","name","map","warnForPluginsWithoutNodes","state","pluginsWithNoNodes","report","warn","getStaleNodes","rootNode","next","undefined","whileCount","parent","console","log","nodesTouched","id","deleteStaleNodes","staleNodes","store","dispatch","isInitialSourcing","sourcingCount","webhookBody","pluginName","parentSpan","deferNodeMutation","traceId","waitForCascadingActions","ready","getState","iterateNodes","apiFinished","apiName"],"mappings":"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","sourcesContent":["import report from \"gatsby-cli/lib/reporter\"\nimport { Span } from \"opentracing\"\nimport apiRunner from \"./api-runner-node\"\nimport { store } from \"../redux\"\nimport { getDataStore, getNode } from \"../datastore\"\nimport { actions } from \"../redux/actions\"\nimport { IGatsbyState, IGatsbyNode } from \"../redux/types\"\nimport type { GatsbyIterable } from \"../datastore/common/iterable\"\n\nconst { deleteNode } = actions\n\n/**\n * Finds the name of all plugins which implement Gatsby APIs that\n * may create nodes, but which have not actually created any nodes.\n */\nfunction discoverPluginsWithoutNodes(\n  storeState: IGatsbyState,\n  nodes: GatsbyIterable<IGatsbyNode>\n): Array<string> {\n  // Find out which plugins own already created nodes\n  const nodeOwnerSet = new Set([`default-site-plugin`])\n  nodes.forEach(node => nodeOwnerSet.add(node.internal.owner))\n\n  return storeState.flattenedPlugins\n    .filter(\n      plugin =>\n        // \"Can generate nodes\"\n        plugin.nodeAPIs.includes(`sourceNodes`) &&\n        // \"Has not generated nodes\"\n        !nodeOwnerSet.has(plugin.name)\n    )\n    .map(plugin => plugin.name)\n}\n\n/**\n * Warn about plugins that should have created nodes but didn't.\n */\nfunction warnForPluginsWithoutNodes(\n  state: IGatsbyState,\n  nodes: GatsbyIterable<IGatsbyNode>\n): void {\n  const pluginsWithNoNodes = discoverPluginsWithoutNodes(state, nodes)\n\n  pluginsWithNoNodes.map(name =>\n    report.warn(\n      `The ${name} plugin has generated no Gatsby nodes. Do you need it?`\n    )\n  )\n}\n\n/**\n * Return the set of nodes for which its root node has not been touched\n */\nfunction getStaleNodes(\n  state: IGatsbyState,\n  nodes: GatsbyIterable<IGatsbyNode>\n): GatsbyIterable<IGatsbyNode> {\n  return nodes.filter(node => {\n    let rootNode = node\n    let next: IGatsbyNode | undefined = undefined\n\n    let whileCount = 0\n    do {\n      next = rootNode.parent ? getNode(rootNode.parent) : undefined\n      if (next) {\n        rootNode = next\n      }\n    } while (next && ++whileCount < 101)\n\n    if (whileCount > 100) {\n      console.log(\n        `It looks like you have a node that's set its parent as itself`,\n        rootNode\n      )\n    }\n\n    return !state.nodesTouched.has(rootNode.id)\n  })\n}\n\n/**\n * Find all stale nodes and delete them\n */\nfunction deleteStaleNodes(\n  state: IGatsbyState,\n  nodes: GatsbyIterable<IGatsbyNode>\n): void {\n  const staleNodes = getStaleNodes(state, nodes)\n\n  staleNodes.forEach(node => store.dispatch(deleteNode(node)))\n}\n\nlet isInitialSourcing = true\nlet sourcingCount = 0\nexport default async ({\n  webhookBody,\n  pluginName,\n  parentSpan,\n  deferNodeMutation = false,\n}: {\n  webhookBody: unknown\n  pluginName?: string\n  parentSpan?: Span\n  deferNodeMutation?: boolean\n}): Promise<void> => {\n  const traceId = isInitialSourcing\n    ? `initial-sourceNodes`\n    : `sourceNodes #${sourcingCount}`\n  await apiRunner(`sourceNodes`, {\n    traceId,\n    waitForCascadingActions: true,\n    deferNodeMutation,\n    parentSpan,\n    webhookBody: webhookBody || {},\n    pluginName,\n  })\n\n  await getDataStore().ready()\n\n  // We only warn for plugins w/o nodes and delete stale nodes on the first sourcing.\n  if (isInitialSourcing) {\n    const state = store.getState()\n    const nodes = getDataStore().iterateNodes()\n\n    warnForPluginsWithoutNodes(state, nodes)\n\n    deleteStaleNodes(state, nodes)\n    isInitialSourcing = false\n  }\n\n  store.dispatch(actions.apiFinished({ apiName: `sourceNodes` }))\n\n  sourcingCount += 1\n}\n"],"file":"source-nodes.js"}
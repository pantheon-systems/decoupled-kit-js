{"version":3,"sources":["../../../../src/datastore/lmdb/query/run-query.ts"],"names":["doRunQuery","args","context","createQueryContext","totalCount","runCountOnce","limit","undefined","skip","canUseIndex","Promise","all","nodeTypeNames","map","typeName","suggestedIndexFields","entries","performIndexScan","performFullTableScan","sortFields","filterContext","length","result","GatsbyIterable","resultOffset","indexMetadata","needsSorting","nodes","usedSkip","filterNodes","concat","canUseIndexForSorting","mergeSorted","createNodeSortComparator","unlimited","sortedNodes","sortNodesInMemory","actualSkip","slice","runCount","count","needsFiltering","datastore","countNodes","completeFiltering","iterateNodesByType","_","e","usedQueries","reverse","Array","from","values","value","getNode","filter","Boolean","intermediateResult","Set","dbQueries","isFullyFiltered","resolvedNodes","store","getState","resolvedNodesCache","filtersToApply","q","has","node","resolvedFields","get","internal","type","id","dottedField","tmp","isArray","some","v","arr","sort","queryArgs","firstOnly","databases","Map","fields","field","i","order","size","index","indexKeyFields","keyFields","sortOrder","nodeComparator","a","b","resolvedAFields","resolvedBFields","direction","valueA","valueB","compareByKeySuffix","prefixLength","aSuffix","key","bSuffix"],"mappings":"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","sourcesContent":["import {\n  IDataStore,\n  ILmdbDatabases,\n  IQueryResult,\n  IRunQueryArgs,\n} from \"../../types\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  createDbQueriesFromObject,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  prepareQueryArgs,\n} from \"../../common/query\"\nimport {\n  createIndex,\n  getIndexMetadata,\n  IIndexMetadata,\n  IndexFields,\n} from \"./create-index\"\nimport {\n  countUsingIndexOnly,\n  filterUsingIndex,\n  IIndexEntry,\n} from \"./filter-using-index\"\nimport { store } from \"../../../redux\"\nimport { isDesc, resolveFieldValue, matchesFilter, compareKey } from \"./common\"\nimport { suggestIndex } from \"./suggest-index\"\n\ninterface IDoRunQueryArgs extends IRunQueryArgs {\n  databases: ILmdbDatabases\n  datastore: IDataStore\n}\n\ntype SortFields = Map<string, number>\n\ninterface IQueryContext {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  sortFields: SortFields\n  nodeTypeNames: Array<string>\n  suggestedIndexFields: IndexFields\n  indexMetadata?: IIndexMetadata\n  limit?: number\n  skip: number\n  totalCount?: number\n}\n\nexport async function doRunQuery(args: IDoRunQueryArgs): Promise<IQueryResult> {\n  // Note: Keeping doRunQuery method the only async method in chain for perf\n  const context = createQueryContext(args)\n\n  const totalCount = async (): Promise<number> =>\n    runCountOnce({ ...context, limit: undefined, skip: 0 })\n\n  if (canUseIndex(context)) {\n    await Promise.all(\n      context.nodeTypeNames.map(typeName =>\n        createIndex(context, typeName, context.suggestedIndexFields)\n      )\n    )\n    return { entries: performIndexScan(context), totalCount }\n  }\n  return { entries: performFullTableScan(context), totalCount }\n}\n\nfunction performIndexScan(context: IQueryContext): GatsbyIterable<IGatsbyNode> {\n  const { suggestedIndexFields, sortFields } = context\n\n  const filterContext =\n    context.nodeTypeNames.length === 1\n      ? context\n      : {\n          ...context,\n          skip: 0,\n          limit:\n            typeof context.limit === `undefined`\n              ? undefined\n              : context.skip + context.limit,\n        }\n\n  let result = new GatsbyIterable<IGatsbyNode>([])\n  let resultOffset = filterContext.skip\n  for (const typeName of context.nodeTypeNames) {\n    const indexMetadata = getIndexMetadata(\n      context,\n      typeName,\n      suggestedIndexFields\n    )\n    if (!needsSorting(context)) {\n      const { nodes, usedSkip } = filterNodes(filterContext, indexMetadata)\n      result = result.concat(nodes)\n      resultOffset = usedSkip\n      continue\n    }\n    if (canUseIndexForSorting(indexMetadata, sortFields)) {\n      const { nodes, usedSkip } = filterNodes(filterContext, indexMetadata)\n      // Interleave nodes of different types (not expensive for already sorted chunks)\n      result = result.mergeSorted(nodes, createNodeSortComparator(sortFields))\n      resultOffset = usedSkip\n      continue\n    }\n    // The sad part - unlimited filter + in-memory sort\n    const unlimited = { ...context, skip: 0, limit: undefined }\n    const { nodes, usedSkip } = filterNodes(unlimited, indexMetadata)\n    const sortedNodes = sortNodesInMemory(context, nodes)\n    resultOffset = usedSkip\n\n    result = result.mergeSorted(\n      sortedNodes,\n      createNodeSortComparator(sortFields)\n    )\n  }\n  const { limit, skip = 0 } = context\n  const actualSkip = skip - resultOffset\n\n  if (limit || actualSkip) {\n    result = result.slice(actualSkip, limit ? actualSkip + limit : undefined)\n  }\n  return result\n}\n\nfunction runCountOnce(context: IQueryContext): number {\n  if (typeof context.totalCount === `undefined`) {\n    context.totalCount = runCount(context)\n  }\n  return context.totalCount\n}\n\nfunction runCount(context: IQueryContext): number {\n  let count = 0\n\n  if (!needsFiltering(context)) {\n    for (const typeName of context.nodeTypeNames) {\n      count += context.datastore.countNodes(typeName)\n    }\n    return count\n  }\n\n  if (!canUseIndex(context)) {\n    for (const typeName of context.nodeTypeNames) {\n      const nodes = completeFiltering(\n        context,\n        new GatsbyIterable(context.datastore.iterateNodesByType(typeName))\n      )\n      for (const _ of nodes) count++\n    }\n    return count\n  }\n\n  for (const typeName of context.nodeTypeNames) {\n    const indexMetadata = getIndexMetadata(\n      context,\n      typeName,\n      context.suggestedIndexFields\n    )\n    try {\n      count += countUsingIndexOnly({ ...context, indexMetadata })\n    } catch (e) {\n      // We cannot reliably count using index - fallback to full iteration :/\n      for (const _ of filterNodes(context, indexMetadata).nodes) count++\n    }\n  }\n  return count\n}\n\nfunction performFullTableScan(\n  context: IQueryContext\n): GatsbyIterable<IGatsbyNode> {\n  // console.warn(`Fallback to full table scan :/`)\n\n  const { datastore, nodeTypeNames } = context\n\n  let result = new GatsbyIterable<IGatsbyNode>([])\n  for (const typeName of nodeTypeNames) {\n    let nodes = new GatsbyIterable(datastore.iterateNodesByType(typeName))\n    nodes = completeFiltering(context, nodes)\n\n    if (needsSorting(context)) {\n      nodes = sortNodesInMemory(context, nodes)\n      result = result.mergeSorted(\n        nodes,\n        createNodeSortComparator(context.sortFields)\n      )\n    } else {\n      result = result.concat(nodes)\n    }\n  }\n  const { limit, skip = 0 } = context\n\n  if (limit || skip) {\n    result = result.slice(skip, limit ? skip + limit : undefined)\n  }\n  return result\n}\n\nfunction filterNodes(\n  context: IQueryContext,\n  indexMetadata: IIndexMetadata\n): { nodes: GatsbyIterable<IGatsbyNode>; usedSkip: number } {\n  const { entries, usedQueries, usedSkip } = filterUsingIndex({\n    ...context,\n    indexMetadata,\n    reverse: Array.from(context.sortFields.values())[0] === -1,\n  })\n  const nodes = entries\n    .map(({ value }) => context.datastore.getNode(value))\n    .filter(Boolean)\n\n  return {\n    nodes: completeFiltering(\n      context,\n      nodes as GatsbyIterable<IGatsbyNode>,\n      usedQueries\n    ),\n    usedSkip,\n  }\n}\n\n/**\n * Takes intermediate result and applies any remaining filterQueries.\n *\n * If result is already fully filtered - simply returns.\n */\nfunction completeFiltering(\n  context: IQueryContext,\n  intermediateResult: GatsbyIterable<IGatsbyNode>,\n  usedQueries: Set<DbQuery> = new Set()\n): GatsbyIterable<IGatsbyNode> {\n  const { dbQueries } = context\n  if (isFullyFiltered(dbQueries, usedQueries)) {\n    return intermediateResult\n  }\n  // Apply remaining filter operations directly (last resort: slow)\n  const resolvedNodes = store.getState().resolvedNodesCache\n\n  const filtersToApply: Array<[string, IDbFilterStatement]> = dbQueries\n    .filter(q => !usedQueries.has(q))\n    .map(q => [dbQueryToDottedField(q), getFilterStatement(q)])\n\n  return intermediateResult.filter(node => {\n    const resolvedFields = resolvedNodes?.get(node.internal.type)?.get(node.id)\n\n    for (const [dottedField, filter] of filtersToApply) {\n      const tmp = resolveFieldValue(dottedField, node, resolvedFields)\n      const value = Array.isArray(tmp) ? tmp : [tmp]\n      if (value.some(v => !matchesFilter(filter, v))) {\n        // Mimic AND semantics\n        return false\n      }\n    }\n    return true\n  })\n}\n\nfunction sortNodesInMemory(\n  context: IQueryContext,\n  nodes: GatsbyIterable<IGatsbyNode>\n): GatsbyIterable<IGatsbyNode> {\n  // TODO: Sort using index data whenever possible (maybe store data needed for sorting in index values)\n  // TODO: Nodes can be partially sorted by index prefix - we can (and should) exploit this\n  return new GatsbyIterable(() => {\n    const arr = Array.from(nodes)\n    arr.sort(createNodeSortComparator(context.sortFields))\n    return arr\n  })\n}\n\nfunction createQueryContext(args: IDoRunQueryArgs): IQueryContext {\n  const { queryArgs: { filter, sort, limit, skip = 0 } = {}, firstOnly } = args\n\n  return {\n    datastore: args.datastore,\n    databases: args.databases,\n    nodeTypeNames: args.nodeTypeNames,\n    dbQueries: createDbQueriesFromObject(prepareQueryArgs(filter)),\n    sortFields: new Map<string, number>(\n      sort?.fields.map((field, i) => [field, isDesc(sort?.order[i]) ? -1 : 1])\n    ),\n    suggestedIndexFields: new Map(suggestIndex({ filter, sort })),\n    limit: firstOnly ? 1 : limit,\n    skip,\n  }\n}\n\nfunction canUseIndex(context: IQueryContext): boolean {\n  return context.suggestedIndexFields.size > 0\n}\n\nfunction needsFiltering(context: IQueryContext): boolean {\n  return context.dbQueries.length > 0\n}\n\nfunction needsSorting(context: IQueryContext): boolean {\n  return context.sortFields.size > 0\n}\n\n/**\n * Based on assumption that if all sort fields exist in index\n * then any result received from this index is fully sorted\n */\nfunction canUseIndexForSorting(\n  index: IIndexMetadata,\n  sortFields: SortFields\n): boolean {\n  const indexKeyFields = new Map(index.keyFields)\n  for (const [field, sortOrder] of sortFields) {\n    if (indexKeyFields.get(field) !== sortOrder) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isFullyFiltered(\n  dbQueries: Array<DbQuery>,\n  usedQueries: Set<DbQuery>\n): boolean {\n  return dbQueries.length === usedQueries.size\n}\n\nfunction createNodeSortComparator(sortFields: SortFields): (a, b) => number {\n  const resolvedNodesCache = store.getState().resolvedNodesCache\n\n  return function nodeComparator(a: IGatsbyNode, b: IGatsbyNode): number {\n    const resolvedAFields = resolvedNodesCache?.get(a.internal.type)?.get(a.id)\n    const resolvedBFields = resolvedNodesCache?.get(b.internal.type)?.get(b.id)\n\n    for (const [field, direction] of sortFields) {\n      const valueA: any = resolveFieldValue(field, a, resolvedAFields)\n      const valueB: any = resolveFieldValue(field, b, resolvedBFields)\n\n      if (valueA > valueB) {\n        return direction === 1 ? 1 : -1\n      } else if (valueA < valueB) {\n        return direction === 1 ? -1 : 1\n      }\n    }\n    return 0\n  }\n}\n\nexport function compareByKeySuffix(prefixLength: number) {\n  return function (a: IIndexEntry, b: IIndexEntry): number {\n    const aSuffix = a.key.slice(prefixLength)\n    const bSuffix = b.key.slice(prefixLength)\n    // @ts-ignore\n    return compareKey(aSuffix, bSuffix)\n  }\n}\n"],"file":"run-query.js"}
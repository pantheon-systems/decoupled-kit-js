{"version":3,"sources":["../../src/utils/node-manifest.ts"],"names":["findPageOwnedByNode","nodeId","slug","state","store","getState","pages","nodes","byNode","queries","pagePath","get","values","next","value","foundPageBy","ownerPagePath","foundOwnerNodeId","pageObject","path","fullPage","ownerNodeId","foundPageIdInContext","context","id","foundPageSlugInContext","pageCreatedByPluginName","pluginCreatorId","name","pageCreatedByFilesystemPlugin","page","foundPageByToLogIds","none","queryTracking","warnAboutNodeManifestMappingProblems","inputManifest","verbose","logId","reporter","error","Error","processNodeManifest","listOfUniqueErrorIds","nodeManifestPagePathMap","verboseLogs","node","fullNode","noNodeWarningId","pluginName","add","nodeManifestPage","nodeManifestMappingProblemsContext","finalManifest","gatsbySiteDirectory","program","directory","fileNameBase","manifestId","process","platform","replace","manifestFilePath","join","manifestFileDir","dirname","fs","ensureDir","writeJSON","info","set","processNodeManifests","env","gatsby_log_level","VERBOSE_NODE_MANIFEST","startTime","Date","now","nodeManifests","totalManifests","length","totalProcessedManifests","totalFailedManifests","Map","Set","processNodeManifestTask","manifest","cb","processedManifest","setImmediate","processNodeManifestQueue","push","idle","Promise","resolve","drain","pluralize","endTime","size","dispatch","internalActions","deleteNodeManifests"],"mappings":"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","sourcesContent":["import type { ErrorId } from \"gatsby-cli/lib/structured-errors/error-map\"\nimport { getNode } from \"./../datastore\"\nimport { IGatsbyPage, INodeManifest } from \"./../redux/types\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { store } from \"../redux/\"\nimport { internalActions } from \"../redux/actions\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport fastq from \"fastq\"\n\ninterface INodeManifestPage {\n  path?: string\n}\n\n/**\n * This it the output after processing calls to the public unstable_createNodeManifest action\n */\ninterface INodeManifestOut {\n  page: INodeManifestPage\n  node: {\n    id: string\n  }\n  foundPageBy: FoundPageBy\n}\n\ntype FoundPageBy =\n  | `ownerNodeId`\n  | `filesystem-route-api`\n  // for these three we warn to use ownerNodeId instead\n  | `context.id`\n  | `context.slug`\n  | `queryTracking`\n  | `none`\n\n/**\n * Finds a final built page by nodeId or by node.slug as a fallback.\n *\n * Note that this function wont work properly in `gatsby develop`\n * since develop no longer runs all page queries when creating pages.\n * We use the node id to query mapping to find the right page but\n * this mapping only exists once you've visited a page in your browser.\n * When this fn is being used for routing to previews the user wont necessarily have\n * visited the page in the browser yet.\n */\nasync function findPageOwnedByNode({\n  nodeId,\n  slug,\n}: {\n  nodeId: string\n  slug?: string\n}): Promise<{\n  page: INodeManifestPage\n  foundPageBy: FoundPageBy\n}> {\n  const state = store.getState()\n  const { pages, nodes } = state\n  const { byNode } = state.queries\n\n  // the default page path is the first page found in\n  // node id to page query tracking\n  let pagePath = byNode?.get(nodeId)?.values()?.next()?.value\n\n  let foundPageBy: FoundPageBy = pagePath ? `queryTracking` : `none`\n\n  if (pages) {\n    let ownerPagePath: string | undefined\n    let foundOwnerNodeId = false\n\n    // for each page this nodeId is queried in\n    for (const pageObject of pages.values()) {\n      // if we haven't found a page with this nodeId\n      // set as page.ownerNodeId then run this logic.\n      // this condition is on foundOwnerNodeId instead of ownerPagePath\n      // in case we find a page with the nodeId in page.context.id/context.slug\n      // and then later in the loop there's a page with this nodeId\n      // set on page.ownerNodeId.\n      // We always want to prefer ownerPagePath over context.id/context.slug\n      if (foundOwnerNodeId) {\n        break\n      }\n\n      const path = pageObject.path\n\n      const fullPage: IGatsbyPage | undefined = pages.get(path)\n\n      foundOwnerNodeId = fullPage?.ownerNodeId === nodeId\n\n      const foundPageIdInContext = fullPage?.context?.id === nodeId\n\n      // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n      const foundPageSlugInContext = slug && fullPage?.context?.slug === slug\n\n      if (foundOwnerNodeId) {\n        foundPageBy = `ownerNodeId`\n      } else if (foundPageIdInContext && fullPage) {\n        const pageCreatedByPluginName = nodes.get(\n          fullPage.pluginCreatorId\n        )?.name\n\n        const pageCreatedByFilesystemPlugin =\n          pageCreatedByPluginName === `gatsby-plugin-page-creator`\n\n        foundPageBy = pageCreatedByFilesystemPlugin\n          ? `filesystem-route-api`\n          : `context.id`\n      } else if (foundPageSlugInContext && fullPage) {\n        foundPageBy = `context.slug`\n      }\n\n      if (\n        fullPage &&\n        // first check for the ownerNodeId on the page. this is\n        // the defacto owner. Can't get more specific than this\n        (foundOwnerNodeId ||\n          // if there's no specified owner look to see if\n          // pageContext has an `id` variable which matches our\n          // nodeId. Using an \"id\" as a variable in queries is common\n          // and if we don't have an owner this is a better guess\n          // of an owner than grabbing the first page query we find\n          // that's mapped to this node id.\n          // this also makes this work with the filesystem Route API without\n          // changing that API.\n          foundPageIdInContext ||\n          foundPageSlugInContext)\n      ) {\n        // save this path to use in our manifest!\n        ownerPagePath = fullPage.path\n      }\n    }\n\n    if (ownerPagePath) {\n      pagePath = ownerPagePath\n    }\n  }\n\n  return {\n    page: {\n      path: pagePath || null,\n    },\n    foundPageBy,\n  }\n}\n\n// these id's correspond to error id's in\n// packages/gatsby-cli/src/structured-errors/error-map.ts\nexport const foundPageByToLogIds = {\n  none: `11801`,\n  [`context.id`]: `11802`,\n  [`context.slug`]: `11805`,\n  queryTracking: `11803`,\n  [`filesystem-route-api`]: `success`,\n  ownerNodeId: `success`,\n}\n\n/**\n * Takes in some info about a node manifest and the page we did or didn't find for it, then warns and returns the warning string\n */\nexport function warnAboutNodeManifestMappingProblems({\n  inputManifest,\n  pagePath,\n  foundPageBy,\n  verbose,\n}: {\n  inputManifest: INodeManifest\n  pagePath?: string\n  foundPageBy: FoundPageBy\n  verbose: boolean\n}): { logId: string } {\n  let logId: ErrorId | `success`\n\n  switch (foundPageBy) {\n    case `none`:\n    case `context.id`:\n    case `context.slug`:\n    case `queryTracking`: {\n      logId = foundPageByToLogIds[foundPageBy]\n      if (verbose) {\n        reporter.error({\n          id: logId,\n          context: {\n            inputManifest,\n            pagePath,\n          },\n        })\n      }\n      break\n    }\n\n    case `filesystem-route-api`:\n    case `ownerNodeId`:\n      logId = `success`\n      break\n\n    default: {\n      throw Error(`Node Manifest mapping is in an impossible state`)\n    }\n  }\n\n  return {\n    logId,\n  }\n}\n\n/**\n * Prepares and then writes out an individual node manifest file to be used for routing to previews. Manifest files are added via the public unstable_createNodeManifest action\n */\nexport async function processNodeManifest(\n  inputManifest: INodeManifest,\n  listOfUniqueErrorIds: Set<string>,\n  nodeManifestPagePathMap: Map<string, string>,\n  verboseLogs: boolean\n): Promise<null | INodeManifestOut> {\n  const nodeId = inputManifest.node.id\n  const fullNode = getNode(nodeId)\n  const noNodeWarningId = `11804`\n\n  if (!fullNode) {\n    if (verboseLogs) {\n      reporter.error({\n        id: noNodeWarningId,\n        context: {\n          pluginName: inputManifest.pluginName,\n          nodeId,\n        },\n      })\n    } else {\n      listOfUniqueErrorIds.add(noNodeWarningId)\n    }\n\n    return null\n  }\n\n  // map the node to a page that was created\n  const { page: nodeManifestPage, foundPageBy } = await findPageOwnedByNode({\n    nodeId,\n    // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n    slug: fullNode?.slug as string,\n  })\n\n  const nodeManifestMappingProblemsContext = {\n    inputManifest,\n    pagePath: nodeManifestPage.path,\n    foundPageBy,\n    verbose: verboseLogs,\n  }\n\n  if (verboseLogs) {\n    warnAboutNodeManifestMappingProblems(nodeManifestMappingProblemsContext)\n  } else {\n    const { logId } = warnAboutNodeManifestMappingProblems(\n      nodeManifestMappingProblemsContext\n    )\n\n    if (logId !== `success`) {\n      listOfUniqueErrorIds.add(logId)\n    }\n  }\n\n  const finalManifest: INodeManifestOut = {\n    node: inputManifest.node,\n    page: nodeManifestPage,\n    foundPageBy,\n  }\n\n  const gatsbySiteDirectory = store.getState().program.directory\n\n  let fileNameBase = inputManifest.manifestId\n\n  /**\n   * Windows has a handful of special/reserved characters that are not valid in a file path\n   * @reference https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os\n   *\n   * The two exceptions to the list linked above are\n   * - the colon that is part of the hard disk partition name at the beginning of a file path (i.e. C:)\n   * - backslashes. We don't want to replace backslashes because those are used to delineate what the actual file path is\n   *\n   * During local development, node manifests can be written to disk but are generally unused as they are only used\n   * for Content Sync which runs in Gatsby Cloud. Gatsby cloud is a Linux environment in which these special chars are valid in\n   * filepaths. To avoid errors on Windows, we replace all instances of the special chars in the filepath (with the exception of the\n   * hard disk partition name) with \"-\" to ensure that local Windows development setups do not break when attempting\n   * to write one of these manifests to disk.\n   */\n  if (process.platform === `win32`) {\n    fileNameBase = fileNameBase.replace(/:|\\/|\\*|\\?|\"|<|>|\\||\\\\/g, `-`)\n  }\n\n  // write out the manifest file\n  const manifestFilePath = path.join(\n    gatsbySiteDirectory,\n    `public`,\n    `__node-manifests`,\n    inputManifest.pluginName,\n    `${fileNameBase}.json`\n  )\n\n  const manifestFileDir = path.dirname(manifestFilePath)\n\n  await fs.ensureDir(manifestFileDir)\n  await fs.writeJSON(manifestFilePath, finalManifest)\n\n  if (verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase}`\n    )\n  }\n\n  if (nodeManifestPage.path) {\n    nodeManifestPagePathMap.set(nodeManifestPage.path, fileNameBase)\n  }\n\n  return finalManifest\n}\n\n/**\n * Grabs all pending node manifests, processes them, writes them to disk,\n * and then removes them from the store.\n * Manifest files are added via the public unstable_createNodeManifest action in sourceNodes\n */\nexport async function processNodeManifests(): Promise<Map<\n  string,\n  string\n> | null> {\n  const verboseLogs =\n    process.env.gatsby_log_level === `verbose` ||\n    process.env.VERBOSE_NODE_MANIFEST === `true`\n\n  const startTime = Date.now()\n  const { nodeManifests } = store.getState()\n\n  const totalManifests = nodeManifests.length\n\n  if (totalManifests === 0) {\n    return null\n  }\n\n  let totalProcessedManifests = 0\n  let totalFailedManifests = 0\n  const nodeManifestPagePathMap: Map<string, string> = new Map()\n  const listOfUniqueErrorIds: Set<string> = new Set()\n\n  async function processNodeManifestTask(\n    manifest: INodeManifest,\n    cb: fastq.done<any>\n  ): Promise<void> {\n    const processedManifest = await processNodeManifest(\n      manifest,\n      listOfUniqueErrorIds,\n      nodeManifestPagePathMap,\n      verboseLogs\n    )\n\n    if (processedManifest) {\n      totalProcessedManifests++\n    } else {\n      totalFailedManifests++\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many manifests\n    setImmediate(() => cb(null, true))\n    return\n  }\n\n  const processNodeManifestQueue = fastq(processNodeManifestTask, 25)\n\n  for (const manifest of nodeManifests) {\n    processNodeManifestQueue.push(manifest, () => {})\n  }\n\n  if (!processNodeManifestQueue.idle()) {\n    await new Promise(resolve => {\n      processNodeManifestQueue.drain = resolve as () => unknown\n    })\n  }\n\n  const pluralize = (length: number): string =>\n    length > 1 || length === 0 ? `s` : ``\n\n  const endTime = Date.now()\n\n  reporter.info(\n    `Wrote out ${totalProcessedManifests} node page manifest file${pluralize(\n      totalProcessedManifests\n    )} in ${endTime - startTime} ms. ${\n      totalFailedManifests > 0\n        ? `. ${totalFailedManifests} manifest${pluralize(\n            totalFailedManifests\n          )} couldn't be processed.`\n        : ``\n    }`\n  )\n\n  reporter.info(\n    (!verboseLogs && listOfUniqueErrorIds.size > 0\n      ? `unstable_createNodeManifest produced warnings [${[\n          ...listOfUniqueErrorIds,\n        ].join(`, `)}]. `\n      : ``) +\n      `To see full warning messages set process.env.VERBOSE_NODE_MANIFEST to \"true\".\\nVisit https://gatsby.dev/nodemanifest for more info on Node Manifests.`\n  )\n\n  // clean up all pending manifests from the store\n  store.dispatch(internalActions.deleteNodeManifests())\n  return nodeManifestPagePathMap\n}\n"],"file":"node-manifest.js"}